/* automatically generated by rust-bindgen 0.56.0 */

#[allow(non_camel_case_types,non_snake_case,non_upper_case_globals,dead_code)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const OS_CONTEXT_TAG: u64 = 5715986497936849012;
pub const OS_THREAD_TAG: u32 = 1950904900;
pub const OS_ALARM_QUEUE_TAG: u32 = 1632398673;
pub const OS_ALARM_TAG: u32 = 1632399949;
pub const OS_CONDITION_TAG: u32 = 1666081878;
pub const OS_EVENT_TAG: u32 = 1700163156;
pub const OS_FAST_CONDITION_TAG: u32 = 1716413526;
pub const OS_FAST_MUTEX_TAG: u32 = 1716352088;
pub const OS_MESSAGE_QUEUE_TAG: u32 = 1834182481;
pub const OS_PAGE_SIZE: u32 = 131072;
pub const OS_MUTEX_TAG: u32 = 1834316888;
pub const OS_SEMAPHORE_TAG: u32 = 1934649426;
pub const GX2_FALSE: u32 = 0;
pub const GX2_TRUE: u32 = 1;
pub const GX2_DISABLE: u32 = 0;
pub const GX2_ENABLE: u32 = 1;
pub const GX2_COMMAND_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_CONTEXT_STATE_ALIGNMENT: u32 = 256;
pub const GX2_SCAN_BUFFER_ALIGNMENT: u32 = 4096;
pub const GX2_SHADER_PROGRAM_ALIGNMENT: u32 = 256;
pub const GX2_VERTEX_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_INDEX_BUFFER_ALIGNMENT: u32 = 32;
pub const GX2_COMMAND_BUFFER_SIZE: u32 = 4194304;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const FD_SETSIZE: u32 = 32;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 4321;
pub const _QUAD_HIGHWORD: u32 = 0;
pub const _QUAD_LOWWORD: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 4321;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SOL_SOCKET: i32 = -1;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const PF_UNSPEC: u32 = 0;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 23;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 23;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_DONTWAIT: u32 = 32;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_BROADCAST: u32 = 32;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_TCPSACK: u32 = 512;
pub const SO_WINSCALE: u32 = 1024;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_TYPE: u32 = 4104;
pub const SO_ERROR: u32 = 4105;
pub const SO_NBIO: u32 = 4116;
pub const SO_BIO: u32 = 4117;
pub const SO_NONBLOCK: u32 = 4118;
pub const NSN_EAGAIN: u32 = 6;
pub const NSN_EWOULDBLOCK: u32 = 6;
extern "C" {
    pub fn __assert(arg1: *const cty::c_char, arg2: cty::c_int, arg3: *const cty::c_char);
}
extern "C" {
    pub fn __assert_func(
        arg1: *const cty::c_char,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: *const cty::c_char,
    );
}
pub type size_t = cty::c_ulong;
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<max_align_t>())).__max_align_ll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<max_align_t>())).__max_align_ld as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ld)
        )
    );
}
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_long;
pub type __uintptr_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
pub type BOOL = i32;
pub mod AVMDrcScanMode {
    pub type Type = cty::c_uint;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_0: Type = 0;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_1: Type = 1;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_3: Type = 3;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_255: Type = 255;
}
extern "C" {
    pub fn AVMGetDRCScanMode(outScanMode: *mut AVMDrcScanMode::Type) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSContext {
    #[doc = "! Should always be set to the value OS_CONTEXT_TAG."]
    pub tag: u64,
    pub gpr: [u32; 32usize],
    pub cr: u32,
    pub lr: u32,
    pub ctr: u32,
    pub xer: u32,
    pub srr0: u32,
    pub srr1: u32,
    pub dsisr: u32,
    pub dar: u32,
    pub __unk0: [cty::c_char; 12usize],
    pub fpscr: u32,
    pub fpr: [f64; 32usize],
    pub spinLockCount: u16,
    pub state: u16,
    pub gqr: [u32; 8usize],
    pub __unk1: [cty::c_char; 4usize],
    pub psf: [f64; 32usize],
    pub coretime: [u64; 3usize],
    pub starttime: u64,
    pub error: u32,
    pub __unk2: [cty::c_char; 4usize],
    pub pmc1: u32,
    pub pmc2: u32,
    pub pmc3: u32,
    pub pmc4: u32,
    pub mmcr0: u32,
    pub mmcr1: u32,
}
#[test]
fn bindgen_test_layout_OSContext() {
    assert_eq!(
        ::core::mem::size_of::<OSContext>(),
        800usize,
        concat!("Size of: ", stringify!(OSContext))
    );
    assert_eq!(
        ::core::mem::align_of::<OSContext>(),
        8usize,
        concat!("Alignment of ", stringify!(OSContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).gpr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(gpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).cr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).lr as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).ctr as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).xer as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(xer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).srr0 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(srr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).srr1 as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(srr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).dsisr as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(dsisr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).dar as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(dar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).__unk0 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(__unk0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).fpscr as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(fpscr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).fpr as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).spinLockCount as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(spinLockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).state as *const _ as usize },
        442usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).gqr as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(gqr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).__unk1 as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(__unk1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).psf as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(psf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).coretime as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(coretime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).starttime as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(starttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).error as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).__unk2 as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(__unk2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).pmc1 as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(pmc1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).pmc2 as *const _ as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(pmc2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).pmc3 as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(pmc3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).pmc4 as *const _ as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(pmc4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).mmcr0 as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(mmcr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSContext>())).mmcr1 as *const _ as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(OSContext),
            "::",
            stringify!(mmcr1)
        )
    );
}
extern "C" {
    pub fn OSInitContext(context: *mut OSContext, entry: *mut cty::c_void, stack: *mut cty::c_void);
}
extern "C" {
    pub fn OSDumpContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSLoadContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSaveContext(context: *mut OSContext) -> u32;
}
extern "C" {
    pub fn OSLoadFPUContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSaveFPUContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSGetCurrentContext() -> *mut OSContext;
}
extern "C" {
    pub fn OSSetCurrentContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSwitchStack(stack: *mut cty::c_void) -> *mut cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSSystemInfo {
    pub busClockSpeed: u32,
    pub coreClockSpeed: u32,
    pub baseTime: i64,
    pub __unk3: [cty::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_OSSystemInfo() {
    assert_eq!(
        ::core::mem::size_of::<OSSystemInfo>(),
        32usize,
        concat!("Size of: ", stringify!(OSSystemInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<OSSystemInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OSSystemInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSystemInfo>())).busClockSpeed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSystemInfo),
            "::",
            stringify!(busClockSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSystemInfo>())).coreClockSpeed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSystemInfo),
            "::",
            stringify!(coreClockSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSystemInfo>())).baseTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSystemInfo),
            "::",
            stringify!(baseTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSystemInfo>())).__unk3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSystemInfo),
            "::",
            stringify!(__unk3)
        )
    );
}
extern "C" {
    pub fn OSGetSystemInfo() -> *mut OSSystemInfo;
}
extern "C" {
    pub fn OSEnableHomeButtonMenu(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn OSIsHomeButtonMenuEnabled() -> BOOL;
}
extern "C" {
    pub fn OSGetOSID() -> u64;
}
extern "C" {
    pub fn __OSGetProcessSDKVersion() -> u32;
}
pub type OSTick = i32;
pub type OSTime = i64;
#[doc = "! Same as std c struct tm but with msec and usec added."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCalendarTime {
    pub tm_sec: i32,
    pub tm_min: i32,
    pub tm_hour: i32,
    pub tm_mday: i32,
    pub tm_mon: i32,
    pub tm_year: i32,
    pub tm_wday: i32,
    pub tm_yday: i32,
    pub tm_msec: i32,
    pub tm_usec: i32,
}
#[test]
fn bindgen_test_layout_OSCalendarTime() {
    assert_eq!(
        ::core::mem::size_of::<OSCalendarTime>(),
        40usize,
        concat!("Size of: ", stringify!(OSCalendarTime))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCalendarTime>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCalendarTime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_msec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_msec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCalendarTime>())).tm_usec as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCalendarTime),
            "::",
            stringify!(tm_usec)
        )
    );
}
extern "C" {
    pub fn OSGetTime() -> OSTime;
}
extern "C" {
    pub fn OSGetSystemTime() -> OSTime;
}
extern "C" {
    pub fn OSGetTick() -> OSTick;
}
extern "C" {
    pub fn OSGetSystemTick() -> OSTick;
}
extern "C" {
    pub fn OSCalendarTimeToTicks(calendarTime: *mut OSCalendarTime) -> OSTime;
}
extern "C" {
    pub fn OSTicksToCalendarTime(time: OSTime, calendarTime: *mut OSCalendarTime);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadLink {
    pub prev: *mut OSThread,
    pub next: *mut OSThread,
}
#[test]
fn bindgen_test_layout_OSThreadLink() {
    assert_eq!(
        ::core::mem::size_of::<OSThreadLink>(),
        8usize,
        concat!("Size of: ", stringify!(OSThreadLink))
    );
    assert_eq!(
        ::core::mem::align_of::<OSThreadLink>(),
        4usize,
        concat!("Alignment of ", stringify!(OSThreadLink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadLink>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadLink),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadLink>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadLink),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
    pub parent: *mut cty::c_void,
    pub __unk4: [cty::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_OSThreadQueue() {
    assert_eq!(
        ::core::mem::size_of::<OSThreadQueue>(),
        16usize,
        concat!("Size of: ", stringify!(OSThreadQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<OSThreadQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(OSThreadQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadQueue>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadQueue>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadQueue),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadQueue>())).__unk4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadQueue),
            "::",
            stringify!(__unk4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadSimpleQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
}
#[test]
fn bindgen_test_layout_OSThreadSimpleQueue() {
    assert_eq!(
        ::core::mem::size_of::<OSThreadSimpleQueue>(),
        8usize,
        concat!("Size of: ", stringify!(OSThreadSimpleQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<OSThreadSimpleQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(OSThreadSimpleQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadSimpleQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadSimpleQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThreadSimpleQueue>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThreadSimpleQueue),
            "::",
            stringify!(tail)
        )
    );
}
extern "C" {
    pub fn OSInitThreadQueue(queue: *mut OSThreadQueue);
}
extern "C" {
    pub fn OSInitThreadQueueEx(queue: *mut OSThreadQueue, parent: *mut cty::c_void);
}
#[doc = "! A value from enum OS_THREAD_STATE."]
pub type OSThreadState = u8;
#[doc = "! A value from enum OS_THREAD_REQUEST."]
pub type OSThreadRequest = u32;
#[doc = "! A bitfield of enum OS_THREAD_ATTRIB."]
pub type OSThreadAttributes = u8;
pub type OSThreadEntryPointFn = ::core::option::Option<
    unsafe extern "C" fn(argc: cty::c_int, argv: *mut *const cty::c_char) -> cty::c_int,
>;
pub type OSThreadCleanupCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(thread: *mut OSThread, stack: *mut cty::c_void)>;
pub type OSThreadDeallocatorFn =
    ::core::option::Option<unsafe extern "C" fn(thread: *mut OSThread, stack: *mut cty::c_void)>;
pub mod OS_THREAD_STATE {
    pub type Type = cty::c_uint;
    pub const OS_THREAD_STATE_NONE: Type = 0;
    #[doc = "! Thread is ready to run"]
    pub const OS_THREAD_STATE_READY: Type = 1;
    #[doc = "! Thread is running"]
    pub const OS_THREAD_STATE_RUNNING: Type = 2;
    #[doc = "! Thread is waiting, i.e. on a mutex"]
    pub const OS_THREAD_STATE_WAITING: Type = 4;
    #[doc = "! Thread is about to terminate"]
    pub const OS_THREAD_STATE_MORIBUND: Type = 8;
}
pub mod OS_THREAD_REQUEST {
    pub type Type = cty::c_uint;
    pub const OS_THREAD_REQUEST_NONE: Type = 0;
    pub const OS_THREAD_REQUEST_SUSPEND: Type = 1;
    pub const OS_THREAD_REQUEST_CANCEL: Type = 2;
}
pub mod OS_THREAD_ATTRIB {
    pub type Type = cty::c_uint;
    #[doc = "! Allow the thread to run on CPU0."]
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU0: Type = 1;
    #[doc = "! Allow the thread to run on CPU1."]
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU1: Type = 2;
    #[doc = "! Allow the thread to run on CPU2."]
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU2: Type = 4;
    #[doc = "! Allow the thread to run any CPU."]
    pub const OS_THREAD_ATTRIB_AFFINITY_ANY: Type = 7;
    #[doc = "! Start the thread detached."]
    pub const OS_THREAD_ATTRIB_DETACHED: Type = 8;
    #[doc = "! Enables tracking of stack usage."]
    pub const OS_THREAD_ATTRIB_STACK_USAGE: Type = 32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexQueue {
    pub head: *mut OSMutex,
    pub tail: *mut OSMutex,
    pub parent: *mut cty::c_void,
    pub __unk5: [cty::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_OSMutexQueue() {
    assert_eq!(
        ::core::mem::size_of::<OSMutexQueue>(),
        16usize,
        concat!("Size of: ", stringify!(OSMutexQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<OSMutexQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(OSMutexQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutexQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutexQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutexQueue>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutexQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutexQueue>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutexQueue),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutexQueue>())).__unk5 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutexQueue),
            "::",
            stringify!(__unk5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexQueue {
    pub head: *mut OSFastMutex,
    pub tail: *mut OSFastMutex,
}
#[test]
fn bindgen_test_layout_OSFastMutexQueue() {
    assert_eq!(
        ::core::mem::size_of::<OSFastMutexQueue>(),
        8usize,
        concat!("Size of: ", stringify!(OSFastMutexQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<OSFastMutexQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(OSFastMutexQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutexQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutexQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutexQueue>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutexQueue),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OSThread {
    pub context: OSContext,
    #[doc = "! Should always be set to the value OS_THREAD_TAG."]
    pub tag: u32,
    #[doc = "! Bitfield of OS_THREAD_STATE"]
    pub state: OSThreadState,
    #[doc = "! Bitfield of OS_THREAD_ATTRIB"]
    pub attr: OSThreadAttributes,
    #[doc = "! Unique thread ID"]
    pub id: u16,
    #[doc = "! Suspend count (increased by OSSuspendThread)."]
    pub suspendCounter: i32,
    #[doc = "! Actual priority of thread."]
    pub priority: i32,
    #[doc = "! Base priority of thread, 0 is highest priority, 31 is lowest priority."]
    pub basePriority: i32,
    #[doc = "! Exit value"]
    pub exitValue: i32,
    pub __unk6: [cty::c_char; 36usize],
    #[doc = "! Queue the thread is currently waiting on"]
    pub queue: *mut OSThreadQueue,
    #[doc = "! Link used for thread queue"]
    pub link: OSThreadLink,
    #[doc = "! Queue of threads waiting to join this thread"]
    pub joinQueue: OSThreadQueue,
    #[doc = "! Mutex this thread is waiting to lock"]
    pub mutex: *mut OSMutex,
    #[doc = "! Queue of mutexes this thread owns"]
    pub mutexQueue: OSMutexQueue,
    #[doc = "! Link for global active thread queue"]
    pub activeLink: OSThreadLink,
    #[doc = "! Stack start (top, highest address)"]
    pub stackStart: *mut cty::c_void,
    #[doc = "! Stack end (bottom, lowest address)"]
    pub stackEnd: *mut cty::c_void,
    #[doc = "! Thread entry point"]
    pub entryPoint: OSThreadEntryPointFn,
    pub __unk7: [cty::c_char; 476usize],
    #[doc = "! Thread specific values, accessed with OSSetThreadSpecific and OSGetThreadSpecific."]
    pub specific: [*mut cty::c_void; 16usize],
    pub __unk8: [cty::c_char; 4usize],
    #[doc = "! Thread name, accessed with OSSetThreadName and OSGetThreadName."]
    pub name: *const cty::c_char,
    pub __unk9: [cty::c_char; 4usize],
    #[doc = "! The stack pointer passed in OSCreateThread."]
    pub userStackPointer: *mut cty::c_void,
    #[doc = "! Called just before thread is terminated, set with OSSetThreadCleanupCallback"]
    pub cleanupCallback: OSThreadCleanupCallbackFn,
    #[doc = "! Called just after a thread is terminated, set with OSSetThreadDeallocator"]
    pub deallocator: OSThreadDeallocatorFn,
    #[doc = "! If TRUE then a thread can be cancelled or suspended, set with OSSetThreadCancelState"]
    pub cancelState: BOOL,
    #[doc = "! Current thread request, used for cancelleing and suspending the thread."]
    pub requestFlag: OSThreadRequest,
    #[doc = "! Pending suspend request count"]
    pub needSuspend: i32,
    #[doc = "! Result of thread suspend"]
    pub suspendResult: i32,
    #[doc = "! Queue of threads waiting for a thread to be suspended."]
    pub suspendQueue: OSThreadQueue,
    pub __unk10: [cty::c_char; 172usize],
}
#[test]
fn bindgen_test_layout_OSThread() {
    assert_eq!(
        ::core::mem::size_of::<OSThread>(),
        1696usize,
        concat!("Size of: ", stringify!(OSThread))
    );
    assert_eq!(
        ::core::mem::align_of::<OSThread>(),
        8usize,
        concat!("Alignment of ", stringify!(OSThread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).tag as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).state as *const _ as usize },
        804usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).attr as *const _ as usize },
        805usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).id as *const _ as usize },
        806usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).suspendCounter as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(suspendCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).priority as *const _ as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).basePriority as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(basePriority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).exitValue as *const _ as usize },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(exitValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).__unk6 as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(__unk6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).queue as *const _ as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).link as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).joinQueue as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(joinQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).mutex as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).mutexQueue as *const _ as usize },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(mutexQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).activeLink as *const _ as usize },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(activeLink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).stackStart as *const _ as usize },
        916usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(stackStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).stackEnd as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(stackEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).entryPoint as *const _ as usize },
        924usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(entryPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).__unk7 as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(__unk7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).specific as *const _ as usize },
        1404usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(specific)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).__unk8 as *const _ as usize },
        1468usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(__unk8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).name as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).__unk9 as *const _ as usize },
        1476usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(__unk9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).userStackPointer as *const _ as usize },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(userStackPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).cleanupCallback as *const _ as usize },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(cleanupCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).deallocator as *const _ as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(deallocator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).cancelState as *const _ as usize },
        1492usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(cancelState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).requestFlag as *const _ as usize },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(requestFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).needSuspend as *const _ as usize },
        1500usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(needSuspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).suspendResult as *const _ as usize },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(suspendResult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).suspendQueue as *const _ as usize },
        1508usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(suspendQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSThread>())).__unk10 as *const _ as usize },
        1524usize,
        concat!(
            "Offset of field: ",
            stringify!(OSThread),
            "::",
            stringify!(__unk10)
        )
    );
}
extern "C" {
    #[doc = " Cancels a thread."]
    #[doc = ""]
    #[doc = " This sets the threads requestFlag to OS_THREAD_REQUEST_CANCEL, the thread will"]
    #[doc = " be terminated next time OSTestThreadCancel is called."]
    pub fn OSCancelThread(thread: *mut OSThread);
}
extern "C" {
    #[doc = " Returns the count of active threads."]
    pub fn OSCheckActiveThreads() -> i32;
}
extern "C" {
    #[doc = " Get the maximum amount of stack the thread has used."]
    pub fn OSCheckThreadStackUsage(thread: *mut OSThread) -> i32;
}
extern "C" {
    #[doc = " Disable tracking of thread stack usage"]
    pub fn OSClearThreadStackUsage(thread: *mut OSThread);
}
extern "C" {
    #[doc = " Clears a thread's suspend counter and resumes it."]
    pub fn OSContinueThread(thread: *mut OSThread);
}
extern "C" {
    #[doc = " Create a new thread."]
    #[doc = ""]
    #[doc = " \\param thread Thread to initialise."]
    #[doc = " \\param entry Thread entry point."]
    #[doc = " \\param argc argc argument passed to entry point."]
    #[doc = " \\param argv argv argument passed to entry point."]
    #[doc = " \\param stack Top of stack (highest address)."]
    #[doc = " \\param stackSize Size of stack."]
    #[doc = " \\param priority Thread priority, 0 is highest priorty, 31 is lowest."]
    #[doc = " \\param attributes Thread attributes, see OSThreadAttributes."]
    pub fn OSCreateThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: i32,
        argv: *mut cty::c_char,
        stack: *mut cty::c_void,
        stackSize: u32,
        priority: i32,
        attributes: OSThreadAttributes,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Detach thread."]
    pub fn OSDetachThread(thread: *mut OSThread);
}
extern "C" {
    #[doc = " Exit the current thread with a exit code."]
    #[doc = ""]
    #[doc = " This function is implicitly called when the thread entry point returns."]
    pub fn OSExitThread(result: i32);
}
extern "C" {
    #[doc = " Get the next and previous thread in the thread's active queue."]
    pub fn OSGetActiveThreadLink(thread: *mut OSThread, link: *mut OSThreadLink);
}
extern "C" {
    #[doc = " Return pointer to OSThread object for the current thread."]
    pub fn OSGetCurrentThread() -> *mut OSThread;
}
extern "C" {
    #[doc = " Returns the default thread for a specific core."]
    #[doc = ""]
    #[doc = " Each core has 1 default thread created before the game boots. The default"]
    #[doc = " thread for core 1 calls the RPX entry point, the default threads for core 0"]
    #[doc = " and 2 are suspended and can be used with OSRunThread."]
    pub fn OSGetDefaultThread(coreID: u32) -> *mut OSThread;
}
extern "C" {
    #[doc = " Return current stack pointer, value of r1 register."]
    pub fn OSGetStackPointer() -> u32;
}
extern "C" {
    #[doc = " Get a thread's affinity."]
    pub fn OSGetThreadAffinity(thread: *mut OSThread) -> u32;
}
extern "C" {
    #[doc = " Get a thread's name."]
    pub fn OSGetThreadName(thread: *mut OSThread) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get a thread's base priority."]
    pub fn OSGetThreadPriority(thread: *mut OSThread) -> i32;
}
extern "C" {
    #[doc = " Get a thread's specific value set by OSSetThreadSpecific."]
    pub fn OSGetThreadSpecific(id: u32) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Returns TRUE if a thread is suspended."]
    pub fn OSIsThreadSuspended(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    #[doc = " Returns TRUE if a thread is terminated."]
    pub fn OSIsThreadTerminated(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    #[doc = " Wait until thread is terminated."]
    #[doc = ""]
    #[doc = " If the target thread is detached, returns FALSE."]
    #[doc = ""]
    #[doc = " \\param thread Thread to wait for"]
    #[doc = " \\param threadResult Pointer to store thread exit value in."]
    #[doc = " \\returns Returns TRUE if thread has terminated, FALSE if thread is detached."]
    pub fn OSJoinThread(thread: *mut OSThread, threadResult: *mut cty::c_int) -> BOOL;
}
extern "C" {
    #[doc = " Resumes a thread."]
    #[doc = ""]
    #[doc = " Decrements the thread's suspend counter, if the counter reaches 0 the thread"]
    #[doc = " is resumed."]
    #[doc = ""]
    #[doc = " \\returns Returns the previous value of the suspend counter."]
    pub fn OSResumeThread(thread: *mut OSThread) -> i32;
}
extern "C" {
    #[doc = " Run a function on an already created thread."]
    #[doc = ""]
    #[doc = " Can only be used on idle threads."]
    pub fn OSRunThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: cty::c_int,
        argv: *mut *const cty::c_char,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Set a thread's affinity."]
    pub fn OSSetThreadAffinity(thread: *mut OSThread, affinity: u32) -> BOOL;
}
extern "C" {
    #[doc = " Set a thread's cancellation state."]
    #[doc = ""]
    #[doc = " If the state is TRUE then the thread can be suspended or cancelled when"]
    #[doc = " OSTestThreadCancel is called."]
    pub fn OSSetThreadCancelState(state: BOOL) -> BOOL;
}
extern "C" {
    #[doc = " Set the callback to be called just before a thread is terminated."]
    pub fn OSSetThreadCleanupCallback(
        thread: *mut OSThread,
        callback: OSThreadCleanupCallbackFn,
    ) -> OSThreadCleanupCallbackFn;
}
extern "C" {
    #[doc = " Set the callback to be called just after a thread is terminated."]
    pub fn OSSetThreadDeallocator(
        thread: *mut OSThread,
        deallocator: OSThreadDeallocatorFn,
    ) -> OSThreadDeallocatorFn;
}
extern "C" {
    #[doc = " Set a thread's name."]
    pub fn OSSetThreadName(thread: *mut OSThread, name: *const cty::c_char);
}
extern "C" {
    #[doc = " Set a thread's priority."]
    pub fn OSSetThreadPriority(thread: *mut OSThread, priority: i32) -> BOOL;
}
extern "C" {
    #[doc = " Set a thread's run quantum."]
    #[doc = ""]
    #[doc = " This is the maximum amount of time the thread can run for before being forced"]
    #[doc = " to yield."]
    pub fn OSSetThreadRunQuantum(thread: *mut OSThread, quantum: u32) -> BOOL;
}
extern "C" {
    #[doc = " Set a thread specific value."]
    #[doc = ""]
    #[doc = " Can be read with OSGetThreadSpecific."]
    pub fn OSSetThreadSpecific(id: u32, value: *mut cty::c_void);
}
extern "C" {
    #[doc = " Set thread stack usage tracking."]
    pub fn OSSetThreadStackUsage(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    #[doc = " Sleep the current thread and add it to a thread queue."]
    #[doc = ""]
    #[doc = " Will sleep until the thread queue is woken with OSWakeupThread."]
    pub fn OSSleepThread(queue: *mut OSThreadQueue);
}
extern "C" {
    #[doc = " Sleep the current thread for a period of time."]
    pub fn OSSleepTicks(ticks: OSTime);
}
extern "C" {
    #[doc = " Suspend a thread."]
    #[doc = ""]
    #[doc = " Increases a thread's suspend counter, if the counter is >0 then the thread is"]
    #[doc = " suspended."]
    #[doc = ""]
    #[doc = " \\returns Returns the thread's previous suspend counter value"]
    pub fn OSSuspendThread(thread: *mut OSThread) -> u32;
}
extern "C" {
    #[doc = " Check to see if the current thread should be cancelled or suspended."]
    #[doc = ""]
    #[doc = " This is implicitly called in:"]
    #[doc = " - OSLockMutex"]
    #[doc = " - OSTryLockMutex"]
    #[doc = " - OSUnlockMutex"]
    #[doc = " - OSAcquireSpinLock"]
    #[doc = " - OSTryAcquireSpinLock"]
    #[doc = " - OSTryAcquireSpinLockWithTimeout"]
    #[doc = " - OSReleaseSpinLock"]
    #[doc = " - OSCancelThread"]
    pub fn OSTestThreadCancel();
}
extern "C" {
    #[doc = " Wake up all threads in queue."]
    #[doc = ""]
    #[doc = " Clears the thread queue."]
    pub fn OSWakeupThread(queue: *mut OSThreadQueue);
}
extern "C" {
    #[doc = " Yield execution to waiting threads with same priority."]
    #[doc = ""]
    #[doc = " This will never switch to a thread with a lower priority than the current"]
    #[doc = " thread."]
    pub fn OSYieldThread();
}
pub type OSAlarmCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut OSAlarm, arg2: *mut OSContext)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmQueue {
    #[doc = "! Should always be set to the value OS_ALARM_QUEUE_TAG."]
    pub tag: u32,
    #[doc = "! Name set by OSInitAlarmQueueEx"]
    pub name: *const cty::c_char,
    pub __unk11: [cty::c_char; 4usize],
    pub threadQueue: OSThreadQueue,
    pub head: *mut OSAlarm,
    pub tail: *mut OSAlarm,
}
#[test]
fn bindgen_test_layout_OSAlarmQueue() {
    assert_eq!(
        ::core::mem::size_of::<OSAlarmQueue>(),
        36usize,
        concat!("Size of: ", stringify!(OSAlarmQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<OSAlarmQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(OSAlarmQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmQueue>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmQueue),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmQueue>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmQueue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmQueue>())).__unk11 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmQueue),
            "::",
            stringify!(__unk11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmQueue>())).threadQueue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmQueue),
            "::",
            stringify!(threadQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmQueue>())).head as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmQueue>())).tail as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmQueue),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmLink {
    pub prev: *mut OSAlarm,
    pub next: *mut OSAlarm,
}
#[test]
fn bindgen_test_layout_OSAlarmLink() {
    assert_eq!(
        ::core::mem::size_of::<OSAlarmLink>(),
        8usize,
        concat!("Size of: ", stringify!(OSAlarmLink))
    );
    assert_eq!(
        ::core::mem::align_of::<OSAlarmLink>(),
        4usize,
        concat!("Alignment of ", stringify!(OSAlarmLink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmLink>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmLink),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarmLink>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarmLink),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarm {
    #[doc = "! Should always be set to the value OS_ALARM_TAG."]
    pub tag: u32,
    #[doc = "! Name set from OSCreateAlarmEx."]
    pub name: *const cty::c_char,
    pub __unk12: [cty::c_char; 4usize],
    #[doc = "! The callback to execute once the alarm is triggered."]
    pub callback: OSAlarmCallback,
    #[doc = "! Used with OSCancelAlarms for bulk cancellation of alarms."]
    pub group: u32,
    pub __unk13: [cty::c_char; 4usize],
    #[doc = "! The time when the alarm will next be triggered."]
    pub nextFire: OSTime,
    #[doc = "! Link used for when this OSAlarm object is inside an OSAlarmQueue"]
    pub link: OSAlarmLink,
    #[doc = "! The period between alarm triggers, this is only set for periodic alarms."]
    pub period: OSTime,
    #[doc = "! The time the alarm was started."]
    pub start: OSTime,
    #[doc = "! User data set with OSSetAlarmUserData and retrieved with OSGetAlarmUserData."]
    pub userData: *mut cty::c_void,
    #[doc = "! The current state of the alarm, internal values."]
    pub state: u32,
    #[doc = "! Queue of threads currently waiting for the alarm to trigger with OSWaitAlarm."]
    pub threadQueue: OSThreadQueue,
    #[doc = "! The queue that this alarm is currently in."]
    pub alarmQueue: *mut OSAlarmQueue,
    #[doc = "! The context the alarm was triggered on."]
    pub context: *mut OSContext,
}
#[test]
fn bindgen_test_layout_OSAlarm() {
    assert_eq!(
        ::core::mem::size_of::<OSAlarm>(),
        88usize,
        concat!("Size of: ", stringify!(OSAlarm))
    );
    assert_eq!(
        ::core::mem::align_of::<OSAlarm>(),
        8usize,
        concat!("Alignment of ", stringify!(OSAlarm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).__unk12 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(__unk12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).callback as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).__unk13 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(__unk13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).nextFire as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(nextFire)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).start as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).userData as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(userData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).state as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).threadQueue as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(threadQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).alarmQueue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(alarmQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSAlarm>())).context as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(OSAlarm),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = " Cancel an alarm."]
    pub fn OSCancelAlarm(alarm: *mut OSAlarm) -> BOOL;
}
extern "C" {
    #[doc = " Cancel all alarms which have a matching tag set by OSSetAlarmTag."]
    #[doc = ""]
    #[doc = " \\param group The alarm tag to cancel."]
    pub fn OSCancelAlarms(group: u32);
}
extern "C" {
    #[doc = " Initialise an alarm structure."]
    pub fn OSCreateAlarm(alarm: *mut OSAlarm);
}
extern "C" {
    #[doc = " Initialise an alarm structure with a name."]
    pub fn OSCreateAlarmEx(alarm: *mut OSAlarm, name: *const cty::c_char);
}
extern "C" {
    #[doc = " Return user data set by OSSetAlarmUserData."]
    pub fn OSGetAlarmUserData(alarm: *mut OSAlarm) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Initialise an alarm queue structure."]
    pub fn OSInitAlarmQueue(queue: *mut OSAlarmQueue);
}
extern "C" {
    #[doc = " Initialise an alarm queue structure with a name."]
    pub fn OSInitAlarmQueueEx(queue: *mut OSAlarmQueue, name: *const cty::c_char);
}
extern "C" {
    #[doc = " Set a one shot alarm to perform a callback after a set amount of time."]
    #[doc = ""]
    #[doc = " \\param alarm The alarm to set."]
    #[doc = " \\param time The duration until the alarm should be triggered."]
    #[doc = " \\param callback The alarm callback to call when the alarm is triggered."]
    pub fn OSSetAlarm(alarm: *mut OSAlarm, time: OSTime, callback: OSAlarmCallback) -> BOOL;
}
extern "C" {
    #[doc = " Set a repeated alarm to execute a callback every interval from start."]
    #[doc = ""]
    #[doc = " \\param alarm The alarm to set."]
    #[doc = " \\param start The duration until the alarm should first be triggered."]
    #[doc = " \\param interval The interval between triggers after the first trigger."]
    #[doc = " \\param callback The alarm callback to call when the alarm is triggered."]
    pub fn OSSetPeriodicAlarm(
        alarm: *mut OSAlarm,
        start: OSTime,
        interval: OSTime,
        callback: OSAlarmCallback,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Set an alarm tag which is used in OSCancelAlarms for bulk cancellation."]
    pub fn OSSetAlarmTag(alarm: *mut OSAlarm, group: u32);
}
extern "C" {
    #[doc = " Set alarm user data which is returned by OSGetAlarmUserData."]
    pub fn OSSetAlarmUserData(alarm: *mut OSAlarm, data: *mut cty::c_void);
}
extern "C" {
    #[doc = " Sleep the current thread until the alarm has been triggered or cancelled."]
    pub fn OSWaitAlarm(alarm: *mut OSAlarm) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomic(ptr: *mut u32, compare: u32, value: u32) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomicEx(ptr: *mut u32, compare: u32, value: u32, old: *mut u32)
        -> BOOL;
}
extern "C" {
    pub fn OSSwapAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSAddAtomic(ptr: *mut i32, value: i32) -> i32;
}
extern "C" {
    pub fn OSAndAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSOrAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSXorAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSTestAndClearAtomic(ptr: *mut u32, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSTestAndSetAtomic(ptr: *mut u32, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSGetAtomic64(ptr: *mut u64) -> u64;
}
extern "C" {
    pub fn OSSetAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSCompareAndSwapAtomic64(ptr: *mut u64, compare: u64, value: u64) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomicEx64(
        ptr: *mut u64,
        compare: u64,
        value: u64,
        old: *mut u64,
    ) -> BOOL;
}
extern "C" {
    pub fn OSSwapAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSAddAtomic64(ptr: *mut i64, value: i64) -> i64;
}
extern "C" {
    pub fn OSAndAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSOrAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSXorAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSTestAndClearAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSTestAndSetAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
}
pub type BSPError = i32;
pub type BSPHardwareVersion = u32;
pub mod BSPErrors {
    pub type Type = cty::c_uint;
    pub const BSP_ERROR_OK: Type = 0;
    pub const BSP_ERROR_IOS_ERROR: Type = 64;
    pub const BSP_ERROR_RESPONSE_TOO_LARGE: Type = 128;
}
pub mod BSPHardwareVersions {
    pub type Type = cty::c_uint;
    pub const BSP_HARDWARE_VERSION_UNKNOWN: Type = 0;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_1: Type = 1;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_2: Type = 268435457;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_PROD_FOR_WII: Type = 269484033;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO: Type = 269484040;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO_ESPRESSO: Type = 269484044;
    pub const BSP_HARDWARE_VERSION_BOLLYWOOD: Type = 536870913;
    pub const BSP_HARDWARE_VERSION_BOLLYWOOD_PROD_FOR_WII: Type = 537919489;
    pub const BSP_HARDWARE_VERSION_LATTE_A11_EV: Type = 554696720;
    pub const BSP_HARDWARE_VERSION_LATTE_A11_CAT: Type = 554696736;
    pub const BSP_HARDWARE_VERSION_LATTE_A12_EV: Type = 555745296;
    pub const BSP_HARDWARE_VERSION_LATTE_A12_CAT: Type = 555745312;
    pub const BSP_HARDWARE_VERSION_LATTE_A2X_EV: Type = 571473936;
    pub const BSP_HARDWARE_VERSION_LATTE_A2X_CAT: Type = 571473952;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_EV: Type = 588251152;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAT: Type = 588251168;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAFE: Type = 588251176;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_EV: Type = 605028368;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAT: Type = 605028384;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAFE: Type = 605028392;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV: Type = 621805584;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV_Y: Type = 621805585;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAT: Type = 621805600;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAFE: Type = 621805608;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV: Type = 638582800;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV_Y: Type = 638582801;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAT: Type = 638582816;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAFE: Type = 638582824;
}
extern "C" {
    pub fn bspInitializeShimInterface() -> BSPError;
}
extern "C" {
    pub fn bspGetHardwareVersion(version: *mut BSPHardwareVersion) -> BSPError;
}
extern "C" {
    #[doc = " Invalidates a range of cached data, in blocks. Equivalent to a loop of"]
    #[doc = " PowerPC \\c dcbi instructions."]
    #[doc = ""]
    #[doc = " This function forces the next reads from the given address to bypass the"]
    #[doc = " the cache and go straight to memory, resulting in slower reads that are"]
    #[doc = " guaranteed to reflect main memory."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the data to invalidate."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to invalidate. Will be rounded up to the next 0x20."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Unnecessary use of caching functions can have an adverse performance impact."]
    #[doc = " They should only be used when needed while interfacing with hardware."]
    pub fn DCInvalidateRange(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    #[doc = " Flushes a range of cached data, in blocks. Equivalent to a loop of PowerPC"]
    #[doc = " \\c dcbf instructions, followed by a \\c sync and \\c eieio."]
    #[doc = ""]
    #[doc = " This function flushes any recently cached data into main memory."]
    #[doc = " This allows other hardware in the console to read the data without worry"]
    #[doc = " of main memory being outdated. It will also invalidate cached data."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the data to flush."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to flush. Will be rounded up to the next 0x20."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Unnecessary use of caching functions can have an adverse performance impact."]
    #[doc = " They should only be used when needed while interfacing with hardware."]
    pub fn DCFlushRange(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    #[doc = " Stores a range of cached data, in blocks. Equivalent to a loop of PowerPC"]
    #[doc = " \\c dcbst instructions, followed by a \\c sync and \\c eieio."]
    #[doc = ""]
    #[doc = " This function writes any recently cached data into main memory."]
    #[doc = " This allows other hardware in the console to read the data without worry"]
    #[doc = " of main memory being outdated. This function does <em>not</em> invalidate"]
    #[doc = " the cached data."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the data to store."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to store. Will be rounded up to the next 0x20."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Unnecessary use of caching functions can have an adverse performance impact."]
    #[doc = " They should only be used when needed while interfacing with hardware."]
    pub fn DCStoreRange(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    #[doc = " Similar to \\link DCFlushRange \\endlink, though this function will"]
    #[doc = " <em>not</em> run PowerPC \\c sync and \\c eieio instructions after flushing."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the data to flush."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to flush. Will be rounded up to the next 0x20."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Unnecessary use of caching functions can have an adverse performance impact."]
    #[doc = " They should only be used when needed while interfacing with hardware."]
    pub fn DCFlushRangeNoSync(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    #[doc = " Similar to \\link DCStoreRange \\endlink, though this function will"]
    #[doc = " <em>not</em> run PowerPC \\c sync and \\c eieio instructions after storing."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the data to store."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to store. Will be rounded up to the next 0x20."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Unnecessary use of caching functions can have an adverse performance impact."]
    #[doc = " They should only be used when needed while interfacing with hardware."]
    pub fn DCStoreRangeNoSync(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    #[doc = " Zeroes the given area of the data cache (to the nearest block) with a loop of"]
    #[doc = " PowerPC \\c dcbz instructions."]
    #[doc = " This will not affect main memory immediately, though it will eventually"]
    #[doc = " trickle down. Can be combined with \\link DCFlushRange \\endlink or"]
    #[doc = " \\link DCStoreRange \\endlink to efficiently set memory to 0."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " The size of the range passed into this function will be internally rounded up"]
    #[doc = " to the next multiple of 0x20. Failing to account for this could result in"]
    #[doc = " delayed, hard-to-diagnose memory corruption."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the data to zero."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to zero. Will be rounded up to the next 0x20."]
    pub fn DCZeroRange(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    #[doc = " Gives the processor a hint that the given range of memory is likely to be"]
    #[doc = " accessed soon, and that performance would be improved if it were cached."]
    #[doc = " The processor does not have to cache the requested area, but it may do so in"]
    #[doc = " response to this function. This function is equvalent to a loop of PowerPC"]
    #[doc = " \\c dcbt instructions."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the data to cache."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to cache. Will be rounded up to the next 0x20."]
    pub fn DCTouchRange(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    #[doc = " Invalidates a range of cached instructions, in blocks. Equivalent to a loop"]
    #[doc = " of PowerPC \\c icbi instructions."]
    #[doc = ""]
    #[doc = " This function forces the next instruction fetches from the given address to"]
    #[doc = " bypass the the cache and go straight to memory, resulting in slower fetches"]
    #[doc = " that are guaranteed to reflect main memory."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " The effective address of the instructions to invalidate."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the range to invalidate. Will be rounded up to the next 0x20."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Unnecessary use of caching functions can have an adverse performance impact."]
    #[doc = " They should only be used when needed while interfacing with hardware."]
    pub fn ICInvalidateRange(addr: *mut cty::c_void, size: u32);
}
extern "C" {
    pub fn OSMemoryBarrier();
}
pub mod OSCodegenSecMode {
    #[doc = "! The memory permissions for the codegen area."]
    pub type Type = cty::c_uint;
    #[doc = "! The area can be read or written to, but not executed."]
    pub const CODEGEN_RW_: Type = 0;
    #[doc = "! The area can be read or executed, but not written to."]
    pub const CODEGEN_R_X: Type = 1;
}
extern "C" {
    #[doc = " Gets the location and size of codegen memory, if available."]
    #[doc = ""]
    #[doc = " \\param outVirtualAddress"]
    #[doc = " Pointer to write the virtual address of the codegen area to. Will write 0 if"]
    #[doc = " codegen isn't available."]
    #[doc = ""]
    #[doc = " \\param outSize"]
    #[doc = " Pointer to write the size of the codegen area to. Will write 0 if codegen"]
    #[doc = " isn't available."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\link OSGetSecCodeGenMode \\endlink"]
    pub fn OSCodegenGetVirtAddrRange(outVirtualAddress: *mut u32, outSize: *mut u32);
}
extern "C" {
    #[doc = " Gets the CPU core that's allowed to use codegen."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The core id of the core that can use codegen."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\link OSGetCoreId \\endlink"]
    #[doc = ""]
    #[doc = " <!-- NOTE this appears to come from cos.xml: bottom few bits -->"]
    pub fn OSGetCodegenCore() -> u32;
}
extern "C" {
    pub fn OSGetCodegenMode() -> u32;
}
extern "C" {
    #[doc = " Switches the permissions on the codegen memory area. Use this function to"]
    #[doc = " move between writing code and executing it."]
    #[doc = ""]
    #[doc = " \\param mode"]
    #[doc = " The memory permission mode to use - one of \\link OSCodegenSecMode \\endlink."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " \\c true on success, or \\c false on a failure, such as codegen not being"]
    #[doc = " available for this app or CPU core."]
    pub fn OSSwitchSecCodeGenMode(mode: OSCodegenSecMode::Type) -> BOOL;
}
extern "C" {
    pub fn OSGetSecCodeGenMode() -> u32;
}
extern "C" {
    #[doc = " Copies data from normal memory into the codegen area, leaving the area in"]
    #[doc = " \\link CODEGEN_R_X \\endlink mode."]
    #[doc = " This function copies into the codegen area regardless"]
    #[doc = " of the current permission status by switching modes as required for the copy."]
    #[doc = ""]
    #[doc = " \\param dst"]
    #[doc = " The starting virtual address of the area in codegen memory to copy to. Must"]
    #[doc = " be a valid pointer"]
    #[doc = ""]
    #[doc = " \\param src"]
    #[doc = " The starting virtual address of the source to copy from. Must be a valid"]
    #[doc = " pointer."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the data to copy. Must not be 0, and must be small"]
    #[doc = " enough such that <tt>dst + size</tt> does not pass the end of the codegen"]
    #[doc = " area (see \\link OSCodegenGetVirtAddrRange \\endlink)."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\c TRUE on success, indicating the codegen area is now in"]
    #[doc = " \\link CODEGEN_R_X \\endlink, or \\c FALSE on an error, such as invalid pointers"]
    #[doc = " or codegen not being available."]
    #[doc = ""]
    #[doc = " <!-- NOTE this function has a specific bit required in cox.xml: 1 << 30? -->"]
    pub fn OSCodegenCopy(dst: *mut cty::c_void, src: *mut cty::c_void, size: size_t) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCondition {
    #[doc = "! Should always be set to the value OS_CONDITION_TAG."]
    pub tag: u32,
    #[doc = "! Name set by OSInitCondEx."]
    pub name: *const cty::c_char,
    pub __unk14: [cty::c_char; 4usize],
    #[doc = "! Queue of threads currently waiting on condition with OSWaitCond."]
    pub queue: OSThreadQueue,
}
#[test]
fn bindgen_test_layout_OSCondition() {
    assert_eq!(
        ::core::mem::size_of::<OSCondition>(),
        28usize,
        concat!("Size of: ", stringify!(OSCondition))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCondition>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCondition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCondition>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCondition),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCondition>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCondition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCondition>())).__unk14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCondition),
            "::",
            stringify!(__unk14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCondition>())).queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCondition),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    #[doc = " Initialise a condition variable structure."]
    pub fn OSInitCond(condition: *mut OSCondition);
}
extern "C" {
    #[doc = " Initialise a condition variable structure with a name."]
    pub fn OSInitCondEx(condition: *mut OSCondition, name: *const cty::c_char);
}
extern "C" {
    #[doc = " Sleep the current thread until the condition variable has been signalled."]
    #[doc = ""]
    #[doc = " The mutex must be locked when entering this function."]
    #[doc = " Will unlock the mutex and then sleep, reacquiring the mutex when woken."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable/wait\">std::condition_variable::wait</a>."]
    pub fn OSWaitCond(condition: *mut OSCondition, mutex: *mut OSMutex);
}
extern "C" {
    #[doc = " Will wake up any threads waiting on the condition with OSWaitCond."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable/notify_all\">std::condition_variable::notify_all</a>."]
    pub fn OSSignalCond(condition: *mut OSCondition);
}
extern "C" {
    #[doc = " Gets the number of cores in the system. On a retail Wii U, this is always 3."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The core count of the system."]
    pub fn OSGetCoreCount() -> u32;
}
extern "C" {
    #[doc = " Gets the core executing the current thread."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The ID of the current core."]
    pub fn OSGetCoreId() -> u32;
}
extern "C" {
    #[doc = " Gets the main core of the system. On a retail Wii U, this is always core 1."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The ID of the main core."]
    pub fn OSGetMainCoreId() -> u32;
}
extern "C" {
    #[doc = " Determines whether the current thread is running on the main core."]
    #[doc = " On a retail Wii U, the main core is always core 1."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " \\c true if the current core is the main core."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " <ul><li>\\link OSGetMainCoreId \\endlink</li></ul>"]
    pub fn OSIsMainCore() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCoroutine {
    pub nia: u32,
    pub cr: u32,
    pub ugqr1: u32,
    pub stack: u32,
    pub sda2Base: u32,
    pub sdaBase: u32,
    pub gpr: [u32; 18usize],
    pub fpr: [f64; 18usize],
    pub psr: [f64; 18usize],
}
#[test]
fn bindgen_test_layout_OSCoroutine() {
    assert_eq!(
        ::core::mem::size_of::<OSCoroutine>(),
        384usize,
        concat!("Size of: ", stringify!(OSCoroutine))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCoroutine>(),
        8usize,
        concat!("Alignment of ", stringify!(OSCoroutine))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).nia as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(nia)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).cr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).ugqr1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(ugqr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).stack as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).sda2Base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(sda2Base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).sdaBase as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(sdaBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).gpr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(gpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).fpr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSCoroutine>())).psr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCoroutine),
            "::",
            stringify!(psr)
        )
    );
}
extern "C" {
    pub fn OSInitCoroutine(
        coroutine: *mut OSCoroutine,
        entry: *mut cty::c_void,
        stack: *mut cty::c_void,
    );
}
extern "C" {
    pub fn OSLoadCoroutine(coroutine: *mut OSCoroutine, result: u32) -> u32;
}
extern "C" {
    pub fn OSSaveCoroutine(coroutine: *mut OSCoroutine) -> u32;
}
extern "C" {
    pub fn OSSwitchCoroutine(from: *mut OSCoroutine, to: *mut OSCoroutine);
}
pub mod COSReportLevel {
    pub type Type = cty::c_uint;
    pub const COS_REPORT_LEVEL_ERROR: Type = 0;
    pub const COS_REPORT_LEVEL_WARN: Type = 1;
    pub const COS_REPORT_LEVEL_INFO: Type = 2;
    pub const COS_REPORT_LEVEL_VERBOSE: Type = 3;
}
pub mod COSReportModule {
    pub type Type = cty::c_uint;
    pub const COS_REPORT_MODULE_UNKNOWN_0: Type = 0;
    pub const COS_REPORT_MODULE_UNKNOWN_1: Type = 1;
    pub const COS_REPORT_MODULE_UNKNOWN_2: Type = 2;
    pub const COS_REPORT_MODULE_UNKNOWN_5: Type = 5;
}
extern "C" {
    pub fn COSVReport(
        module: COSReportModule::Type,
        level: COSReportLevel::Type,
        fmt: *const cty::c_char,
        ...
    );
}
extern "C" {
    pub fn COSError(module: COSReportModule::Type, fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn COSInfo(module: COSReportModule::Type, fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn COSVerbose(module: COSReportModule::Type, fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn COSWarn(module: COSReportModule::Type, fmt: *const cty::c_char, ...);
}
pub type DisassemblyPrintFn =
    ::core::option::Option<unsafe extern "C" fn(fmt: *const cty::c_char, ...)>;
pub type DisassemblyFindSymbolFn = ::core::option::Option<
    unsafe extern "C" fn(addr: u32, symbolNameBuf: *mut cty::c_char, symbolNameBufSize: u32) -> u32,
>;
pub mod DisassemblePPCFlags {
    pub type Type = cty::c_uint;
    pub const DISASSEMBLE_PPC_FLAGS_NONE: Type = 0;
}
extern "C" {
    pub fn OSConsoleWrite(msg: *const cty::c_char, size: u32);
}
extern "C" {
    pub fn OSReport(fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn OSReportVerbose(fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn OSReportInfo(fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn OSReportWarn(fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn OSPanic(file: *const cty::c_char, line: u32, fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn OSFatal(msg: *const cty::c_char);
}
extern "C" {
    pub fn OSGetSymbolName(
        addr: u32,
        symbolNameBuf: *mut cty::c_char,
        symbolNameBufSize: u32,
    ) -> u32;
}
extern "C" {
    pub fn OSGetUPID() -> u32;
}
extern "C" {
    pub fn OSIsDebuggerInitialized() -> BOOL;
}
extern "C" {
    pub fn OSIsDebuggerPresent() -> BOOL;
}
extern "C" {
    pub fn OSIsECOBoot() -> BOOL;
}
extern "C" {
    pub fn OSIsECOMode() -> BOOL;
}
extern "C" {
    pub fn DisassemblePPCOpcode(
        opcode: *mut u32,
        buffer: *mut cty::c_char,
        bufferSize: u32,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn DisassemblePPCRange(
        start: *mut cty::c_void,
        end: *mut cty::c_void,
        printFn: DisassemblyPrintFn,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags::Type,
    );
}
pub type OSDynLoad_Module = *mut cty::c_void;
pub mod OSDynLoad_Error {
    pub type Type = cty::c_uint;
    pub const OS_DYNLOAD_OK: Type = 0;
    pub const OS_DYNLOAD_OUT_OF_MEMORY: Type = 3134259202;
    pub const OS_DYNLOAD_INVALID_NOTIFY_PTR: Type = 3134259214;
    pub const OS_DYNLOAD_INVALID_MODULE_NAME_PTR: Type = 3134259215;
    pub const OS_DYNLOAD_INVALID_MODULE_NAME: Type = 3134259216;
    pub const OS_DYNLOAD_INVALID_ACQUIRE_PTR: Type = 3134259217;
    pub const OS_DYNLOAD_EMPTY_MODULE_NAME: Type = 3134259218;
    pub const OS_DYNLOAD_INVALID_ALLOCATOR_PTR: Type = 3134259223;
    pub const OS_DYNLOAD_OUT_OF_SYSTEM_MEMORY: Type = 3134259247;
    pub const OS_DYNLOAD_TLS_ALLOCATOR_LOCKED: Type = 3134259249;
}
pub type OSDynLoadAllocFn = ::core::option::Option<
    unsafe extern "C" fn(
        size: i32,
        align: i32,
        outAddr: *mut *mut cty::c_void,
    ) -> OSDynLoad_Error::Type,
>;
pub type OSDynLoadFreeFn = ::core::option::Option<unsafe extern "C" fn(addr: *mut cty::c_void)>;
pub mod OSDynLoad_EntryReason {
    pub type Type = cty::c_uint;
    pub const OS_DYNLOAD_LOADED: Type = 0;
    pub const OS_DYNLOAD_UNLOADED: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_NotifyData {
    pub name: *mut cty::c_char,
    pub textAddr: u32,
    pub textOffset: u32,
    pub textSize: u32,
    pub dataAddr: u32,
    pub dataOffset: u32,
    pub dataSize: u32,
    pub readAddr: u32,
    pub readOffset: u32,
    pub readSize: u32,
}
#[test]
fn bindgen_test_layout_OSDynLoad_NotifyData() {
    assert_eq!(
        ::core::mem::size_of::<OSDynLoad_NotifyData>(),
        40usize,
        concat!("Size of: ", stringify!(OSDynLoad_NotifyData))
    );
    assert_eq!(
        ::core::mem::align_of::<OSDynLoad_NotifyData>(),
        4usize,
        concat!("Alignment of ", stringify!(OSDynLoad_NotifyData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).textAddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(textAddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).textOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(textOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).textSize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(textSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).dataAddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(dataAddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).dataOffset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(dataOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).dataSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).readAddr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(readAddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).readOffset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(readOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSDynLoad_NotifyData>())).readSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OSDynLoad_NotifyData),
            "::",
            stringify!(readSize)
        )
    );
}
extern "C" {
    #[doc = " Load a module."]
    #[doc = ""]
    #[doc = " If the module is already loaded, increase reference count."]
    #[doc = " Similar to LoadLibrary on Windows."]
    pub fn OSDynLoad_Acquire(
        name: *const cty::c_char,
        outModule: *mut OSDynLoad_Module,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    #[doc = " Retrieve the address of a function or data export from a module."]
    #[doc = ""]
    #[doc = " Similar to GetProcAddress on Windows."]
    pub fn OSDynLoad_FindExport(
        module: OSDynLoad_Module,
        isData: BOOL,
        name: *const cty::c_char,
        outAddr: *mut *mut cty::c_void,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    #[doc = " Free a module handle returned from OSDynLoad_Acquire."]
    #[doc = ""]
    #[doc = " Will decrease reference count and only unload the module if count reaches 0."]
    #[doc = " Similar to FreeLibrary on Windows."]
    pub fn OSDynLoad_Release(module: OSDynLoad_Module);
}
extern "C" {
    #[doc = " Set the allocator functions to use for dynamic loading."]
    pub fn OSDynLoad_SetAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    #[doc = " Get the allocator functions used for dynamic loading."]
    pub fn OSDynLoad_GetAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    #[doc = " Set the allocator functions to use for thread local storage."]
    pub fn OSDynLoad_SetTLSAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    #[doc = " Get the allocator functions used for thread local storage."]
    pub fn OSDynLoad_GetTLSAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    #[doc = " Gets the name for a given module handle."]
    #[doc = " Using the value \"-1\" as module handle gets the name of the running main rpl"]
    pub fn OSDynLoad_GetModuleName(
        module: OSDynLoad_Module,
        nameBuf: *mut cty::c_char,
        nameBufSize: *mut i32,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    #[doc = " Gets the number of currently loaded RPLs."]
    #[doc = ""]
    #[doc = " Always returns 0 on release versions of CafeOS."]
    #[doc = " Requires OSGetSecurityLevel() > 0."]
    pub fn OSDynLoad_GetNumberOfRPLs() -> i32;
}
extern "C" {
    #[doc = " Get information about the currently loaded RPLs."]
    #[doc = ""]
    #[doc = " \\param first the index of the first RPL to retrieve info for."]
    #[doc = " \\param count the number of RPLs to retrieve info for"]
    #[doc = " \\param outInfos buffer of RPL info to be filled, should be an array of at"]
    #[doc = "                 least count size."]
    #[doc = ""]
    #[doc = " Always returns FALSE on release versions of CafeOS."]
    #[doc = " Requires OSGetSecurityLevel() > 0."]
    pub fn OSDynLoad_GetRPLInfo(
        first: u32,
        count: u32,
        outInfos: *mut OSDynLoad_NotifyData,
    ) -> BOOL;
}
extern "C" {
    #[doc = " The prototype for an RPL entry point."]
    #[doc = ""]
    #[doc = " Use this instead of main when creating .rpl files"]
    pub fn rpl_entry(module: OSDynLoad_Module, reason: OSDynLoad_EntryReason::Type) -> cty::c_int;
}
pub type IMError = i32;
extern "C" {
    pub fn IMDisableAPD() -> IMError;
}
extern "C" {
    pub fn IMDisableDim() -> IMError;
}
extern "C" {
    pub fn IMEnableAPD() -> IMError;
}
extern "C" {
    pub fn IMEnableDim() -> IMError;
}
extern "C" {
    pub fn IMIsAPDEnabled(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMIsAPDEnabledBySysSettings(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMIsDimEnabled(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimEnableDrc(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimEnableTv(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimPeriod(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetTimeBeforeAPD(outSeconds: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetTimeBeforeDimming(outSeconds: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMSetDimEnableDrc(value: BOOL) -> IMError;
}
extern "C" {
    pub fn IMSetDimEnableTv(value: BOOL) -> IMError;
}
extern "C" {
    pub fn IMStartAPDVideoMode() -> IMError;
}
pub mod OSEventMode {
    pub type Type = cty::c_uint;
    #[doc = "! A manual event will only reset when OSResetEvent is called."]
    pub const OS_EVENT_MODE_MANUAL: Type = 0;
    #[doc = "! An auto event will reset everytime a thread is woken."]
    pub const OS_EVENT_MODE_AUTO: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSEvent {
    #[doc = "! Should always be set to the value OS_EVENT_TAG."]
    pub tag: u32,
    #[doc = "! Name set by OSInitEventEx."]
    pub name: *const cty::c_char,
    pub __unk15: [cty::c_char; 4usize],
    #[doc = "! The current value of the event object."]
    pub value: BOOL,
    #[doc = "! The threads currently waiting on this event object with OSWaitEvent."]
    pub queue: OSThreadQueue,
    #[doc = "! The mode of the event object, set by OSInitEvent."]
    pub mode: OSEventMode::Type,
}
#[test]
fn bindgen_test_layout_OSEvent() {
    assert_eq!(
        ::core::mem::size_of::<OSEvent>(),
        36usize,
        concat!("Size of: ", stringify!(OSEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<OSEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(OSEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSEvent>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSEvent),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSEvent>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSEvent),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSEvent>())).__unk15 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSEvent),
            "::",
            stringify!(__unk15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSEvent>())).value as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSEvent>())).queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSEvent),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSEvent>())).mode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSEvent),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    #[doc = " Initialise an event object with value and mode."]
    pub fn OSInitEvent(event: *mut OSEvent, value: BOOL, mode: OSEventMode::Type);
}
extern "C" {
    #[doc = " Initialise an event object with value, mode and name."]
    pub fn OSInitEventEx(
        event: *mut OSEvent,
        value: BOOL,
        mode: OSEventMode::Type,
        name: *mut cty::c_char,
    );
}
extern "C" {
    #[doc = " Signals the event."]
    #[doc = ""]
    #[doc = " If no threads are waiting the event value is set."]
    #[doc = ""]
    #[doc = " If the event mode is OS_EVENT_MODE_MANUAL this will wake all waiting threads"]
    #[doc = " and the event will remain set until OSResetEvent is called."]
    #[doc = ""]
    #[doc = " If the event mode is OS_EVENT_MODE_AUTO this will wake only one thread"]
    #[doc = " and the event will be reset immediately."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms686211(v=vs.85).aspx\">SetEvent</a>."]
    pub fn OSSignalEvent(event: *mut OSEvent);
}
extern "C" {
    #[doc = " Signals all threads waiting on an event."]
    #[doc = ""]
    #[doc = " If no threads are waiting the event value is set."]
    #[doc = ""]
    #[doc = " If the event mode is OS_EVENT_MODE_MANUAL this will wake all waiting threads"]
    #[doc = " and the event will remain set until OSResetEvent is called."]
    #[doc = ""]
    #[doc = " If the event mode is OS_EVENT_MODE_AUTO this will wake all waiting threads"]
    #[doc = " and the event will be reset."]
    pub fn OSSignalEventAll(event: *mut OSEvent);
}
extern "C" {
    #[doc = " Wait until an event is signalled."]
    #[doc = ""]
    #[doc = " If the event is already set, this returns immediately."]
    #[doc = ""]
    #[doc = " If the event mode is OS_EVENT_MODE_AUTO the event will be reset before"]
    #[doc = " returning from this method."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx\">WaitForSingleObject</a>."]
    pub fn OSWaitEvent(event: *mut OSEvent);
}
extern "C" {
    #[doc = " Resets the event object."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms685081(v=vs.85).aspx\">ResetEvent</a>."]
    pub fn OSResetEvent(event: *mut OSEvent);
}
extern "C" {
    #[doc = " Wait until an event is signalled or a timeout has occurred."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx\">WaitForSingleObject</a>."]
    pub fn OSWaitEventWithTimeout(event: *mut OSEvent, timeout: OSTime) -> BOOL;
}
pub type OSExceptionCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut OSContext) -> BOOL>;
pub mod OSExceptionMode {
    pub type Type = cty::c_uint;
    pub const OS_EXCEPTION_MODE_SYSTEM: Type = 0;
    pub const OS_EXCEPTION_MODE_THREAD: Type = 1;
    pub const OS_EXCEPTION_MODE_GLOBAL: Type = 2;
    pub const OS_EXCEPTION_MODE_THREAD_ALL_CORES: Type = 3;
    pub const OS_EXCEPTION_MODE_GLOBAL_ALL_CORES: Type = 4;
}
pub mod OSExceptionType {
    pub type Type = cty::c_uint;
    pub const OS_EXCEPTION_TYPE_SYSTEM_RESET: Type = 0;
    pub const OS_EXCEPTION_TYPE_MACHINE_CHECK: Type = 1;
    pub const OS_EXCEPTION_TYPE_DSI: Type = 2;
    pub const OS_EXCEPTION_TYPE_ISI: Type = 3;
    pub const OS_EXCEPTION_TYPE_EXTERNAL_INTERRUPT: Type = 4;
    pub const OS_EXCEPTION_TYPE_ALIGNMENT: Type = 5;
    pub const OS_EXCEPTION_TYPE_PROGRAM: Type = 6;
    pub const OS_EXCEPTION_TYPE_FLOATING_POINT: Type = 7;
    pub const OS_EXCEPTION_TYPE_DECREMENTER: Type = 8;
    pub const OS_EXCEPTION_TYPE_SYSTEM_CALL: Type = 9;
    pub const OS_EXCEPTION_TYPE_TRACE: Type = 10;
    pub const OS_EXCEPTION_TYPE_PERFORMANCE_MONITOR: Type = 11;
    pub const OS_EXCEPTION_TYPE_BREAKPOINT: Type = 12;
    pub const OS_EXCEPTION_TYPE_SYSTEM_INTERRUPT: Type = 13;
    pub const OS_EXCEPTION_TYPE_ICI: Type = 14;
}
extern "C" {
    pub fn OSSetExceptionCallback(
        exceptionType: OSExceptionType::Type,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
}
extern "C" {
    pub fn OSSetExceptionCallbackEx(
        mode: OSExceptionMode::Type,
        exceptionType: OSExceptionType::Type,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
}
extern "C" {
    pub fn __rplwrap_exit(code: cty::c_int);
}
extern "C" {
    pub fn _Exit(code: cty::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastCondition {
    pub tag: u32,
    pub name: *const cty::c_char,
    pub __unk16: [cty::c_char; 4usize],
    pub queue: OSThreadQueue,
}
#[test]
fn bindgen_test_layout_OSFastCondition() {
    assert_eq!(
        ::core::mem::size_of::<OSFastCondition>(),
        28usize,
        concat!("Size of: ", stringify!(OSFastCondition))
    );
    assert_eq!(
        ::core::mem::align_of::<OSFastCondition>(),
        4usize,
        concat!("Alignment of ", stringify!(OSFastCondition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastCondition>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastCondition),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastCondition>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastCondition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastCondition>())).__unk16 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastCondition),
            "::",
            stringify!(__unk16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastCondition>())).queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastCondition),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    pub fn OSFastCond_Init(condition: *mut OSFastCondition, name: *const cty::c_char);
}
extern "C" {
    pub fn OSFastCond_Wait(condition: *mut OSFastCondition, mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastCond_Signal(condition: *mut OSFastCondition);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexLink {
    pub next: *mut OSFastMutex,
    pub prev: *mut OSFastMutex,
}
#[test]
fn bindgen_test_layout_OSFastMutexLink() {
    assert_eq!(
        ::core::mem::size_of::<OSFastMutexLink>(),
        8usize,
        concat!("Size of: ", stringify!(OSFastMutexLink))
    );
    assert_eq!(
        ::core::mem::align_of::<OSFastMutexLink>(),
        4usize,
        concat!("Alignment of ", stringify!(OSFastMutexLink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutexLink>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutexLink),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutexLink>())).prev as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutexLink),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutex {
    pub tag: u32,
    pub name: *const cty::c_char,
    pub __unk17: [cty::c_char; 4usize],
    pub queue: OSThreadSimpleQueue,
    pub link: OSFastMutexLink,
    pub __unk18: [cty::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_OSFastMutex() {
    assert_eq!(
        ::core::mem::size_of::<OSFastMutex>(),
        44usize,
        concat!("Size of: ", stringify!(OSFastMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<OSFastMutex>(),
        4usize,
        concat!("Alignment of ", stringify!(OSFastMutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutex>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutex),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutex>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutex),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutex>())).__unk17 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutex),
            "::",
            stringify!(__unk17)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutex>())).queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutex),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutex>())).link as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutex),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSFastMutex>())).__unk18 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSFastMutex),
            "::",
            stringify!(__unk18)
        )
    );
}
extern "C" {
    pub fn OSFastMutex_Init(mutex: *mut OSFastMutex, name: *const cty::c_char);
}
extern "C" {
    pub fn OSFastMutex_Lock(mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastMutex_Unlock(mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastMutex_TryLock(mutex: *mut OSFastMutex) -> BOOL;
}
pub type OSFiberEntryFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type OSFiberExEntryFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32, arg3: u32, arg4: u32)>;
extern "C" {
    pub fn OSSwitchFiber(entry: OSFiberEntryFn, stack: *mut cty::c_void) -> i32;
}
extern "C" {
    pub fn OSSwitchFiberEx(
        arg1: u32,
        arg2: u32,
        arg3: u32,
        arg4: u32,
        entry: OSFiberExEntryFn,
        stack: *mut cty::c_void,
    ) -> i32;
}
pub mod OSMessageFlags {
    pub type Type = cty::c_uint;
    pub const OS_MESSAGE_FLAGS_NONE: Type = 0;
    pub const OS_MESSAGE_FLAGS_BLOCKING: Type = 1;
    pub const OS_MESSAGE_FLAGS_HIGH_PRIORITY: Type = 2;
}
pub mod OSFunctionType {
    pub type Type = cty::c_uint;
    pub const OS_FUNCTION_TYPE_HIO_OPEN: Type = 1;
    pub const OS_FUNCTION_TYPE_HIO_READ_ASYNC: Type = 2;
    pub const OS_FUNCTION_TYPE_HIO_WRITE_ASYNC: Type = 3;
    pub const OS_FUNCTION_TYPE_FSA_CMD_ASYNC: Type = 4;
    pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC: Type = 5;
    pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC_NO_ALLOC: Type = 6;
    pub const OS_FUNCTION_TYPE_FSA_ATTACH_EVENT: Type = 7;
    pub const OS_FUNCTION_TYPE_FS_CMD_ASYNC: Type = 8;
    pub const OS_FUNCTION_TYPE_FS_CMD_HANDLER: Type = 9;
    pub const OS_FUNCTION_TYPE_FS_ATTACH_EVENT: Type = 10;
    pub const OS_FUNCTION_TYPE_FS_STATE_CHANGE_EVENT: Type = 11;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessage {
    pub message: *mut cty::c_void,
    pub args: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_OSMessage() {
    assert_eq!(
        ::core::mem::size_of::<OSMessage>(),
        16usize,
        concat!("Size of: ", stringify!(OSMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<OSMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(OSMessage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessage>())).message as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessage),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessage>())).args as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessage),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessageQueue {
    pub tag: u32,
    pub name: *const cty::c_char,
    pub __unk19: [cty::c_char; 4usize],
    pub sendQueue: OSThreadQueue,
    pub recvQueue: OSThreadQueue,
    pub messages: *mut OSMessage,
    pub size: u32,
    pub first: u32,
    pub used: u32,
}
#[test]
fn bindgen_test_layout_OSMessageQueue() {
    assert_eq!(
        ::core::mem::size_of::<OSMessageQueue>(),
        60usize,
        concat!("Size of: ", stringify!(OSMessageQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<OSMessageQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(OSMessageQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).__unk19 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(__unk19)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).sendQueue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(sendQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).recvQueue as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(recvQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).messages as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(messages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).first as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMessageQueue>())).used as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMessageQueue),
            "::",
            stringify!(used)
        )
    );
}
extern "C" {
    pub fn OSInitMessageQueue(queue: *mut OSMessageQueue, messages: *mut OSMessage, size: i32);
}
extern "C" {
    pub fn OSInitMessageQueueEx(
        queue: *mut OSMessageQueue,
        messages: *mut OSMessage,
        size: i32,
        name: *const cty::c_char,
    );
}
extern "C" {
    pub fn OSSendMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn OSReceiveMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn OSPeekMessage(queue: *mut OSMessageQueue, message: *mut OSMessage) -> BOOL;
}
extern "C" {
    pub fn OSGetSystemMessageQueue() -> *mut OSMessageQueue;
}
pub type FSDirectoryHandle = u32;
pub type FSFileHandle = u32;
pub type FSPriority = u32;
pub mod FSStatus {
    pub type Type = cty::c_int;
    pub const FS_STATUS_OK: Type = 0;
    pub const FS_STATUS_CANCELLED: Type = -1;
    pub const FS_STATUS_END: Type = -2;
    pub const FS_STATUS_MAX: Type = -3;
    pub const FS_STATUS_ALREADY_OPEN: Type = -4;
    pub const FS_STATUS_EXISTS: Type = -5;
    pub const FS_STATUS_NOT_FOUND: Type = -6;
    pub const FS_STATUS_NOT_FILE: Type = -7;
    pub const FS_STATUS_NOT_DIR: Type = -8;
    pub const FS_STATUS_ACCESS_ERROR: Type = -9;
    pub const FS_STATUS_PERMISSION_ERROR: Type = -10;
    pub const FS_STATUS_FILE_TOO_BIG: Type = -11;
    pub const FS_STATUS_STORAGE_FULL: Type = -12;
    pub const FS_STATUS_JOURNAL_FULL: Type = -13;
    pub const FS_STATUS_UNSUPPORTED_CMD: Type = -14;
    pub const FS_STATUS_MEDIA_NOT_READY: Type = -15;
    pub const FS_STATUS_MEDIA_ERROR: Type = -17;
    pub const FS_STATUS_CORRUPTED: Type = -18;
    pub const FS_STATUS_FATAL_ERROR: Type = -1024;
}
pub mod FSError {
    pub type Type = cty::c_int;
    pub const FS_ERROR_NOT_INIT: Type = -196609;
    pub const FS_ERROR_BUSY: Type = -196610;
    pub const FS_ERROR_CANCELLED: Type = -196611;
    pub const FS_ERROR_END_OF_DIR: Type = -196612;
    pub const FS_ERROR_END_OF_FILE: Type = -196613;
    pub const FS_ERROR_MAX_MOUNT_POINTS: Type = -196624;
    pub const FS_ERROR_MAX_VOLUMES: Type = -196625;
    pub const FS_ERROR_MAX_CLIENTS: Type = -196626;
    pub const FS_ERROR_MAX_FILES: Type = -196627;
    pub const FS_ERROR_MAX_DIRS: Type = -196628;
    pub const FS_ERROR_ALREADY_OPEN: Type = -196629;
    pub const FS_ERROR_ALREADY_EXISTS: Type = -196630;
    pub const FS_ERROR_NOT_FOUND: Type = -196631;
    pub const FS_ERROR_NOT_EMPTY: Type = -196632;
    pub const FS_ERROR_ACCESS_ERROR: Type = -196633;
    pub const FS_ERROR_PERMISSION_ERROR: Type = -196634;
    pub const FS_ERROR_DATA_CORRUPTED: Type = -196635;
    pub const FS_ERROR_STORAGE_FULL: Type = -196636;
    pub const FS_ERROR_JOURNAL_FULL: Type = -196637;
    pub const FS_ERROR_UNAVAILABLE_COMMAND: Type = -196639;
    pub const FS_ERROR_UNSUPPORTED_COMMAND: Type = -196640;
    pub const FS_ERROR_INVALID_PARAM: Type = -196641;
    pub const FS_ERROR_INVALID_PATH: Type = -196642;
    pub const FS_ERROR_INVALID_BUFFER: Type = -196643;
    pub const FS_ERROR_INVALID_ALIGNMENT: Type = -196644;
    pub const FS_ERROR_INVALID_CLIENTHANDLE: Type = -196645;
    pub const FS_ERROR_INVALID_FILEHANDLE: Type = -196646;
    pub const FS_ERROR_INVALID_DIRHANDLE: Type = -196647;
    pub const FS_ERROR_NOT_FILE: Type = -196648;
    pub const FS_ERROR_NOT_DIR: Type = -196649;
    pub const FS_ERROR_FILE_TOO_BIG: Type = -196650;
    pub const FS_ERROR_OUT_OF_RANGE: Type = -196651;
    pub const FS_ERROR_OUT_OF_RESOURCES: Type = -196652;
    pub const FS_ERROR_MEDIA_NOT_READY: Type = -196656;
    pub const FS_ERROR_MEDIA_ERROR: Type = -196657;
    pub const FS_ERROR_WRITE_PROTECTED: Type = -196658;
    pub const FS_ERROR_INVALID_MEDIA: Type = -196659;
}
pub mod FSMode {
    pub type Type = cty::c_uint;
    pub const FS_MODE_READ_OWNER: Type = 1024;
    pub const FS_MODE_WRITE_OWNER: Type = 512;
    pub const FS_MODE_EXEC_OWNER: Type = 256;
    pub const FS_MODE_READ_GROUP: Type = 64;
    pub const FS_MODE_WRITE_GROUP: Type = 32;
    pub const FS_MODE_EXEC_GROUP: Type = 16;
    pub const FS_MODE_READ_OTHER: Type = 4;
    pub const FS_MODE_WRITE_OTHER: Type = 2;
    pub const FS_MODE_EXEC_OTHER: Type = 1;
}
pub mod FSStatFlags {
    pub type Type = cty::c_uint;
    pub const FS_STAT_DIRECTORY: Type = 2147483648;
}
pub mod FSVolumeState {
    pub type Type = cty::c_uint;
    pub const FS_VOLUME_STATE_INITIAL: Type = 0;
    pub const FS_VOLUME_STATE_READY: Type = 1;
    pub const FS_VOLUME_STATE_NO_MEDIA: Type = 2;
    pub const FS_VOLUME_STATE_INVALID_MEDIA: Type = 3;
    pub const FS_VOLUME_STATE_DIRTY_MEDIA: Type = 4;
    pub const FS_VOLUME_STATE_WRONG_MEDIA: Type = 5;
    pub const FS_VOLUME_STATE_MEDIA_ERROR: Type = 6;
    pub const FS_VOLUME_STATE_DATA_CORRUPTED: Type = 7;
    pub const FS_VOLUME_STATE_WRITE_PROTECTED: Type = 8;
    pub const FS_VOLUME_STATE_JOURNAL_FULL: Type = 9;
    pub const FS_VOLUME_STATE_FATAL: Type = 10;
    pub const FS_VOLUME_STATE_INVALID: Type = 11;
}
pub mod FSMountSourceType {
    pub type Type = cty::c_uint;
    pub const FS_MOUNT_SOURCE_SD: Type = 0;
    pub const FS_MOUNT_SOURCE_UNK: Type = 1;
}
pub type FSAsyncCallback = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSClient,
        arg2: *mut FSCmdBlock,
        arg3: FSStatus::Type,
        arg4: u32,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSClient {
    pub __unk20: [cty::c_char; 5888usize],
}
#[test]
fn bindgen_test_layout_FSClient() {
    assert_eq!(
        ::core::mem::size_of::<FSClient>(),
        5888usize,
        concat!("Size of: ", stringify!(FSClient))
    );
    assert_eq!(
        ::core::mem::align_of::<FSClient>(),
        1usize,
        concat!("Alignment of ", stringify!(FSClient))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSClient>())).__unk20 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSClient),
            "::",
            stringify!(__unk20)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSCmdBlock {
    pub __unk21: [cty::c_char; 2688usize],
}
#[test]
fn bindgen_test_layout_FSCmdBlock() {
    assert_eq!(
        ::core::mem::size_of::<FSCmdBlock>(),
        2688usize,
        concat!("Size of: ", stringify!(FSCmdBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<FSCmdBlock>(),
        1usize,
        concat!("Alignment of ", stringify!(FSCmdBlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSCmdBlock>())).__unk21 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSCmdBlock),
            "::",
            stringify!(__unk21)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSStat {
    pub flags: FSStatFlags::Type,
    pub mode: FSMode::Type,
    pub owner: u32,
    pub group: u32,
    pub size: u32,
    pub allocSize: u32,
    pub quotaSize: u64,
    pub entryId: u32,
    pub created: i64,
    pub modified: i64,
    pub __unk22: [cty::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_FSStat() {
    assert_eq!(
        ::core::mem::size_of::<FSStat>(),
        100usize,
        concat!("Size of: ", stringify!(FSStat))
    );
    assert_eq!(
        ::core::mem::align_of::<FSStat>(),
        1usize,
        concat!("Alignment of ", stringify!(FSStat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).group as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).allocSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(allocSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).quotaSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(quotaSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).entryId as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(entryId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).created as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).modified as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStat>())).__unk22 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStat),
            "::",
            stringify!(__unk22)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSStateChangeInfo {
    pub __unk23: [cty::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_FSStateChangeInfo() {
    assert_eq!(
        ::core::mem::size_of::<FSStateChangeInfo>(),
        12usize,
        concat!("Size of: ", stringify!(FSStateChangeInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<FSStateChangeInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(FSStateChangeInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSStateChangeInfo>())).__unk23 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSStateChangeInfo),
            "::",
            stringify!(__unk23)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSMessage {
    #[doc = "! Message data"]
    pub data: *mut cty::c_void,
    pub __unk24: [cty::c_char; 8usize],
    #[doc = "! Type of message"]
    pub type_: OSFunctionType::Type,
}
#[test]
fn bindgen_test_layout_FSMessage() {
    assert_eq!(
        ::core::mem::size_of::<FSMessage>(),
        16usize,
        concat!("Size of: ", stringify!(FSMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<FSMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(FSMessage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSMessage>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSMessage>())).__unk24 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSMessage),
            "::",
            stringify!(__unk24)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSMessage>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FSMessage),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncData {
    pub callback: FSAsyncCallback,
    pub param: u32,
    pub ioMsgQueue: *mut OSMessageQueue,
}
#[test]
fn bindgen_test_layout_FSAsyncData() {
    assert_eq!(
        ::core::mem::size_of::<FSAsyncData>(),
        12usize,
        concat!("Size of: ", stringify!(FSAsyncData))
    );
    assert_eq!(
        ::core::mem::align_of::<FSAsyncData>(),
        4usize,
        concat!("Alignment of ", stringify!(FSAsyncData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncData>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncData),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncData>())).param as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncData),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncData>())).ioMsgQueue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncData),
            "::",
            stringify!(ioMsgQueue)
        )
    );
}
#[doc = " Stores the result of an async FS command."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncResult {
    #[doc = "! User supplied async data."]
    pub asyncData: FSAsyncData,
    #[doc = "! Message to put into asyncdata.ioMsgQueue."]
    pub ioMsg: FSMessage,
    #[doc = "! FSClient which owns this result."]
    pub client: *mut FSClient,
    #[doc = "! FSCmdBlock which owns this result."]
    pub block: *mut FSCmdBlock,
    #[doc = "! The result of the command."]
    pub status: FSStatus::Type,
}
#[test]
fn bindgen_test_layout_FSAsyncResult() {
    assert_eq!(
        ::core::mem::size_of::<FSAsyncResult>(),
        40usize,
        concat!("Size of: ", stringify!(FSAsyncResult))
    );
    assert_eq!(
        ::core::mem::align_of::<FSAsyncResult>(),
        4usize,
        concat!("Alignment of ", stringify!(FSAsyncResult))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncResult>())).asyncData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncResult),
            "::",
            stringify!(asyncData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncResult>())).ioMsg as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncResult),
            "::",
            stringify!(ioMsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncResult>())).client as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncResult),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncResult>())).block as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncResult),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSAsyncResult>())).status as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSAsyncResult),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSDirectoryEntry {
    pub info: FSStat,
    pub name: [cty::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_FSDirectoryEntry() {
    assert_eq!(
        ::core::mem::size_of::<FSDirectoryEntry>(),
        356usize,
        concat!("Size of: ", stringify!(FSDirectoryEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<FSDirectoryEntry>(),
        1usize,
        concat!("Alignment of ", stringify!(FSDirectoryEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSDirectoryEntry>())).info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectoryEntry),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSDirectoryEntry>())).name as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectoryEntry),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSMountSource {
    pub __unk25: [cty::c_char; 768usize],
}
#[test]
fn bindgen_test_layout_FSMountSource() {
    assert_eq!(
        ::core::mem::size_of::<FSMountSource>(),
        768usize,
        concat!("Size of: ", stringify!(FSMountSource))
    );
    assert_eq!(
        ::core::mem::align_of::<FSMountSource>(),
        1usize,
        concat!("Alignment of ", stringify!(FSMountSource))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FSMountSource>())).__unk25 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSMountSource),
            "::",
            stringify!(__unk25)
        )
    );
}
extern "C" {
    pub fn FSInit();
}
extern "C" {
    pub fn FSShutdown();
}
extern "C" {
    pub fn FSAddClient(client: *mut FSClient, flags: u32) -> FSStatus::Type;
}
extern "C" {
    pub fn FSDelClient(client: *mut FSClient, flags: u32) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetClientNum() -> u32;
}
extern "C" {
    pub fn FSInitCmdBlock(block: *mut FSCmdBlock);
}
extern "C" {
    pub fn FSSetCmdPriority(block: *mut FSCmdBlock, priority: FSPriority) -> FSStatus::Type;
}
extern "C" {
    pub fn FSSetStateChangeNotification(client: *mut FSClient, info: *mut FSStateChangeInfo);
}
extern "C" {
    pub fn FSGetCwd(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut cty::c_char,
        bufferSize: u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetAsyncResult(message: *mut FSMessage) -> *mut FSAsyncResult;
}
extern "C" {
    pub fn FSGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        stat: *mut FSStat,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        stat: *mut FSStat,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        mode: *const cty::c_char,
        handle: *mut FSFileHandle,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        mode: *const cty::c_char,
        outHandle: *mut FSFileHandle,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        handle: *mut FSDirectoryHandle,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        handle: *mut FSDirectoryHandle,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const cty::c_char,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRewindDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *mut cty::c_char,
        mode: FSMode::Type,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *mut cty::c_char,
        mode: FSMode::Type,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *mut cty::c_char,
        outSize: *mut u64,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *mut cty::c_char,
        outSize: *mut u64,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetStatFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetStatFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSSetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSSetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSFlushFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSFlushFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSTruncateFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSTruncateFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const cty::c_char,
        newPath: *const cty::c_char,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const cty::c_char,
        newPath: *const cty::c_char,
        flags: u32,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetVolumeState(client: *mut FSClient) -> FSVolumeState::Type;
}
extern "C" {
    pub fn FSGetLastErrorCodeForViewer(client: *mut FSClient) -> FSError::Type;
}
extern "C" {
    pub fn FSGetMountSource(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        type_: FSMountSourceType::Type,
        out: *mut FSMountSource,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *mut FSMountSource,
        target: *const cty::c_char,
        bytes: u32,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const cty::c_char,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSBindMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *const cty::c_char,
        target: *const cty::c_char,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSbindUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const cty::c_char,
        flags: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn OSEnableForegroundExit();
}
extern "C" {
    pub fn OSReleaseForeground();
}
extern "C" {
    pub fn OSSavesDone_ReadyToRelease();
}
extern "C" {
    pub fn __os_snprintf(
        buf: *mut cty::c_char,
        n: size_t,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
pub type IOSHandle = i32;
pub mod IOSOpenMode {
    pub type Type = cty::c_uint;
    pub const IOS_OPEN_READ: Type = 1;
    pub const IOS_OPEN_WRITE: Type = 2;
    pub const IOS_OPEN_READWRITE: Type = 3;
}
pub mod IOSError {
    pub type Type = cty::c_int;
    pub const IOS_ERROR_OK: Type = 0;
    pub const IOS_ERROR_ACCESS: Type = -1;
    pub const IOS_ERROR_EXISTS: Type = -2;
    pub const IOS_ERROR_INTR: Type = -3;
    pub const IOS_ERROR_INVALID: Type = -4;
    pub const IOS_ERROR_MAX: Type = -5;
    pub const IOS_ERROR_NOEXISTS: Type = -6;
    pub const IOS_ERROR_QEMPTY: Type = -7;
    pub const IOS_ERROR_QFULL: Type = -8;
    pub const IOS_ERROR_UNKNOWN: Type = -9;
    pub const IOS_ERROR_NOTREADY: Type = -10;
    pub const IOS_ERROR_ECC: Type = -11;
    pub const IOS_ERROR_ECCCRIT: Type = -12;
    pub const IOS_ERROR_BADBLOCK: Type = -13;
    pub const IOS_ERROR_INVALIDOBJTYPE: Type = -14;
    pub const IOS_ERROR_INVALIDRNG: Type = -15;
    pub const IOS_ERROR_INVALIDFLAG: Type = -16;
    pub const IOS_ERROR_INVALIDFORMAT: Type = -17;
    pub const IOS_ERROR_INVALIDVERSION: Type = -18;
    pub const IOS_ERROR_INVALIDSIGNER: Type = -19;
    pub const IOS_ERROR_FAILCHECKVALUE: Type = -20;
    pub const IOS_ERROR_FAILINTERNAL: Type = -21;
    pub const IOS_ERROR_FAILALLOC: Type = -22;
    pub const IOS_ERROR_INVALIDSIZE: Type = -23;
    pub const IOS_ERROR_NOLINK: Type = -24;
    pub const IOS_ERROR_ANFAILED: Type = -25;
    pub const IOS_ERROR_MAXSEMCOUNT: Type = -26;
    pub const IOS_ERROR_SEMUNAVAILABLE: Type = -27;
    pub const IOS_ERROR_INVALIDHANDLE: Type = -28;
    pub const IOS_ERROR_INVALIDARG: Type = -29;
    pub const IOS_ERROR_NORESOURCE: Type = -30;
    pub const IOS_ERROR_BUSY: Type = -31;
    pub const IOS_ERROR_TIMEOUT: Type = -32;
    pub const IOS_ERROR_ALIGNMENT: Type = -33;
    pub const IOS_ERROR_BSP: Type = -34;
    pub const IOS_ERROR_DATAPENDING: Type = -35;
    pub const IOS_ERROR_EXPIRED: Type = -36;
    pub const IOS_ERROR_NOREADACCESS: Type = -37;
    pub const IOS_ERROR_NOWRITEACCESS: Type = -38;
    pub const IOS_ERROR_NOREADWRITEACCESS: Type = -39;
    pub const IOS_ERROR_CLIENTTXNLIMIT: Type = -40;
    pub const IOS_ERROR_STALEHANDLE: Type = -41;
    pub const IOS_ERROR_UNKNOWNVALUE: Type = -42;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOSVec {
    #[doc = "! Virtual address of buffer."]
    pub vaddr: *mut cty::c_void,
    #[doc = "! Length of buffer."]
    pub len: u32,
    #[doc = "! Physical address of buffer."]
    pub paddr: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_IOSVec() {
    assert_eq!(
        ::core::mem::size_of::<IOSVec>(),
        12usize,
        concat!("Size of: ", stringify!(IOSVec))
    );
    assert_eq!(
        ::core::mem::align_of::<IOSVec>(),
        4usize,
        concat!("Alignment of ", stringify!(IOSVec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IOSVec>())).vaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOSVec),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IOSVec>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IOSVec),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IOSVec>())).paddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IOSVec),
            "::",
            stringify!(paddr)
        )
    );
}
pub type IOSAsyncCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: IOSError::Type, arg2: *mut cty::c_void)>;
extern "C" {
    pub fn IOS_Open(device: *const cty::c_char, mode: IOSOpenMode::Type) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_OpenAsync(
        device: *const cty::c_char,
        mode: IOSOpenMode::Type,
        callback: IOSAsyncCallbackFn,
        context: *mut cty::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_Close(handle: IOSHandle) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_CloseAsync(
        handle: IOSHandle,
        callback: IOSAsyncCallbackFn,
        context: *mut cty::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_Ioctl(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut cty::c_void,
        inLen: u32,
        outBuf: *mut cty::c_void,
        outLen: u32,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_IoctlAsync(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut cty::c_void,
        inLen: u32,
        outBuf: *mut cty::c_void,
        outLen: u32,
        callback: IOSAsyncCallbackFn,
        context: *mut cty::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_Ioctlv(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_IoctlvAsync(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
        callback: IOSAsyncCallbackFn,
        context: *mut cty::c_void,
    ) -> IOSError::Type;
}
pub type MCPError = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPDeviceList {
    _unused: [u8; 0],
}
pub mod MCPAppType {
    pub type Type = cty::c_uint;
    pub const MCP_APP_TYPE_GAME_UPDATE: Type = 134217755;
    pub const MCP_APP_TYPE_GAME_DLC: Type = 134217742;
    pub const MCP_APP_TYPE_BOOT1: Type = 268435465;
    pub const MCP_APP_TYPE_SYSTEM_LIBRARIES: Type = 268435466;
    pub const MCP_APP_TYPE_BLUETOOTH_FIRMWARE: Type = 268435474;
    pub const MCP_APP_TYPE_DRH_FIRMWARE: Type = 268435475;
    pub const MCP_APP_TYPE_DRC_FIRMWARE: Type = 268435476;
    pub const MCP_APP_TYPE_SYSTEM_VERSION: Type = 268435477;
    pub const MCP_APP_TYPE_DRC_LANGUAGE: Type = 268435482;
    pub const MCP_APP_TYPE_EXCEPTIONS_DATA: Type = 402653200;
    pub const MCP_APP_TYPE_SHARED_DATA: Type = 402653212;
    pub const MCP_APP_TYPE_CERT_STORE: Type = 402653214;
    pub const MCP_APP_TYPE_PATCH_MAP_DATA: Type = 402653219;
    pub const MCP_APP_TYPE_WAGONU_MIGRATION_LIST: Type = 402653225;
    pub const MCP_APP_TYPE_CAFFEINE_TITLE_LIST: Type = 402653232;
    pub const MCP_APP_TYPE_MCP_TITLE_LIST: Type = 402653233;
    pub const MCP_APP_TYPE_GAME: Type = 2147483648;
    pub const MCP_APP_TYPE_GAME_WII: Type = 2147483694;
    pub const MCP_APP_TYPE_SYSTEM_MENU: Type = 2415919105;
    pub const MCP_APP_TYPE_SYSTEM_UPDATER: Type = 2415919115;
    pub const MCP_APP_TYPE_SYSTEM_APPS: Type = 2415919136;
    pub const MCP_APP_TYPE_ACCOUNT_APPS: Type = 2415919137;
    pub const MCP_APP_TYPE_SYSTEM_SETTINGS: Type = 2415919138;
    pub const MCP_APP_TYPE_ECO_PROCESS: Type = 2415919151;
    pub const MCP_APP_TYPE_EMANUAL: Type = 3489660931;
    pub const MCP_APP_TYPE_HOME_MENU: Type = 3489660932;
    pub const MCP_APP_TYPE_ERROR_DISPLAY: Type = 3489660933;
    pub const MCP_APP_TYPE_BROWSER: Type = 3489660934;
    pub const MCP_APP_TYPE_MIIVERSE_POST: Type = 3489660941;
    pub const MCP_APP_TYPE_MIIVERSE: Type = 3489660950;
    pub const MCP_APP_TYPE_ESHOP: Type = 3489660951;
    pub const MCP_APP_TYPE_FRIEND_LIST: Type = 3489660952;
    pub const MCP_APP_TYPE_DOWNLOAD_MANAGEMENT: Type = 3489660953;
    pub const MCP_APP_TYPE_AOC_OVERLAY: Type = 3489660972;
    pub const MCP_APP_TYPE_AMIIBO_SETTINGS: Type = 3489660979;
}
pub mod MCPDeviceFlags {
    pub type Type = cty::c_uint;
    pub const MCP_DEVICE_FLAG_UNK_1: Type = 1;
    pub const MCP_DEVICE_FLAG_UNK_2: Type = 2;
    pub const MCP_DEVICE_FLAG_UNK_4: Type = 4;
    pub const MCP_DEVICE_FLAG_UNK_8: Type = 8;
}
pub mod MCPInstallTarget {
    pub type Type = cty::c_uint;
    pub const MCP_INSTALL_TARGET_MLC: Type = 0;
    pub const MCP_INSTALL_TARGET_USB: Type = 1;
}
pub mod MCPRegion {
    pub type Type = cty::c_uint;
    pub const MCP_REGION_JAPAN: Type = 1;
    pub const MCP_REGION_USA: Type = 2;
    pub const MCP_REGION_EUROPE: Type = 4;
    pub const MCP_REGION_CHINA: Type = 16;
    pub const MCP_REGION_KOREA: Type = 32;
    pub const MCP_REGION_TAIWAN: Type = 64;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct MCPDevice {
    pub type_: [cty::c_char; 8usize],
    pub unk0x08: [cty::c_char; 128usize],
    pub filesystem: [cty::c_char; 8usize],
    pub path: [cty::c_char; 639usize],
    pub flags: MCPDeviceFlags::Type,
    pub uid: u32,
    pub index: u32,
}
#[test]
fn bindgen_test_layout_MCPDevice() {
    assert_eq!(
        ::core::mem::size_of::<MCPDevice>(),
        795usize,
        concat!("Size of: ", stringify!(MCPDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<MCPDevice>(),
        1usize,
        concat!("Alignment of ", stringify!(MCPDevice))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPDevice>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPDevice),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPDevice>())).unk0x08 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPDevice),
            "::",
            stringify!(unk0x08)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPDevice>())).filesystem as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPDevice),
            "::",
            stringify!(filesystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPDevice>())).path as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPDevice),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPDevice>())).flags as *const _ as usize },
        783usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPDevice),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPDevice>())).uid as *const _ as usize },
        787usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPDevice),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPDevice>())).index as *const _ as usize },
        791usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPDevice),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MCPInstallInfo {
    pub __unk26: [cty::c_char; 639usize],
}
#[test]
fn bindgen_test_layout_MCPInstallInfo() {
    assert_eq!(
        ::core::mem::size_of::<MCPInstallInfo>(),
        639usize,
        concat!("Size of: ", stringify!(MCPInstallInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MCPInstallInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(MCPInstallInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPInstallInfo>())).__unk26 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallInfo),
            "::",
            stringify!(__unk26)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallProgress {
    pub inProgress: u32,
    pub tid: u64,
    pub sizeTotal: u64,
    pub sizeProgress: u64,
    pub contentsTotal: u32,
    pub contentsProgress: u32,
}
#[test]
fn bindgen_test_layout_MCPInstallProgress() {
    assert_eq!(
        ::core::mem::size_of::<MCPInstallProgress>(),
        36usize,
        concat!("Size of: ", stringify!(MCPInstallProgress))
    );
    assert_eq!(
        ::core::mem::align_of::<MCPInstallProgress>(),
        1usize,
        concat!("Alignment of ", stringify!(MCPInstallProgress))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPInstallProgress>())).inProgress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallProgress),
            "::",
            stringify!(inProgress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPInstallProgress>())).tid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallProgress),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPInstallProgress>())).sizeTotal as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallProgress),
            "::",
            stringify!(sizeTotal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPInstallProgress>())).sizeProgress as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallProgress),
            "::",
            stringify!(sizeProgress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPInstallProgress>())).contentsTotal as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallProgress),
            "::",
            stringify!(contentsTotal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPInstallProgress>())).contentsProgress as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallProgress),
            "::",
            stringify!(contentsProgress)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MCPInstallTitleInfo {
    pub __unk27: [cty::c_char; 639usize],
}
#[test]
fn bindgen_test_layout_MCPInstallTitleInfo() {
    assert_eq!(
        ::core::mem::size_of::<MCPInstallTitleInfo>(),
        639usize,
        concat!("Size of: ", stringify!(MCPInstallTitleInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MCPInstallTitleInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(MCPInstallTitleInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPInstallTitleInfo>())).__unk27 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPInstallTitleInfo),
            "::",
            stringify!(__unk27)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPSysProdSettings {
    pub product_area: MCPRegion::Type,
    pub eeprom_version: u16,
    pub __unk28: [cty::c_char; 2usize],
    pub game_region: MCPRegion::Type,
    pub __unk29: [cty::c_char; 4usize],
    pub ntsc_pal: [cty::c_char; 5usize],
    #[doc = "! 5ghz_country_code in xml"]
    pub wifi_5ghz_country_code: [cty::c_char; 4usize],
    #[doc = "! 5ghz_country_code_revision in xml"]
    pub wifi_5ghz_country_code_revision: u8,
    pub code_id: [cty::c_char; 8usize],
    pub serial_id: [cty::c_char; 12usize],
    pub __unk30: [cty::c_char; 4usize],
    pub model_number: [cty::c_char; 16usize],
    pub version: u32,
}
#[test]
fn bindgen_test_layout_MCPSysProdSettings() {
    assert_eq!(
        ::core::mem::size_of::<MCPSysProdSettings>(),
        70usize,
        concat!("Size of: ", stringify!(MCPSysProdSettings))
    );
    assert_eq!(
        ::core::mem::align_of::<MCPSysProdSettings>(),
        1usize,
        concat!("Alignment of ", stringify!(MCPSysProdSettings))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPSysProdSettings>())).product_area as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(product_area)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPSysProdSettings>())).eeprom_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(eeprom_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).__unk28 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(__unk28)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).game_region as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(game_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).__unk29 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(__unk29)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).ntsc_pal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(ntsc_pal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPSysProdSettings>())).wifi_5ghz_country_code as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(wifi_5ghz_country_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPSysProdSettings>())).wifi_5ghz_country_code_revision
                as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(wifi_5ghz_country_code_revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).code_id as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(code_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).serial_id as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(serial_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).__unk30 as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(__unk30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MCPSysProdSettings>())).model_number as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(model_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPSysProdSettings>())).version as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPSysProdSettings),
            "::",
            stringify!(version)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct MCPTitleListType {
    pub titleId: u64,
    pub groupId: u32,
    pub path: [cty::c_char; 56usize],
    pub appType: MCPAppType::Type,
    pub titleVersion: u16,
    pub osVersion: u64,
    pub sdkVersion: u32,
    pub indexedDevice: [cty::c_char; 10usize],
    pub unk0x60: u8,
}
#[test]
fn bindgen_test_layout_MCPTitleListType() {
    assert_eq!(
        ::core::mem::size_of::<MCPTitleListType>(),
        97usize,
        concat!("Size of: ", stringify!(MCPTitleListType))
    );
    assert_eq!(
        ::core::mem::align_of::<MCPTitleListType>(),
        1usize,
        concat!("Alignment of ", stringify!(MCPTitleListType))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).titleId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(titleId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).groupId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(groupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).path as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).appType as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(appType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).titleVersion as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(titleVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).osVersion as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(osVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).sdkVersion as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(sdkVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).indexedDevice as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(indexedDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPTitleListType>())).unk0x60 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPTitleListType),
            "::",
            stringify!(unk0x60)
        )
    );
}
extern "C" {
    pub fn MCP_Open() -> MCPError;
}
extern "C" {
    pub fn MCP_Close(handle: cty::c_int) -> MCPError;
}
extern "C" {
    pub fn MCP_DeviceList(
        handle: cty::c_int,
        numDevices: *mut cty::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_FullDeviceList(
        handle: cty::c_int,
        numDevices: *mut cty::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_GetOwnTitleInfo(handle: i32, titleInfo: *mut MCPTitleListType) -> MCPError;
}
extern "C" {
    pub fn MCP_GetSysProdSettings(handle: i32, settings: *mut MCPSysProdSettings) -> MCPError;
}
extern "C" {
    pub fn MCP_GetTitleId(handle: i32, outTitleId: *mut u64) -> MCPError;
}
extern "C" {
    pub fn MCP_GetTitleInfo(
        handle: i32,
        titleId: u64,
        titleInfo: *mut MCPTitleListType,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallSetTargetDevice(
        handle: cty::c_int,
        device: MCPInstallTarget::Type,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetTargetDevice(
        handle: cty::c_int,
        deviceOut: *mut MCPInstallTarget::Type,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallSetTargetUsb(handle: cty::c_int, usb: cty::c_int) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetInfo(
        handle: cty::c_int,
        path: *mut cty::c_char,
        out: *mut MCPInstallInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallTitleAsync(
        handle: cty::c_int,
        path: *mut cty::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetProgress(
        handle: cty::c_int,
        installProgressOut: *mut MCPInstallProgress,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallTitleAbort(handle: cty::c_int) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleCount(handle: i32) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleList(
        handle: i32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByAppType(
        handle: i32,
        appType: MCPAppType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByUniqueId(
        handle: i32,
        uniqueId: u32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByUniqueIdAndIndexedDeviceAndAppType(
        handle: i32,
        uniqueId: u32,
        indexedDevice: *const cty::c_char,
        unk0x60: u8,
        appType: MCPAppType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_UninstallTitleAsync(
        handle: cty::c_int,
        path: *mut cty::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn OSInitSpinLock(spinlock: *mut OSSpinLock);
}
extern "C" {
    pub fn OSAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSTryAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSTryAcquireSpinLockWithTimeout(spinlock: *mut OSSpinLock, timeout: OSTime) -> BOOL;
}
extern "C" {
    pub fn OSReleaseSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_Acquire(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_TryAcquire(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_TryAcquireWithTimeout(
        spinlock: *mut OSSpinLock,
        timeout: OSTime,
    ) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_Release(spinlock: *mut OSSpinLock) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryLink {
    pub prev: *mut cty::c_void,
    pub next: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_MEMMemoryLink() {
    assert_eq!(
        ::core::mem::size_of::<MEMMemoryLink>(),
        8usize,
        concat!("Size of: ", stringify!(MEMMemoryLink))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMMemoryLink>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMMemoryLink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMMemoryLink>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMMemoryLink),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMMemoryLink>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMMemoryLink),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryList {
    pub head: *mut cty::c_void,
    pub tail: *mut cty::c_void,
    pub count: u16,
    pub offsetToMemoryLink: u16,
}
#[test]
fn bindgen_test_layout_MEMMemoryList() {
    assert_eq!(
        ::core::mem::size_of::<MEMMemoryList>(),
        12usize,
        concat!("Size of: ", stringify!(MEMMemoryList))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMMemoryList>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMMemoryList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMMemoryList>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMMemoryList),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMMemoryList>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMMemoryList),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMMemoryList>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMMemoryList),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MEMMemoryList>())).offsetToMemoryLink as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMMemoryList),
            "::",
            stringify!(offsetToMemoryLink)
        )
    );
}
extern "C" {
    pub fn MEMInitList(list: *mut MEMMemoryList, offsetToMemoryLink: u16);
}
extern "C" {
    pub fn MEMAppendListObject(list: *mut MEMMemoryList, object: *mut cty::c_void);
}
extern "C" {
    pub fn MEMPrependListObject(list: *mut MEMMemoryList, object: *mut cty::c_void);
}
extern "C" {
    pub fn MEMInsertListObject(
        list: *mut MEMMemoryList,
        before: *mut cty::c_void,
        object: *mut cty::c_void,
    );
}
extern "C" {
    pub fn MEMRemoveListObject(list: *mut MEMMemoryList, object: *mut cty::c_void);
}
extern "C" {
    pub fn MEMGetNextListObject(
        list: *mut MEMMemoryList,
        object: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMGetPrevListObject(
        list: *mut MEMMemoryList,
        object: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMGetNthListObject(list: *mut MEMMemoryList, n: u16) -> *mut cty::c_void;
}
pub type MEMHeapHandle = *mut MEMHeapHeader;
pub mod MEMBaseHeapType {
    pub type Type = cty::c_uint;
    pub const MEM_BASE_HEAP_MEM1: Type = 0;
    pub const MEM_BASE_HEAP_MEM2: Type = 1;
    pub const MEM_BASE_HEAP_FG: Type = 8;
}
pub mod MEMHeapFillType {
    pub type Type = cty::c_uint;
    pub const MEM_HEAP_FILL_TYPE_UNUSED: Type = 0;
    pub const MEM_HEAP_FILL_TYPE_ALLOCATED: Type = 1;
    pub const MEM_HEAP_FILL_TYPE_FREED: Type = 2;
}
pub mod MEMHeapTag {
    pub type Type = cty::c_uint;
    pub const MEM_BLOCK_HEAP_TAG: Type = 1112296264;
    pub const MEM_EXPANDED_HEAP_TAG: Type = 1163415624;
    pub const MEM_FRAME_HEAP_TAG: Type = 1179798856;
    pub const MEM_UNIT_HEAP_TAG: Type = 1431196744;
    pub const MEM_USER_HEAP_TAG: Type = 1431523912;
}
pub mod MEMHeapFlags {
    pub type Type = cty::c_uint;
    pub const MEM_HEAP_FLAG_ZERO_ALLOCATED: Type = 1;
    pub const MEM_HEAP_FLAG_DEBUG_MODE: Type = 2;
    pub const MEM_HEAP_FLAG_USE_LOCK: Type = 4;
}
#[repr(C, packed)]
pub struct MEMHeapHeader {
    #[doc = "! Tag indicating which type of heap this is"]
    pub tag: MEMHeapTag::Type,
    #[doc = "! Link for list this heap is in"]
    pub link: MEMMemoryLink,
    #[doc = "! List of all child heaps in this heap"]
    pub list: MEMMemoryList,
    #[doc = "! Pointer to start of allocatable memory"]
    pub dataStart: *mut cty::c_void,
    #[doc = "! Pointer to end of allocatable memory"]
    pub dataEnd: *mut cty::c_void,
    #[doc = "! Lock used when MEM_HEAP_FLAG_USE_LOCK is set."]
    pub lock: OSSpinLock,
    #[doc = "! Flags set during heap creation."]
    pub flags: u32,
    pub __unk33: [cty::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_MEMHeapHeader() {
    assert_eq!(
        ::core::mem::size_of::<MEMHeapHeader>(),
        64usize,
        concat!("Size of: ", stringify!(MEMHeapHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMHeapHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(MEMHeapHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).link as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).list as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).dataStart as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(dataStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).dataEnd as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(dataEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMHeapHeader>())).__unk33 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMHeapHeader),
            "::",
            stringify!(__unk33)
        )
    );
}
extern "C" {
    #[doc = " Get which memory area a heap belongs to."]
    pub fn MEMGetArena(handle: MEMHeapHandle) -> MEMBaseHeapType::Type;
}
extern "C" {
    #[doc = " Get base heap for memory area."]
    pub fn MEMGetBaseHeapHandle(type_: MEMBaseHeapType::Type) -> MEMHeapHandle;
}
extern "C" {
    #[doc = " Set base heap for memory area."]
    pub fn MEMSetBaseHeapHandle(
        type_: MEMBaseHeapType::Type,
        handle: MEMHeapHandle,
    ) -> MEMHeapHandle;
}
extern "C" {
    #[doc = " Create a heap handle for a user defined heap."]
    pub fn MEMCreateUserHeapHandle(heap: *mut cty::c_void, size: u32) -> MEMHeapHandle;
}
extern "C" {
    #[doc = " Print details about heap to COSWarn"]
    pub fn MEMDumpHeap(heap: MEMHeapHandle);
}
extern "C" {
    #[doc = " Find heap which contains a memory block."]
    pub fn MEMFindContainHeap(block: *mut cty::c_void) -> *mut MEMHeapHeader;
}
extern "C" {
    #[doc = " Find the parent heap of a given heap. Return NULL if no parent was found."]
    pub fn MEMFindParentHeap(handle: MEMHeapHandle) -> MEMHeapHandle;
}
extern "C" {
    #[doc = " Get the data fill value used when MEM_HEAP_FLAG_DEBUG_MODE is set."]
    pub fn MEMGetFillValForHeap(type_: MEMHeapFillType::Type) -> u32;
}
extern "C" {
    #[doc = " Set the data fill value used when MEM_HEAP_FLAG_DEBUG_MODE is set."]
    pub fn MEMSetFillValForHeap(type_: MEMHeapFillType::Type, value: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMBlockHeapTracking {
    pub __unk34: [cty::c_char; 8usize],
    #[doc = "! Pointer to first memory block"]
    pub blocks: *mut MEMBlockHeapBlock,
    #[doc = "! Number of blocks in this tracking heap"]
    pub blockCount: u32,
}
#[test]
fn bindgen_test_layout_MEMBlockHeapTracking() {
    assert_eq!(
        ::core::mem::size_of::<MEMBlockHeapTracking>(),
        16usize,
        concat!("Size of: ", stringify!(MEMBlockHeapTracking))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMBlockHeapTracking>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMBlockHeapTracking))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeapTracking>())).__unk34 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapTracking),
            "::",
            stringify!(__unk34)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeapTracking>())).blocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapTracking),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<MEMBlockHeapTracking>())).blockCount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapTracking),
            "::",
            stringify!(blockCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMBlockHeapBlock {
    #[doc = "! First address of the data region this block has allocated"]
    pub start: *mut cty::c_void,
    #[doc = "! End address of the data region this block has allocated"]
    pub end: *mut cty::c_void,
    #[doc = "! TRUE if the block is free, FALSE if allocated"]
    pub isFree: BOOL,
    #[doc = "! Link to previous block, note that this is only set for allocated blocks"]
    pub prev: *mut MEMBlockHeapBlock,
    #[doc = "! Link to next block, always set"]
    pub next: *mut MEMBlockHeapBlock,
}
#[test]
fn bindgen_test_layout_MEMBlockHeapBlock() {
    assert_eq!(
        ::core::mem::size_of::<MEMBlockHeapBlock>(),
        20usize,
        concat!("Size of: ", stringify!(MEMBlockHeapBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMBlockHeapBlock>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMBlockHeapBlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeapBlock>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapBlock),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeapBlock>())).end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapBlock),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeapBlock>())).isFree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapBlock),
            "::",
            stringify!(isFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeapBlock>())).prev as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapBlock),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeapBlock>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeapBlock),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C, packed)]
pub struct MEMBlockHeap {
    pub header: MEMHeapHeader,
    #[doc = "! Default tracking heap, tracks only defaultBlock"]
    pub defaultTrack: MEMBlockHeapTracking,
    #[doc = "! Default block, used so we don't have an empty block list"]
    pub defaultBlock: MEMBlockHeapBlock,
    #[doc = "! First block in this heap"]
    pub firstBlock: *mut MEMBlockHeapBlock,
    #[doc = "! Last block in this heap"]
    pub lastBlock: *mut MEMBlockHeapBlock,
    #[doc = "! First free block"]
    pub firstFreeBlock: *mut MEMBlockHeapBlock,
    #[doc = "! Free block count"]
    pub numFreeBlocks: u32,
}
#[test]
fn bindgen_test_layout_MEMBlockHeap() {
    assert_eq!(
        ::core::mem::size_of::<MEMBlockHeap>(),
        116usize,
        concat!("Size of: ", stringify!(MEMBlockHeap))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMBlockHeap>(),
        1usize,
        concat!("Alignment of ", stringify!(MEMBlockHeap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeap>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeap),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeap>())).defaultTrack as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeap),
            "::",
            stringify!(defaultTrack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeap>())).defaultBlock as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeap),
            "::",
            stringify!(defaultBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeap>())).firstBlock as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeap),
            "::",
            stringify!(firstBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeap>())).lastBlock as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeap),
            "::",
            stringify!(lastBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeap>())).firstFreeBlock as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeap),
            "::",
            stringify!(firstFreeBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMBlockHeap>())).numFreeBlocks as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMBlockHeap),
            "::",
            stringify!(numFreeBlocks)
        )
    );
}
extern "C" {
    pub fn MEMInitBlockHeap(
        heap: *mut MEMBlockHeap,
        start: *mut cty::c_void,
        end: *mut cty::c_void,
        blocks: *mut MEMBlockHeapTracking,
        size: u32,
        flags: u32,
    ) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMDestroyBlockHeap(heap: MEMHeapHandle) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMAddBlockHeapTracking(
        heap: MEMHeapHandle,
        tracking: *mut MEMBlockHeapTracking,
        size: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn MEMAllocFromBlockHeapAt(
        heap: MEMHeapHandle,
        addr: *mut cty::c_void,
        size: u32,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMAllocFromBlockHeapEx(heap: MEMHeapHandle, size: u32, align: i32) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMFreeToBlockHeap(heap: MEMHeapHandle, data: *mut cty::c_void);
}
extern "C" {
    pub fn MEMGetAllocatableSizeForBlockHeapEx(heap: MEMHeapHandle, align: i32) -> u32;
}
extern "C" {
    pub fn MEMGetTrackingLeftInBlockHeap(heap: MEMHeapHandle) -> u32;
}
extern "C" {
    pub fn MEMGetTotalFreeSizeForBlockHeap(heap: MEMHeapHandle) -> u32;
}
pub type MEMAllocFromDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut cty::c_void>;
pub type MEMAllocFromDefaultHeapExFn =
    ::core::option::Option<unsafe extern "C" fn(size: u32, alignment: i32) -> *mut cty::c_void>;
pub type MEMFreeToDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(ptr: *mut cty::c_void)>;
extern "C" {
    pub static mut MEMAllocFromDefaultHeap: MEMAllocFromDefaultHeapFn;
}
extern "C" {
    pub static mut MEMAllocFromDefaultHeapEx: MEMAllocFromDefaultHeapExFn;
}
extern "C" {
    pub static mut MEMFreeToDefaultHeap: MEMFreeToDefaultHeapFn;
}
extern "C" {
    #[doc = " Default implementation of __preinit_user."]
    pub fn CoreInitDefaultHeap(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
}
extern "C" {
    #[doc = " Allows the user to completely customise the default heaps, this runs after"]
    #[doc = " the rpx code section has loaded but before the data section as the data"]
    #[doc = " sections are allocated from the default heap."]
    #[doc = ""]
    #[doc = " This is for a user to export from their .rpx file, it is not exported from"]
    #[doc = " coreinit.rpl"]
    pub fn __preinit_user(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
}
pub type MEMExpHeapBlockVisitor = ::core::option::Option<
    unsafe extern "C" fn(block: *mut cty::c_void, heap: MEMHeapHandle, context: *mut cty::c_void),
>;
pub mod MEMExpHeapMode {
    pub type Type = cty::c_uint;
    pub const MEM_EXP_HEAP_MODE_FIRST_FREE: Type = 0;
    pub const MEM_EXP_HEAP_MODE_NEAREST_SIZE: Type = 1;
}
pub mod MEMExpHeapDirection {
    pub type Type = cty::c_uint;
    pub const MEM_EXP_HEAP_DIR_FROM_TOP: Type = 0;
    pub const MEM_EXP_HEAP_DIR_FROM_BOTTOM: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMExpHeapBlock {
    pub attribs: u32,
    pub blockSize: u32,
    pub prev: *mut MEMExpHeapBlock,
    pub next: *mut MEMExpHeapBlock,
    pub tag: u16,
    pub __unk35: [cty::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_MEMExpHeapBlock() {
    assert_eq!(
        ::core::mem::size_of::<MEMExpHeapBlock>(),
        20usize,
        concat!("Size of: ", stringify!(MEMExpHeapBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMExpHeapBlock>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMExpHeapBlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlock>())).attribs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlock),
            "::",
            stringify!(attribs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlock>())).blockSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlock),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlock>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlock),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlock>())).next as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlock),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlock>())).tag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlock),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlock>())).__unk35 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlock),
            "::",
            stringify!(__unk35)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMExpHeapBlockList {
    pub head: *mut MEMExpHeapBlock,
    pub tail: *mut MEMExpHeapBlock,
}
#[test]
fn bindgen_test_layout_MEMExpHeapBlockList() {
    assert_eq!(
        ::core::mem::size_of::<MEMExpHeapBlockList>(),
        8usize,
        concat!("Size of: ", stringify!(MEMExpHeapBlockList))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMExpHeapBlockList>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMExpHeapBlockList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlockList>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlockList),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeapBlockList>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeapBlockList),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C, packed)]
pub struct MEMExpHeap {
    pub header: MEMHeapHeader,
    pub freeList: MEMExpHeapBlockList,
    pub usedList: MEMExpHeapBlockList,
    pub groupId: u16,
    pub attribs: u16,
}
#[test]
fn bindgen_test_layout_MEMExpHeap() {
    assert_eq!(
        ::core::mem::size_of::<MEMExpHeap>(),
        84usize,
        concat!("Size of: ", stringify!(MEMExpHeap))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMExpHeap>(),
        1usize,
        concat!("Alignment of ", stringify!(MEMExpHeap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeap>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeap),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeap>())).freeList as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeap),
            "::",
            stringify!(freeList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeap>())).usedList as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeap),
            "::",
            stringify!(usedList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeap>())).groupId as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeap),
            "::",
            stringify!(groupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMExpHeap>())).attribs as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMExpHeap),
            "::",
            stringify!(attribs)
        )
    );
}
extern "C" {
    pub fn MEMCreateExpHeapEx(heap: *mut cty::c_void, size: u32, flags: u16) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMDestroyExpHeap(heap: MEMHeapHandle) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMAllocFromExpHeapEx(
        heap: MEMHeapHandle,
        size: u32,
        alignment: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMFreeToExpHeap(heap: MEMHeapHandle, block: *mut cty::c_void);
}
extern "C" {
    pub fn MEMSetAllocModeForExpHeap(
        heap: MEMHeapHandle,
        mode: MEMExpHeapMode::Type,
    ) -> MEMExpHeapMode::Type;
}
extern "C" {
    pub fn MEMGetAllocModeForExpHeap(heap: MEMHeapHandle) -> MEMExpHeapMode::Type;
}
extern "C" {
    pub fn MEMAdjustExpHeap(heap: MEMHeapHandle) -> u32;
}
extern "C" {
    pub fn MEMResizeForMBlockExpHeap(
        heap: MEMHeapHandle,
        block: *mut cty::c_void,
        size: u32,
    ) -> u32;
}
extern "C" {
    pub fn MEMGetTotalFreeSizeForExpHeap(heap: MEMHeapHandle) -> u32;
}
extern "C" {
    pub fn MEMGetAllocatableSizeForExpHeapEx(heap: MEMHeapHandle, alignment: cty::c_int) -> u32;
}
extern "C" {
    pub fn MEMSetGroupIDForExpHeap(heap: MEMHeapHandle, id: u16) -> u16;
}
extern "C" {
    pub fn MEMGetGroupIDForExpHeap(heap: MEMHeapHandle) -> u16;
}
extern "C" {
    pub fn MEMGetSizeForMBlockExpHeap(block: *mut cty::c_void) -> u32;
}
extern "C" {
    pub fn MEMGetGroupIDForMBlockExpHeap(block: *mut cty::c_void) -> u16;
}
extern "C" {
    pub fn MEMGetAllocDirForMBlockExpHeap(block: *mut cty::c_void) -> MEMExpHeapDirection::Type;
}
extern "C" {
    pub fn MEMVisitAllocatedForExpHeap(
        heap: MEMHeapHandle,
        callback: MEMExpHeapBlockVisitor,
        context: *mut cty::c_void,
    );
}
pub mod MEMFrmHeapFreeMode {
    pub type Type = cty::c_uint;
    pub const MEM_FRM_HEAP_FREE_HEAD: Type = 1;
    pub const MEM_FRM_HEAP_FREE_TAIL: Type = 2;
    pub const MEM_FRM_HEAP_FREE_ALL: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMFrmHeapState {
    pub tag: u32,
    pub head: *mut cty::c_void,
    pub tail: *mut cty::c_void,
    pub previous: *mut MEMFrmHeapState,
}
#[test]
fn bindgen_test_layout_MEMFrmHeapState() {
    assert_eq!(
        ::core::mem::size_of::<MEMFrmHeapState>(),
        16usize,
        concat!("Size of: ", stringify!(MEMFrmHeapState))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMFrmHeapState>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMFrmHeapState))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeapState>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeapState),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeapState>())).head as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeapState),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeapState>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeapState),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeapState>())).previous as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeapState),
            "::",
            stringify!(previous)
        )
    );
}
#[repr(C, packed)]
pub struct MEMFrmHeap {
    pub header: MEMHeapHeader,
    pub head: *mut cty::c_void,
    pub tail: *mut cty::c_void,
    pub previousState: *mut MEMFrmHeapState,
}
#[test]
fn bindgen_test_layout_MEMFrmHeap() {
    assert_eq!(
        ::core::mem::size_of::<MEMFrmHeap>(),
        76usize,
        concat!("Size of: ", stringify!(MEMFrmHeap))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMFrmHeap>(),
        1usize,
        concat!("Alignment of ", stringify!(MEMFrmHeap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeap>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeap),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeap>())).head as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeap),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeap>())).tail as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeap),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMFrmHeap>())).previousState as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMFrmHeap),
            "::",
            stringify!(previousState)
        )
    );
}
extern "C" {
    pub fn MEMCreateFrmHeapEx(heap: *mut cty::c_void, size: u32, flags: u32) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMDestroyFrmHeap(heap: MEMHeapHandle) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMAllocFromFrmHeapEx(
        heap: MEMHeapHandle,
        size: u32,
        alignment: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMFreeToFrmHeap(heap: MEMHeapHandle, mode: MEMFrmHeapFreeMode::Type);
}
extern "C" {
    pub fn MEMRecordStateForFrmHeap(heap: MEMHeapHandle, tag: u32) -> BOOL;
}
extern "C" {
    pub fn MEMFreeByStateToFrmHeap(heap: MEMHeapHandle, tag: u32) -> BOOL;
}
extern "C" {
    pub fn MEMAdjustFrmHeap(heap: MEMHeapHandle) -> u32;
}
extern "C" {
    pub fn MEMResizeForMBlockFrmHeap(heap: MEMHeapHandle, addr: u32, size: u32) -> u32;
}
extern "C" {
    pub fn MEMGetAllocatableSizeForFrmHeapEx(heap: MEMHeapHandle, alignment: cty::c_int) -> u32;
}
pub mod OSMemoryType {
    pub type Type = cty::c_uint;
    pub const OS_MEM1: Type = 1;
    pub const OS_MEM2: Type = 2;
}
pub mod OSSharedDataType {
    pub type Type = cty::c_uint;
    pub const OS_SHAREDDATATYPE_FONT_CHINESE: Type = 0;
    pub const OS_SHAREDDATATYPE_FONT_KOREAN: Type = 1;
    pub const OS_SHAREDDATATYPE_FONT_STANDARD: Type = 2;
    pub const OS_SHAREDDATATYPE_FONT_TAIWANESE: Type = 3;
    pub const OS_SHAREDDATATYPE_FONT_MAX: Type = 4;
}
extern "C" {
    pub fn OSGetSharedData(
        type_: OSSharedDataType::Type,
        unk_r4: u32,
        outPtr: *mut *mut cty::c_void,
        outSize: *mut u32,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Moves chunks of memory around, similarly to memmove. Overlapping source and"]
    #[doc = " destination regions are supported."]
    #[doc = ""]
    #[doc = " \\param dst"]
    #[doc = " The destination address for the move."]
    #[doc = ""]
    #[doc = " \\param src"]
    #[doc = " The source address for the move."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the data to be moved, in bytes."]
    #[doc = ""]
    #[doc = " \\param flush"]
    #[doc = " Whether to flush the data caches for the source and destination."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " dst is returned."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This function makes use of the cache to speed up the copy, so a flush is"]
    #[doc = " recommended."]
    pub fn OSBlockMove(
        dst: *mut cty::c_void,
        src: *const cty::c_void,
        size: u32,
        flush: BOOL,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Fills a chunk of memory with the given value, like memset."]
    #[doc = ""]
    #[doc = " \\param dst"]
    #[doc = " Pointer to the memory to fill."]
    #[doc = ""]
    #[doc = " \\param val"]
    #[doc = " Byte value to be set."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " Number of bytes to be set to val."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " dst is returned."]
    pub fn OSBlockSet(dst: *mut cty::c_void, val: u8, size: u32) -> *mut cty::c_void;
}
extern "C" {
    pub fn OSAllocFromSystem(size: u32, align: cty::c_int) -> *mut cty::c_void;
}
extern "C" {
    pub fn OSFreeToSystem(ptr: *mut cty::c_void);
}
extern "C" {
    #[doc = " Gets the location and size of the foreground bucket memory area."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This function may not account for the system reserved portion of the"]
    #[doc = " foreground bucket. Consider using OSGetForegroundBucketFreeArea() instead."]
    #[doc = ""]
    #[doc = " \\param outAddr"]
    #[doc = " Pointer to write the foreground bucket's address to."]
    #[doc = ""]
    #[doc = " \\param outSize"]
    #[doc = " Pointer to write the foreground bucket's size to."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\c true on success."]
    pub fn OSGetForegroundBucket(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
}
extern "C" {
    #[doc = " Gets the location and size of the application-usable portion of the"]
    #[doc = " foreground bucket area."]
    #[doc = ""]
    #[doc = " \\param outAddr"]
    #[doc = " Pointer to write the bucket area's address to."]
    #[doc = ""]
    #[doc = " \\param outSize"]
    #[doc = " Pointer to write the bucket area's size to."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\c true on success."]
    pub fn OSGetForegroundBucketFreeArea(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
}
extern "C" {
    #[doc = " Gets the location and size of available memory areas."]
    #[doc = ""]
    #[doc = " \\param type"]
    #[doc = " Type of memory to get information about. See #OSMemoryType."]
    #[doc = ""]
    #[doc = " \\param outAddr"]
    #[doc = " Pointer to write the area's address to."]
    #[doc = ""]
    #[doc = " \\param outSize"]
    #[doc = " Pointer to write the area's size to."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " 0 on success, -1 otherwise."]
    pub fn OSGetMemBound(
        type_: OSMemoryType::Type,
        outAddr: *mut u32,
        outSize: *mut u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Zeros the memory for a given proccessID."]
    #[doc = " Works only inside the ROOT process."]
    pub fn __OSZeroProcessMemory(proccesID: u32);
}
pub mod OSMemoryMapMode {
    pub type Type = cty::c_uint;
    pub const OS_MAP_MEMORY_INVALID: Type = 0;
    pub const OS_MAP_MEMORY_READ_ONLY: Type = 1;
    pub const OS_MAP_MEMORY_READ_WRITE: Type = 2;
    pub const OS_MAP_MEMORY_FREE: Type = 3;
    pub const OS_MAP_MEMORY_ALLOCATED: Type = 4;
}
extern "C" {
    pub fn OSEffectiveToPhysical(virtualAddress: u32) -> u32;
}
extern "C" {
    pub fn OSIsAddressValid(virtualAddress: u32) -> BOOL;
}
extern "C" {
    pub fn __OSValidateAddressSpaceRange(arg1: cty::c_int, virtualAddress: u32, size: u32) -> BOOL;
}
extern "C" {
    #[doc = " Allocates virtual address range for later mapping."]
    #[doc = ""]
    #[doc = " \\param virtualAddress"]
    #[doc = " Requested start address for the range. If there is no preference, NULL can be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " Size of address range to allocate."]
    #[doc = ""]
    #[doc = " \\param align"]
    #[doc = " Alignment of address range to allocate."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The starting address of the newly allocated range, or NULL on failure."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - OSFreeVirtAddr()"]
    #[doc = " - OSMapMemory()"]
    pub fn OSAllocVirtAddr(virtualAddress: u32, size: u32, align: u32) -> u32;
}
extern "C" {
    #[doc = " Frees a previously allocated virtual address range back to the system."]
    #[doc = ""]
    #[doc = " \\param virtualAddress"]
    #[doc = " The start of the virtual address range to free."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The size of the virtual address range to free."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\c true on success."]
    pub fn OSFreeVirtAddr(virtualAddress: u32, size: u32) -> BOOL;
}
extern "C" {
    #[doc = " Determines the status of the given virtual memory address - mapped read-write"]
    #[doc = " or read-only, free, allocated or invalid."]
    #[doc = ""]
    #[doc = " \\param virtualAddress"]
    #[doc = " The virtual address to query."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The status of the memory address - see #OSMemoryMapMode."]
    pub fn OSQueryVirtAddr(virtualAddress: u32) -> OSMemoryMapMode::Type;
}
extern "C" {
    #[doc = " Maps a physical address to a virtual address, with a given size and set of"]
    #[doc = " permissions."]
    #[doc = ""]
    #[doc = " \\param virtualAddress"]
    #[doc = " The target virtual address for the mapping."]
    #[doc = ""]
    #[doc = " \\param physicalAddress"]
    #[doc = " Physical address of the memory to back the mapping."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " Size, in bytes, of the desired mapping. Likely has an alignment requirement."]
    #[doc = ""]
    #[doc = " \\param mode"]
    #[doc = " Permissions to map the memory with - see #OSMemoryMapMode."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\c true on success."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - OSAllocVirtAddr()"]
    #[doc = " - OSUnmapMemory()"]
    pub fn OSMapMemory(
        virtualAddress: u32,
        physicalAddress: u32,
        size: u32,
        mode: OSMemoryMapMode::Type,
    ) -> BOOL;
}
extern "C" {
    #[doc = " Unmaps previously mapped memory."]
    #[doc = ""]
    #[doc = " \\param virtualAddress"]
    #[doc = " Starting address of the area to unmap."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " Size of the memory area to unmap."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\c true on success."]
    pub fn OSUnmapMemory(virtualAddress: u32, size: u32) -> BOOL;
}
extern "C" {
    #[doc = " Gets the range of virtual addresses available for mapping."]
    #[doc = ""]
    #[doc = " \\param outVirtualAddress"]
    #[doc = " Pointer to write the starting address of the memory area to."]
    #[doc = ""]
    #[doc = " \\param outSize"]
    #[doc = " Pointer to write the size of the memory area to."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - OSMapMemory()"]
    pub fn OSGetMapVirtAddrRange(outVirtualAddress: *mut u32, outSize: *mut u32);
}
extern "C" {
    #[doc = " Gets the range of available physical memory (not reserved for app code or"]
    #[doc = " data)."]
    #[doc = ""]
    #[doc = " \\param outPhysicalAddress"]
    #[doc = " Pointer to write the starting physical address of the memory area to."]
    #[doc = ""]
    #[doc = " \\param outSize"]
    #[doc = " Pointer to write the size of the memory area to."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " Is memory returned by this function actually safe to map and use? couldn't"]
    #[doc = " get a straight answer from decaf-emu's kernel_memory.cpp..."]
    #[doc = " \\endif"]
    pub fn OSGetAvailPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
}
extern "C" {
    #[doc = " Gets the range of physical memory used for the application's data."]
    #[doc = ""]
    #[doc = " \\param outPhysicalAddress"]
    #[doc = " Pointer to write the starting physical address of the memory area to."]
    #[doc = ""]
    #[doc = " \\param outSize"]
    #[doc = " Pointer to write the size of the memory area to."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " does this include the main heap?"]
    #[doc = " \\endif"]
    pub fn OSGetDataPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMUnitHeapFreeBlock {
    pub next: *mut MEMUnitHeapFreeBlock,
}
#[test]
fn bindgen_test_layout_MEMUnitHeapFreeBlock() {
    assert_eq!(
        ::core::mem::size_of::<MEMUnitHeapFreeBlock>(),
        4usize,
        concat!("Size of: ", stringify!(MEMUnitHeapFreeBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMUnitHeapFreeBlock>(),
        4usize,
        concat!("Alignment of ", stringify!(MEMUnitHeapFreeBlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMUnitHeapFreeBlock>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMUnitHeapFreeBlock),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C, packed)]
pub struct MEMUnitHeap {
    pub header: MEMHeapHeader,
    pub freeBlocks: *mut MEMUnitHeapFreeBlock,
    pub blockSize: u32,
}
#[test]
fn bindgen_test_layout_MEMUnitHeap() {
    assert_eq!(
        ::core::mem::size_of::<MEMUnitHeap>(),
        72usize,
        concat!("Size of: ", stringify!(MEMUnitHeap))
    );
    assert_eq!(
        ::core::mem::align_of::<MEMUnitHeap>(),
        1usize,
        concat!("Alignment of ", stringify!(MEMUnitHeap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMUnitHeap>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMUnitHeap),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMUnitHeap>())).freeBlocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMUnitHeap),
            "::",
            stringify!(freeBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MEMUnitHeap>())).blockSize as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MEMUnitHeap),
            "::",
            stringify!(blockSize)
        )
    );
}
extern "C" {
    pub fn MEMCreateUnitHeapEx(
        heap: *mut cty::c_void,
        size: u32,
        blockSize: u32,
        alignment: i32,
        flags: u16,
    ) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMDestroyUnitHeap(heap: MEMHeapHandle) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMAllocFromUnitHeap(heap: MEMHeapHandle) -> *mut cty::c_void;
}
extern "C" {
    pub fn MEMFreeToUnitHeap(heap: MEMHeapHandle, block: *mut cty::c_void);
}
extern "C" {
    pub fn MEMiDumpUnitHeap(heap: MEMHeapHandle);
}
extern "C" {
    pub fn MEMCountFreeBlockForUnitHeap(heap: MEMHeapHandle) -> u32;
}
extern "C" {
    pub fn MEMCalcHeapSizeForUnitHeap(blockSize: u32, count: u32, alignment: i32) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexLink {
    pub next: *mut OSMutex,
    pub prev: *mut OSMutex,
}
#[test]
fn bindgen_test_layout_OSMutexLink() {
    assert_eq!(
        ::core::mem::size_of::<OSMutexLink>(),
        8usize,
        concat!("Size of: ", stringify!(OSMutexLink))
    );
    assert_eq!(
        ::core::mem::align_of::<OSMutexLink>(),
        4usize,
        concat!("Alignment of ", stringify!(OSMutexLink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutexLink>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutexLink),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutexLink>())).prev as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutexLink),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutex {
    #[doc = "! Should always be set to the value OS_MUTEX_TAG."]
    pub tag: u32,
    #[doc = "! Name set by OSInitMutexEx."]
    pub name: *const cty::c_char,
    pub __unk36: [cty::c_char; 4usize],
    #[doc = "! Queue of threads waiting for this mutex to unlock."]
    pub queue: OSThreadQueue,
    #[doc = "! Current owner of mutex."]
    pub owner: *mut OSThread,
    #[doc = "! Current recursion lock count of mutex."]
    pub count: i32,
    #[doc = "! Link used inside OSThread's mutex queue."]
    pub link: OSMutexLink,
}
#[test]
fn bindgen_test_layout_OSMutex() {
    assert_eq!(
        ::core::mem::size_of::<OSMutex>(),
        44usize,
        concat!("Size of: ", stringify!(OSMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<OSMutex>(),
        4usize,
        concat!("Alignment of ", stringify!(OSMutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutex>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutex),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutex>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutex),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutex>())).__unk36 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutex),
            "::",
            stringify!(__unk36)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutex>())).queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutex),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutex>())).owner as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutex>())).count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutex),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSMutex>())).link as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OSMutex),
            "::",
            stringify!(link)
        )
    );
}
extern "C" {
    #[doc = " Initialise a mutex structure."]
    pub fn OSInitMutex(mutex: *mut OSMutex);
}
extern "C" {
    #[doc = " Initialise a mutex structure with a name."]
    pub fn OSInitMutexEx(mutex: *mut OSMutex, name: *const cty::c_char);
}
extern "C" {
    #[doc = " Lock the mutex."]
    #[doc = ""]
    #[doc = " If no one owns the mutex, set current thread as owner."]
    #[doc = ""]
    #[doc = " If the lock is owned by the current thread, increase the recursion count."]
    #[doc = ""]
    #[doc = " If the lock is owned by another thread, the current thread will sleep until"]
    #[doc = " the owner has unlocked this mutex."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"http://en.cppreference.com/w/cpp/thread/recursive_mutex/lock\">std::recursive_mutex::lock</a>."]
    pub fn OSLockMutex(mutex: *mut OSMutex);
}
extern "C" {
    #[doc = " Try to lock a mutex."]
    #[doc = ""]
    #[doc = " If no one owns the mutex, set current thread as owner."]
    #[doc = ""]
    #[doc = " If the lock is owned by the current thread, increase the recursion count."]
    #[doc = ""]
    #[doc = " If the lock is owned by another thread, do not block, return FALSE."]
    #[doc = ""]
    #[doc = " \\return TRUE if the mutex is locked, FALSE if the mutex is owned by another thread."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"http://en.cppreference.com/w/cpp/thread/recursive_mutex/try_lock\">std::recursive_mutex::try_lock</a>."]
    pub fn OSTryLockMutex(mutex: *mut OSMutex) -> BOOL;
}
extern "C" {
    #[doc = " Unlocks the mutex."]
    #[doc = ""]
    #[doc = " Will decrease the recursion count, will only unlock the mutex when the"]
    #[doc = " recursion count reaches 0."]
    #[doc = ""]
    #[doc = " If any other threads are waiting to lock the mutex they will be woken."]
    #[doc = ""]
    #[doc = " Similar to <a href=\"http://en.cppreference.com/w/cpp/thread/recursive_mutex/unlock\">std::recursive_mutex::unlock</a>."]
    pub fn OSUnlockMutex(mutex: *mut OSMutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRendezvous {
    pub core: [u32; 3usize],
    pub __unk37: [cty::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_OSRendezvous() {
    assert_eq!(
        ::core::mem::size_of::<OSRendezvous>(),
        16usize,
        concat!("Size of: ", stringify!(OSRendezvous))
    );
    assert_eq!(
        ::core::mem::align_of::<OSRendezvous>(),
        4usize,
        concat!("Alignment of ", stringify!(OSRendezvous))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSRendezvous>())).core as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRendezvous),
            "::",
            stringify!(core)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSRendezvous>())).__unk37 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRendezvous),
            "::",
            stringify!(__unk37)
        )
    );
}
extern "C" {
    pub fn OSInitRendezvous(rendezvous: *mut OSRendezvous);
}
extern "C" {
    pub fn OSWaitRendezvous(rendezvous: *mut OSRendezvous, coreMask: u32) -> BOOL;
}
extern "C" {
    pub fn OSWaitRendezvousWithTimeout(
        rendezvous: *mut OSRendezvous,
        coreMask: u32,
        timeout: OSTime,
    ) -> BOOL;
}
pub mod OSScreenID {
    #[doc = "! Defines the ID of a display usable with OSScreen."]
    pub type Type = cty::c_uint;
    #[doc = "! Represents the TV connected to the system."]
    pub const SCREEN_TV: Type = 0;
    #[doc = "! Represents the screen in the DRC (gamepad)."]
    pub const SCREEN_DRC: Type = 1;
}
extern "C" {
    #[doc = " Initialises the OSScreen library for use. This function must be called before"]
    #[doc = " using any other OSScreen functions."]
    #[doc = ""]
    #[doc = " \\sa <ul>"]
    #[doc = " <li>\\link OSScreenSetBufferEx \\endlink</li>"]
    #[doc = " <li>\\link OSScreenEnableEx \\endlink</li>"]
    #[doc = " <li>\\link OSScreenShutdown \\endlink</li>"]
    #[doc = " </ul>"]
    pub fn OSScreenInit();
}
extern "C" {
    #[doc = " Cleans up and shuts down the OSScreen library."]
    #[doc = ""]
    #[doc = " \\sa <ul>"]
    #[doc = " <li>\\link OSScreenEnableEx \\endlink</li>"]
    #[doc = " </ul>"]
    pub fn OSScreenShutdown();
}
extern "C" {
    #[doc = " Gets the amount of memory required to fit both buffers of a given screen."]
    #[doc = ""]
    #[doc = " \\param screen"]
    #[doc = " The ID of the screen to be sized."]
    #[doc = ""]
    #[doc = " \\sa <ul>"]
    #[doc = " <li>\\link OSScreenSetBufferEx \\endlink</li>"]
    #[doc = " </ul>"]
    pub fn OSScreenGetBufferSizeEx(screen: OSScreenID::Type) -> u32;
}
extern "C" {
    #[doc = " Sets the memory location for both buffers of a given screen. This location"]
    #[doc = " must be of the size prescribed by \\link OSScreenGetBufferSizeEx \\endlink and"]
    #[doc = " at an address aligned to 0x100 bytes."]
    #[doc = ""]
    #[doc = " \\param screen"]
    #[doc = " The ID of the screen whose memory location should be changed."]
    #[doc = ""]
    #[doc = " \\param addr"]
    #[doc = " Pointer to the memory to use. This area must be 0x100 aligned, and of the"]
    #[doc = " size given by \\link OSScreenGetBufferSizeEx \\endlink."]
    #[doc = ""]
    #[doc = " \\sa <ul>"]
    #[doc = " <li>\\link OSScreenGetBufferSizeEx \\endlink</li>"]
    #[doc = " </ul>"]
    pub fn OSScreenSetBufferEx(screen: OSScreenID::Type, addr: *mut cty::c_void);
}
extern "C" {
    #[doc = " Clear the work buffer of the given screen by setting all of its pixels to"]
    #[doc = " a given colour."]
    #[doc = ""]
    #[doc = " \\param screen"]
    #[doc = " The ID of the screen to clear. Only the work buffer will be cleared."]
    #[doc = ""]
    #[doc = " \\param colour"]
    #[doc = " The colour to use, in big-endian RGBX8 format - 0xRRGGBBXX, where X bits are"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Since this function only affects the <em>work buffer</em>, its effect will"]
    #[doc = " not appear on screen immediately. See \\link OSScreenFlipBuffersEx \\endlink."]
    #[doc = ""]
    #[doc = " \\sa <ul>"]
    #[doc = " <li>\\link OSScreenPutFontEx \\endlink</li>"]
    #[doc = " <li>\\link OSScreenPutPixelEx \\endlink</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " <!-- TODO: Are the XX bits really ignored? I'm basing this off a vague memory"]
    #[doc = " of setting them to 00 and nothing changing... Check this. -->"]
    pub fn OSScreenClearBufferEx(screen: OSScreenID::Type, colour: u32);
}
extern "C" {
    #[doc = " Swap the buffers of the given screen. The work buffer will become the visible"]
    #[doc = " buffer and will start being shown on-screen, while the visible buffer becomes"]
    #[doc = " the new work buffer. This operation is known as \"flipping\" the buffers."]
    #[doc = ""]
    #[doc = " You must call this function once drawing is complete, otherwise draws will"]
    #[doc = " not appear on-screen."]
    #[doc = ""]
    #[doc = " \\param screen"]
    #[doc = " The ID of the screen to flip."]
    pub fn OSScreenFlipBuffersEx(screen: OSScreenID::Type);
}
extern "C" {
    #[doc = " Draws text at the given position. The text will be drawn to the work"]
    #[doc = " buffer with a built-in monospace font, coloured white, and anti-aliased."]
    #[doc = " The position coordinates are in <em>characters</em>, not pixels."]
    #[doc = ""]
    #[doc = " \\param screen"]
    #[doc = " The ID of the screen to draw to. Only the work buffer will be affected."]
    #[doc = ""]
    #[doc = " \\param row"]
    #[doc = " The row, in characters, to place the text in. 0 corresponds to the top of"]
    #[doc = " the screen."]
    #[doc = ""]
    #[doc = " \\param column"]
    #[doc = " The column, in characters, to place the text at. 0 corresponds to the left of"]
    #[doc = " the screen."]
    #[doc = ""]
    #[doc = " \\param buffer"]
    #[doc = " Pointer to the string of text to draw. Null-terminated."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Since this function only affects the <em>work buffer</em>, its effect will"]
    #[doc = " not appear on screen immediately. See \\link OSScreenFlipBuffersEx \\endlink."]
    #[doc = ""]
    #[doc = " \\sa <ul>"]
    #[doc = " <li>\\link OSScreenPutPixelEx \\endlink</li>"]
    #[doc = " <li>\\link OSScreenClearBufferEx \\endlink</li>"]
    #[doc = " </ul>"]
    pub fn OSScreenPutFontEx(
        screen: OSScreenID::Type,
        row: u32,
        column: u32,
        buffer: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " Draws a single pixel at the given position. The pixel, a 32-bit RGBX"]
    #[doc = " colour, will be placed in the work buffer at the coordinates given."]
    #[doc = ""]
    #[doc = " \\param screen"]
    #[doc = " The ID of the screen to place the pixel in."]
    #[doc = ""]
    #[doc = " \\param x"]
    #[doc = " The x-coordinate, in pixels, to draw the pixel at."]
    #[doc = ""]
    #[doc = " \\param y"]
    #[doc = " The y-coordinate, in pixels, to draw the pixel at."]
    #[doc = ""]
    #[doc = " \\param colour"]
    #[doc = " The desired colour of the pixel to draw, in RGBX32 colour (0xRRGGBBXX, where"]
    #[doc = " the XX value is ignored)."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Since this function only affects the <em>work buffer</em>, its effect will"]
    #[doc = " not appear on screen immediately. See \\link OSScreenFlipBuffersEx \\endlink."]
    #[doc = ""]
    #[doc = " \\sa <ul>"]
    #[doc = " <li>\\link OSScreenPutFontEx \\endlink</li>"]
    #[doc = " <li>\\link OSScreenClearBufferEx \\endlink</li>"]
    #[doc = " </ul>"]
    pub fn OSScreenPutPixelEx(screen: OSScreenID::Type, x: u32, y: u32, colour: u32);
}
extern "C" {
    #[doc = " Enables or disables a given screen. If a screen is disabled, it shows black."]
    #[doc = ""]
    #[doc = " \\param screen"]
    #[doc = " The ID of the screen to enable or disable."]
    #[doc = ""]
    #[doc = " \\param enable"]
    #[doc = " \\c true if the screen should be enabled, otherwise false."]
    pub fn OSScreenEnableEx(screen: OSScreenID::Type, enable: BOOL);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSSemaphore {
    #[doc = "! Should always be set to the value OS_SEMAPHORE_TAG."]
    pub tag: u32,
    #[doc = "! Name set by OSInitMutexEx."]
    pub name: *const cty::c_char,
    pub __unk38: [cty::c_char; 4usize],
    #[doc = "! Current count of semaphore"]
    pub count: i32,
    #[doc = "! Queue of threads waiting on semaphore object with OSWaitSemaphore"]
    pub queue: OSThreadQueue,
}
#[test]
fn bindgen_test_layout_OSSemaphore() {
    assert_eq!(
        ::core::mem::size_of::<OSSemaphore>(),
        32usize,
        concat!("Size of: ", stringify!(OSSemaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<OSSemaphore>(),
        4usize,
        concat!("Alignment of ", stringify!(OSSemaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSemaphore>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSemaphore),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSemaphore>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSemaphore),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSemaphore>())).__unk38 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSemaphore),
            "::",
            stringify!(__unk38)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSemaphore>())).count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSemaphore),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OSSemaphore>())).queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSSemaphore),
            "::",
            stringify!(queue)
        )
    );
}
extern "C" {
    #[doc = " Initialise semaphore object with count."]
    pub fn OSInitSemaphore(semaphore: *mut OSSemaphore, count: i32);
}
extern "C" {
    #[doc = " Initialise semaphore object with count and name."]
    pub fn OSInitSemaphoreEx(semaphore: *mut OSSemaphore, count: i32, name: *const cty::c_char);
}
extern "C" {
    #[doc = " Get the current semaphore count."]
    pub fn OSGetSemaphoreCount(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    #[doc = " Increase the semaphore value."]
    #[doc = ""]
    #[doc = " If any threads are waiting for semaphore, they are woken."]
    pub fn OSSignalSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    #[doc = " Decrease the semaphore value."]
    #[doc = ""]
    #[doc = " If the value is less than or equal to zero the current thread will be put to"]
    #[doc = " sleep until the count is above zero and it can decrement it safely."]
    pub fn OSWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    #[doc = " Try to decrease the semaphore value."]
    #[doc = ""]
    #[doc = " If the value is greater than zero then it will be decremented, else the function"]
    #[doc = " will return immediately with a value <= 0 indicating a failure."]
    #[doc = ""]
    #[doc = " \\return Returns previous semaphore count, before the decrement in this function."]
    #[doc = "         If the value is >0 then it means the call was succesful."]
    pub fn OSTryWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
pub type MPTaskFunc = ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32) -> u32>;
pub mod MPTaskState {
    pub type Type = cty::c_uint;
    pub const MP_TASK_STATE_INITIALISED: Type = 1;
    pub const MP_TASK_STATE_READY: Type = 2;
    pub const MP_TASK_STATE_RUNNING: Type = 4;
    pub const MP_TASK_STATE_FINISHED: Type = 8;
}
pub mod MPTaskQueueState {
    pub type Type = cty::c_uint;
    pub const MP_TASK_QUEUE_STATE_INITIALISED: Type = 1;
    pub const MP_TASK_QUEUE_STATE_READY: Type = 2;
    pub const MP_TASK_QUEUE_STATE_STOPPING: Type = 4;
    pub const MP_TASK_QUEUE_STATE_STOPPED: Type = 8;
    pub const MP_TASK_QUEUE_STATE_FINISHED: Type = 16;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskInfo {
    pub state: MPTaskState::Type,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
}
#[test]
fn bindgen_test_layout_MPTaskInfo() {
    assert_eq!(
        ::core::mem::size_of::<MPTaskInfo>(),
        20usize,
        concat!("Size of: ", stringify!(MPTaskInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MPTaskInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(MPTaskInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskInfo>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskInfo),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskInfo>())).result as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskInfo),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskInfo>())).coreID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskInfo),
            "::",
            stringify!(coreID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskInfo>())).duration as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskInfo),
            "::",
            stringify!(duration)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTask {
    pub self_: *mut MPTask,
    pub queue: *mut MPTaskQueue,
    pub state: MPTaskState::Type,
    pub func: MPTaskFunc,
    pub userArg1: u32,
    pub userArg2: u32,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
    pub userData: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_MPTask() {
    assert_eq!(
        ::core::mem::size_of::<MPTask>(),
        44usize,
        concat!("Size of: ", stringify!(MPTask))
    );
    assert_eq!(
        ::core::mem::align_of::<MPTask>(),
        1usize,
        concat!("Alignment of ", stringify!(MPTask))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).self_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).queue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).func as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).userArg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(userArg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).userArg2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(userArg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).result as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).coreID as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(coreID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).duration as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTask>())).userData as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTask),
            "::",
            stringify!(userData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskQueueInfo {
    pub state: MPTaskQueueState::Type,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub tasksFinished: u32,
}
#[test]
fn bindgen_test_layout_MPTaskQueueInfo() {
    assert_eq!(
        ::core::mem::size_of::<MPTaskQueueInfo>(),
        20usize,
        concat!("Size of: ", stringify!(MPTaskQueueInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MPTaskQueueInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(MPTaskQueueInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueueInfo>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueueInfo),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueueInfo>())).tasks as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueueInfo),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueueInfo>())).tasksReady as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueueInfo),
            "::",
            stringify!(tasksReady)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueueInfo>())).tasksRunning as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueueInfo),
            "::",
            stringify!(tasksRunning)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueueInfo>())).tasksFinished as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueueInfo),
            "::",
            stringify!(tasksFinished)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
pub struct MPTaskQueue {
    pub self_: *mut MPTaskQueue,
    pub state: MPTaskQueueState::Type,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub __unk39: [cty::c_char; 4usize],
    pub tasksFinished: u32,
    pub __unk40: [cty::c_char; 8usize],
    pub queueIndex: u32,
    pub __unk41: [cty::c_char; 8usize],
    pub queueSize: u32,
    pub __unk42: [cty::c_char; 4usize],
    pub queue: *mut *mut MPTask,
    pub queueMaxSize: u32,
    pub lock: OSSpinLock,
}
#[test]
fn bindgen_test_layout_MPTaskQueue() {
    assert_eq!(
        ::core::mem::size_of::<MPTaskQueue>(),
        80usize,
        concat!("Size of: ", stringify!(MPTaskQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<MPTaskQueue>(),
        16usize,
        concat!("Alignment of ", stringify!(MPTaskQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).self_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).tasks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).tasksReady as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(tasksReady)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).tasksRunning as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(tasksRunning)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).__unk39 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(__unk39)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).tasksFinished as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(tasksFinished)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).__unk40 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(__unk40)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).queueIndex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(queueIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).__unk41 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(__unk41)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).queueSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(queueSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).__unk42 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(__unk42)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).queue as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).queueMaxSize as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(queueMaxSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MPTaskQueue>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MPTaskQueue),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    pub fn MPInitTaskQ(queue: *mut MPTaskQueue, queueBuffer: *mut *mut MPTask, queueBufferLen: u32);
}
extern "C" {
    pub fn MPTermTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskQInfo(queue: *mut MPTaskQueue, info: *mut MPTaskQueueInfo) -> BOOL;
}
extern "C" {
    pub fn MPStartTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPStopTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPResetTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPEnqueTask(queue: *mut MPTaskQueue, task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn MPDequeTask(queue: *mut MPTaskQueue) -> *mut MPTask;
}
extern "C" {
    pub fn MPDequeTasks(
        queue: *mut MPTaskQueue,
        queueBuffer: *mut *mut MPTask,
        queueBufferLen: u32,
    ) -> u32;
}
extern "C" {
    pub fn MPWaitTaskQ(queue: *mut MPTaskQueue, mask: MPTaskQueueState::Type) -> BOOL;
}
extern "C" {
    pub fn MPWaitTaskQWithTimeout(
        queue: *mut MPTaskQueue,
        wmask: MPTaskQueueState::Type,
        timeout: OSTime,
    ) -> BOOL;
}
extern "C" {
    pub fn MPPrintTaskQStats(queue: *mut MPTaskQueue, unk: u32) -> BOOL;
}
extern "C" {
    pub fn MPInitTask(task: *mut MPTask, func: MPTaskFunc, userArg1: u32, userArg2: u32);
}
extern "C" {
    pub fn MPTermTask(task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskInfo(task: *mut MPTask, info: *mut MPTaskInfo) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskUserData(task: *mut MPTask) -> *mut cty::c_void;
}
extern "C" {
    pub fn MPSetTaskUserData(task: *mut MPTask, userData: *mut cty::c_void);
}
extern "C" {
    pub fn MPRunTasksFromTaskQ(queue: *mut MPTaskQueue, count: u32) -> BOOL;
}
extern "C" {
    pub fn MPRunTask(task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn OSGetTitleID() -> u64;
}
pub type UCError = i32;
pub mod UCCommand {
    pub type Type = cty::c_uint;
    pub const UC_CMD_READ_SYS_CONFIG: Type = 48;
    pub const UC_CMD_WRITE_SYS_CONFIG: Type = 49;
    pub const UC_CMD_DELETE_SYS_CONFIG: Type = 50;
    pub const UC_CMD_QUERY_SYS_CONFIG: Type = 51;
    pub const UC_CMD_LIST_SYS_CONFIG: Type = 52;
}
pub mod UCDataType {
    pub type Type = cty::c_uint;
    pub const UC_DATATYPE_UNDEFINED: Type = 0;
    pub const UC_DATATYPE_UNSIGNED_BYTE: Type = 1;
    pub const UC_DATATYPE_UNSIGNED_SHORT: Type = 2;
    pub const UC_DATATYPE_UNSIGNED_INT: Type = 3;
    pub const UC_DATATYPE_SIGNED_INT: Type = 4;
    pub const UC_DATATYPE_FLOAT: Type = 5;
    pub const UC_DATATYPE_STRING: Type = 6;
    pub const UC_DATATYPE_HEXBINARY: Type = 7;
    pub const UC_DATATYPE_COMPLEX: Type = 8;
    pub const UC_DATATYPE_INVALID: Type = 255;
}
pub mod UCErrors {
    pub type Type = cty::c_int;
    pub const UC_ERROR_OK: Type = 0;
    pub const UC_ERROR_ERROR: Type = -1;
    pub const UC_ERROR_OTHER: Type = -2097153;
    pub const UC_ERROR_SYSTEM: Type = -2097154;
    pub const UC_ERROR_ALLOC: Type = -2097155;
    pub const UC_ERROR_OPCODE: Type = -2097156;
    pub const UC_ERROR_INVALID_PARAM: Type = -2097157;
    pub const UC_ERROR_INVALID_TYPE: Type = -2097158;
    pub const UC_ERROR_UNSUPPORTED: Type = -2097159;
    pub const UC_ERROR_NON_LEAF_NODE: Type = -2097160;
    pub const UC_ERROR_KEY_NOT_FOUND: Type = -2097161;
    pub const UC_ERROR_MODIFY: Type = -2097162;
    pub const UC_ERROR_STRING_TOO_LONG: Type = -2097163;
    pub const UC_ERROR_ROOT_KEYS_DIFFER: Type = -2097164;
    pub const UC_ERROR_INVALID_LOCATION: Type = -2097165;
    pub const UC_ERROR_BAD_COMMENT: Type = -2097166;
    pub const UC_ERROR_READ_ACCESS: Type = -2097167;
    pub const UC_ERROR_WRITE_ACCESS: Type = -2097168;
    pub const UC_ERROR_CREATE_ACCESS: Type = -2097169;
    pub const UC_ERROR_FILE_SYS_NAME: Type = -2097170;
    pub const UC_ERROR_FILE_SYS_INIT: Type = -2097171;
    pub const UC_ERROR_FILE_SYS_MOUNT: Type = -2097172;
    pub const UC_ERROR_FILE_OPEN: Type = -2097173;
    pub const UC_ERROR_FILE_STAT: Type = -2097174;
    pub const UC_ERROR_FILE_READ: Type = -2097175;
    pub const UC_ERROR_FILE_WRITE: Type = -2097176;
    pub const UC_ERROR_FILE_TOO_BIG: Type = -2097177;
    pub const UC_ERROR_FILE_REMOVE: Type = -2097178;
    pub const UC_ERROR_FILE_RENAME: Type = -2097179;
    pub const UC_ERROR_FILE_CLOSE: Type = -2097180;
    pub const UC_ERROR_FILE_SEEK: Type = -2097181;
    pub const UC_ERROR_FILE_CONFIRM: Type = -2097182;
    pub const UC_ERROR_FILE_BACKUP: Type = -2097183;
    pub const UC_ERROR_MALFORMED_XML: Type = -2097184;
    pub const UC_ERROR_VERSION: Type = -2097185;
    pub const UC_ERROR_NO_IPC_BUFFERS: Type = -2097186;
    pub const UC_ERROR_FILE_LOCK_NEEDED: Type = -2097188;
    pub const UC_ERROR_SYS_PROT: Type = -2097192;
}
pub mod UCFileSys {
    pub type Type = cty::c_uint;
    pub const UC_FILE_SYS_INVALID: Type = 0;
    pub const UC_FILE_SYS_SYS: Type = 1;
    pub const UC_FILE_SYS_SLC: Type = 2;
    pub const UC_FILE_SYS_RAM: Type = 3;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct UCSysConfig {
    pub name: [cty::c_char; 64usize],
    pub access: u32,
    pub dataType: UCDataType::Type,
    pub error: UCError,
    pub dataSize: u32,
    pub data: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_UCSysConfig() {
    assert_eq!(
        ::core::mem::size_of::<UCSysConfig>(),
        84usize,
        concat!("Size of: ", stringify!(UCSysConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<UCSysConfig>(),
        1usize,
        concat!("Alignment of ", stringify!(UCSysConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCSysConfig>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCSysConfig),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCSysConfig>())).access as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UCSysConfig),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCSysConfig>())).dataType as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(UCSysConfig),
            "::",
            stringify!(dataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCSysConfig>())).error as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UCSysConfig),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCSysConfig>())).dataSize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(UCSysConfig),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCSysConfig>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(UCSysConfig),
            "::",
            stringify!(data)
        )
    );
}
pub type UCAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: UCError,
        command: UCCommand::Type,
        count: u32,
        settings: *mut UCSysConfig,
        context: *mut cty::c_void,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UCAsyncParams {
    pub callback: UCAsyncCallbackFn,
    pub context: *mut cty::c_void,
    pub command: UCCommand::Type,
    pub unk0x0C: u32,
    pub count: u32,
    pub settings: *mut UCSysConfig,
    pub vecs: *mut IOSVec,
}
#[test]
fn bindgen_test_layout_UCAsyncParams() {
    assert_eq!(
        ::core::mem::size_of::<UCAsyncParams>(),
        28usize,
        concat!("Size of: ", stringify!(UCAsyncParams))
    );
    assert_eq!(
        ::core::mem::align_of::<UCAsyncParams>(),
        1usize,
        concat!("Alignment of ", stringify!(UCAsyncParams))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCAsyncParams>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAsyncParams),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCAsyncParams>())).context as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAsyncParams),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCAsyncParams>())).command as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAsyncParams),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCAsyncParams>())).unk0x0C as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAsyncParams),
            "::",
            stringify!(unk0x0C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCAsyncParams>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAsyncParams),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCAsyncParams>())).settings as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAsyncParams),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UCAsyncParams>())).vecs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAsyncParams),
            "::",
            stringify!(vecs)
        )
    );
}
extern "C" {
    pub fn UCOpen() -> UCError;
}
extern "C" {
    pub fn UCClose(handle: IOSHandle) -> UCError;
}
extern "C" {
    pub fn UCDeleteSysConfig(handle: i32, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCDeleteSysConfigAsync(
        handle: i32,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn UCReadSysConfig(handle: i32, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCReadSysConfigAsync(
        handle: i32,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn UCWriteSysConfig(handle: i32, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCWriteSysConfigAsync(
        handle: i32,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
#[doc = "! Timestamp for a DMAE operation."]
pub type DMAETimeStamp = u64;
extern "C" {
    #[doc = " Waits for a DMAE operation to complete."]
    #[doc = ""]
    #[doc = " \\param timestamp"]
    #[doc = " Timestamp of the operation to wait for."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " TRUE when successful."]
    pub fn DMAEWaitDone(timestamp: DMAETimeStamp) -> BOOL;
}
pub mod DMAESwapMode {
    #[doc = "! DMAE Memory endian swappng mode."]
    pub type Type = cty::c_uint;
    #[doc = "! No memory swapping."]
    pub const DMAE_SWAP_NONE: Type = 0;
    #[doc = "! 16 bit memory swapping."]
    pub const DMAE_SWAP_16: Type = 1;
    #[doc = "! 32 bit memory swapping."]
    pub const DMAE_SWAP_32: Type = 2;
    #[doc = "! 64 bit memory swapping."]
    pub const DMAE_SWAP_64: Type = 3;
}
extern "C" {
    #[doc = " Starts a DMAE copy operation."]
    #[doc = ""]
    #[doc = " \\param dst"]
    #[doc = " Pointer to the destination buffer."]
    #[doc = ""]
    #[doc = " \\param src"]
    #[doc = " Pointer to the source buffer."]
    #[doc = ""]
    #[doc = " \\param wordCount"]
    #[doc = " Number of 32 bit words to copy."]
    #[doc = ""]
    #[doc = " \\param swap"]
    #[doc = " Memory endian swapping mode."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " DMAE operations queue timestamp."]
    pub fn DMAECopyMem(
        dst: *mut cty::c_void,
        src: *const cty::c_void,
        wordCount: u32,
        swap: DMAESwapMode::Type,
    ) -> DMAETimeStamp;
}
extern "C" {
    #[doc = " Starts a DMAE fill operation."]
    #[doc = ""]
    #[doc = " \\param dst"]
    #[doc = " Pointer to the destination buffer."]
    #[doc = ""]
    #[doc = " \\param val"]
    #[doc = " The value to fill the destination buffer."]
    #[doc = ""]
    #[doc = " \\param wordCount"]
    #[doc = " Number of 32 bit words to fill."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " DMAE operations queue timestamp."]
    pub fn DMAEFillMem(dst: *mut cty::c_void, val: u32, wordCount: u32) -> DMAETimeStamp;
}
extern "C" {
    #[doc = " Starts a DMAE fill operation for a physical address."]
    #[doc = ""]
    #[doc = " \\param dst"]
    #[doc = " Pointer to the destination buffer (physical address)."]
    #[doc = ""]
    #[doc = " \\param val"]
    #[doc = " The value to fill the destination buffer."]
    #[doc = ""]
    #[doc = " \\param wordCount"]
    #[doc = " Number of 32 bit words to fill."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " DMAE operations queue timestamp."]
    pub fn DMAEFillMemPhys(dst: *mut cty::c_void, val: u32, wordCount: u32) -> DMAETimeStamp;
}
pub mod GX2AAMode {
    pub type Type = cty::c_uint;
    pub const GX2_AA_MODE1X: Type = 0;
    pub const GX2_AA_MODE2X: Type = 1;
    pub const GX2_AA_MODE4X: Type = 2;
}
pub mod GX2AlphaToMaskMode {
    pub type Type = cty::c_uint;
    pub const GX2_ALPHA_TO_MASK_MODE_NON_DITHERED: Type = 0;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_0: Type = 1;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_90: Type = 2;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_180: Type = 3;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_270: Type = 4;
}
pub mod GX2AttribFormat {
    pub type Type = cty::c_uint;
    pub const GX2_ATTRIB_FORMAT_UNORM_8: Type = 0;
    pub const GX2_ATTRIB_FORMAT_UNORM_8_8: Type = 4;
    pub const GX2_ATTRIB_FORMAT_UNORM_8_8_8_8: Type = 10;
    pub const GX2_ATTRIB_FORMAT_UINT_8: Type = 256;
    pub const GX2_ATTRIB_FORMAT_UINT_8_8: Type = 260;
    pub const GX2_ATTRIB_FORMAT_UINT_8_8_8_8: Type = 266;
    pub const GX2_ATTRIB_FORMAT_SNORM_8: Type = 512;
    pub const GX2_ATTRIB_FORMAT_SNORM_8_8: Type = 516;
    pub const GX2_ATTRIB_FORMAT_SNORM_8_8_8_8: Type = 522;
    pub const GX2_ATTRIB_FORMAT_SINT_8: Type = 768;
    pub const GX2_ATTRIB_FORMAT_SINT_8_8: Type = 772;
    pub const GX2_ATTRIB_FORMAT_SINT_8_8_8_8: Type = 778;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32: Type = 2054;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32: Type = 2061;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32: Type = 2065;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32_32: Type = 2067;
}
pub mod GX2AttribIndexType {
    pub type Type = cty::c_uint;
    pub const GX2_ATTRIB_INDEX_PER_VERTEX: Type = 0;
    pub const GX2_ATTRIB_INDEX_PER_INSTANCE: Type = 1;
}
pub mod GX2BlendMode {
    pub type Type = cty::c_uint;
    pub const GX2_BLEND_MODE_ZERO: Type = 0;
    pub const GX2_BLEND_MODE_ONE: Type = 1;
    pub const GX2_BLEND_MODE_SRC_COLOR: Type = 2;
    pub const GX2_BLEND_MODE_INV_SRC_COLOR: Type = 3;
    pub const GX2_BLEND_MODE_SRC_ALPHA: Type = 4;
    pub const GX2_BLEND_MODE_INV_SRC_ALPHA: Type = 5;
    pub const GX2_BLEND_MODE_DST_ALPHA: Type = 6;
    pub const GX2_BLEND_MODE_INV_DST_ALPHA: Type = 7;
    pub const GX2_BLEND_MODE_DST_COLOR: Type = 8;
    pub const GX2_BLEND_MODE_INV_DST_COLOR: Type = 9;
    pub const GX2_BLEND_MODE_SRC_ALPHA_SAT: Type = 10;
    pub const GX2_BLEND_MODE_BOTH_SRC_ALPHA: Type = 11;
    pub const GX2_BLEND_MODE_BOTH_INV_SRC_ALPHA: Type = 12;
    pub const GX2_BLEND_MODE_BLEND_FACTOR: Type = 13;
    pub const GX2_BLEND_MODE_INV_BLEND_FACTOR: Type = 14;
    pub const GX2_BLEND_MODE_SRC1_COLOR: Type = 15;
    pub const GX2_BLEND_MODE_INV_SRC1_COLOR: Type = 16;
    pub const GX2_BLEND_MODE_SRC1_ALPHA: Type = 17;
    pub const GX2_BLEND_MODE_INV_SRC1_ALPHA: Type = 18;
}
pub mod GX2BlendCombineMode {
    pub type Type = cty::c_uint;
    pub const GX2_BLEND_COMBINE_MODE_ADD: Type = 0;
    pub const GX2_BLEND_COMBINE_MODE_SUB: Type = 1;
    pub const GX2_BLEND_COMBINE_MODE_MIN: Type = 2;
    pub const GX2_BLEND_COMBINE_MODE_MAX: Type = 3;
    pub const GX2_BLEND_COMBINE_MODE_REV_SUB: Type = 4;
}
pub mod GX2BufferingMode {
    pub type Type = cty::c_uint;
    pub const GX2_BUFFERING_MODE_SINGLE: Type = 1;
    pub const GX2_BUFFERING_MODE_DOUBLE: Type = 2;
    pub const GX2_BUFFERING_MODE_TRIPLE: Type = 3;
}
pub mod GX2ChannelMask {
    pub type Type = cty::c_uint;
    pub const GX2_CHANNEL_MASK_R: Type = 1;
    pub const GX2_CHANNEL_MASK_G: Type = 2;
    pub const GX2_CHANNEL_MASK_RG: Type = 3;
    pub const GX2_CHANNEL_MASK_B: Type = 4;
    pub const GX2_CHANNEL_MASK_RB: Type = 5;
    pub const GX2_CHANNEL_MASK_GB: Type = 6;
    pub const GX2_CHANNEL_MASK_RGB: Type = 7;
    pub const GX2_CHANNEL_MASK_A: Type = 8;
    pub const GX2_CHANNEL_MASK_RA: Type = 9;
    pub const GX2_CHANNEL_MASK_GA: Type = 10;
    pub const GX2_CHANNEL_MASK_RGA: Type = 11;
    pub const GX2_CHANNEL_MASK_BA: Type = 12;
    pub const GX2_CHANNEL_MASK_RBA: Type = 13;
    pub const GX2_CHANNEL_MASK_GBA: Type = 14;
    pub const GX2_CHANNEL_MASK_RGBA: Type = 15;
}
pub mod GX2ClearFlags {
    pub type Type = cty::c_uint;
    pub const GX2_CLEAR_FLAGS_DEPTH: Type = 1;
    pub const GX2_CLEAR_FLAGS_STENCIL: Type = 2;
    pub const GX2_CLEAR_FLAGS_BOTH: Type = 3;
}
pub mod GX2CompareFunction {
    pub type Type = cty::c_uint;
    pub const GX2_COMPARE_FUNC_NEVER: Type = 0;
    pub const GX2_COMPARE_FUNC_LESS: Type = 1;
    pub const GX2_COMPARE_FUNC_EQUAL: Type = 2;
    pub const GX2_COMPARE_FUNC_LEQUAL: Type = 3;
    pub const GX2_COMPARE_FUNC_GREATER: Type = 4;
    pub const GX2_COMPARE_FUNC_NOT_EQUAL: Type = 5;
    pub const GX2_COMPARE_FUNC_GEQUAL: Type = 6;
    pub const GX2_COMPARE_FUNC_ALWAYS: Type = 7;
}
pub mod GX2DrcRenderMode {
    pub type Type = cty::c_uint;
    pub const GX2_DRC_RENDER_MODE_DISABLED: Type = 0;
    pub const GX2_DRC_RENDER_MODE_SINGLE: Type = 1;
}
pub mod GX2EventType {
    pub type Type = cty::c_uint;
    pub const GX2_EVENT_TYPE_VSYNC: Type = 2;
    pub const GX2_EVENT_TYPE_FLIP: Type = 3;
    pub const GX2_EVENT_TYPE_DISPLAY_LIST_OVERRUN: Type = 4;
}
pub mod GX2EndianSwapMode {
    pub type Type = cty::c_uint;
    pub const GX2_ENDIAN_SWAP_NONE: Type = 0;
    pub const GX2_ENDIAN_SWAP_8_IN_16: Type = 1;
    pub const GX2_ENDIAN_SWAP_8_IN_32: Type = 2;
    pub const GX2_ENDIAN_SWAP_DEFAULT: Type = 3;
}
pub mod GX2FetchShaderType {
    pub type Type = cty::c_uint;
    pub const GX2_FETCH_SHADER_TESSELLATION_NONE: Type = 0;
    pub const GX2_FETCH_SHADER_TESSELLATION_LINE: Type = 1;
    pub const GX2_FETCH_SHADER_TESSELLATION_TRIANGLE: Type = 2;
    pub const GX2_FETCH_SHADER_TESSELLATION_QUAD: Type = 3;
}
pub mod GX2FrontFace {
    pub type Type = cty::c_uint;
    pub const GX2_FRONT_FACE_CCW: Type = 0;
    pub const GX2_FRONT_FACE_CW: Type = 1;
}
pub mod GX2IndexType {
    pub type Type = cty::c_uint;
    pub const GX2_INDEX_TYPE_U16_LE: Type = 0;
    pub const GX2_INDEX_TYPE_U32_LE: Type = 1;
    pub const GX2_INDEX_TYPE_U16: Type = 4;
    pub const GX2_INDEX_TYPE_U32: Type = 9;
}
pub mod GX2InvalidateMode {
    pub type Type = cty::c_uint;
    pub const GX2_INVALIDATE_MODE_ATTRIBUTE_BUFFER: Type = 1;
    pub const GX2_INVALIDATE_MODE_TEXTURE: Type = 2;
    pub const GX2_INVALIDATE_MODE_UNIFORM_BLOCK: Type = 4;
    pub const GX2_INVALIDATE_MODE_SHADER: Type = 8;
    pub const GX2_INVALIDATE_MODE_COLOR_BUFFER: Type = 16;
    pub const GX2_INVALIDATE_MODE_DEPTH_BUFFER: Type = 32;
    pub const GX2_INVALIDATE_MODE_CPU: Type = 64;
    pub const GX2_INVALIDATE_MODE_STREAM_OUT_BUFFER: Type = 128;
    pub const GX2_INVALIDATE_MODE_EXPORT_BUFFER: Type = 256;
    pub const GX2_INVALIDATE_MODE_CPU_ATTRIBUTE_BUFFER: Type = 65;
    pub const GX2_INVALIDATE_MODE_CPU_TEXTURE: Type = 66;
    pub const GX2_INVALIDATE_MODE_CPU_SHADER: Type = 72;
}
pub mod GX2InitAttributes {
    pub type Type = cty::c_uint;
    pub const GX2_INIT_END: Type = 0;
    pub const GX2_INIT_CMD_BUF_BASE: Type = 1;
    pub const GX2_INIT_CMD_BUF_POOL_SIZE: Type = 2;
    pub const GX2_INIT_ARGC: Type = 7;
    pub const GX2_INIT_ARGV: Type = 8;
}
pub mod GX2LogicOp {
    pub type Type = cty::c_uint;
    pub const GX2_LOGIC_OP_CLEAR: Type = 0;
    pub const GX2_LOGIC_OP_NOR: Type = 17;
    pub const GX2_LOGIC_OP_INV_AND: Type = 34;
    pub const GX2_LOGIC_OP_INV_COPY: Type = 51;
    pub const GX2_LOGIC_OP_REV_AND: Type = 68;
    pub const GX2_LOGIC_OP_INV: Type = 85;
    pub const GX2_LOGIC_OP_XOR: Type = 102;
    pub const GX2_LOGIC_OP_NOT_AND: Type = 119;
    pub const GX2_LOGIC_OP_AND: Type = 136;
    pub const GX2_LOGIC_OP_EQUIV: Type = 153;
    pub const GX2_LOGIC_OP_NOP: Type = 170;
    pub const GX2_LOGIC_OP_INV_OR: Type = 187;
    pub const GX2_LOGIC_OP_COPY: Type = 204;
    pub const GX2_LOGIC_OP_REV_OR: Type = 221;
    pub const GX2_LOGIC_OP_OR: Type = 238;
    pub const GX2_LOGIC_OP_SET: Type = 255;
}
pub mod GX2PrimitiveMode {
    pub type Type = cty::c_uint;
    pub const GX2_PRIMITIVE_MODE_POINTS: Type = 1;
    pub const GX2_PRIMITIVE_MODE_LINES: Type = 2;
    pub const GX2_PRIMITIVE_MODE_LINE_STRIP: Type = 3;
    pub const GX2_PRIMITIVE_MODE_TRIANGLES: Type = 4;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_FAN: Type = 5;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP: Type = 6;
    pub const GX2_PRIMITIVE_MODE_LINES_ADJACENCY: Type = 10;
    pub const GX2_PRIMITIVE_MODE_LINE_STRIP_ADJACENCY: Type = 11;
    pub const GX2_PRIMITIVE_MODE_TRIANGLES_ADJACENCY: Type = 12;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP_ADJACENCY: Type = 13;
    pub const GX2_PRIMITIVE_MODE_RECTS: Type = 17;
    pub const GX2_PRIMITIVE_MODE_LINE_LOOP: Type = 18;
    pub const GX2_PRIMITIVE_MODE_QUADS: Type = 19;
    pub const GX2_PRIMITIVE_MODE_QUAD_STRIP: Type = 20;
}
pub mod GX2PolygonMode {
    pub type Type = cty::c_uint;
    pub const GX2_POLYGON_MODE_POINT: Type = 0;
    pub const GX2_POLYGON_MODE_LINE: Type = 1;
    pub const GX2_POLYGON_MODE_TRIANGLE: Type = 2;
}
pub mod GX2RenderTarget {
    pub type Type = cty::c_uint;
    pub const GX2_RENDER_TARGET_0: Type = 0;
    pub const GX2_RENDER_TARGET_1: Type = 1;
    pub const GX2_RENDER_TARGET_2: Type = 2;
    pub const GX2_RENDER_TARGET_3: Type = 3;
    pub const GX2_RENDER_TARGET_4: Type = 4;
    pub const GX2_RENDER_TARGET_5: Type = 5;
    pub const GX2_RENDER_TARGET_6: Type = 6;
}
pub mod GX2RoundingMode {
    pub type Type = cty::c_uint;
    pub const GX2_ROUNDING_MODE_ROUND_TO_EVEN: Type = 0;
    pub const GX2_ROUNDING_MODE_TRUNCATE: Type = 1;
}
pub mod GX2SamplerVarType {
    pub type Type = cty::c_uint;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_1D: Type = 0;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_2D: Type = 1;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_3D: Type = 3;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_CUBE: Type = 4;
}
pub mod GX2ScanTarget {
    pub type Type = cty::c_uint;
    pub const GX2_SCAN_TARGET_TV: Type = 1;
    pub const GX2_SCAN_TARGET_DRC: Type = 4;
}
pub mod GX2ShaderMode {
    pub type Type = cty::c_uint;
    pub const GX2_SHADER_MODE_UNIFORM_REGISTER: Type = 0;
    pub const GX2_SHADER_MODE_UNIFORM_BLOCK: Type = 1;
    pub const GX2_SHADER_MODE_GEOMETRY_SHADER: Type = 2;
    pub const GX2_SHADER_MODE_COMPUTE_SHADER: Type = 3;
}
pub mod GX2ShaderVarType {
    pub type Type = cty::c_uint;
    pub const GX2_SHADER_VAR_TYPE_INT: Type = 2;
    pub const GX2_SHADER_VAR_TYPE_FLOAT: Type = 4;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2: Type = 9;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3: Type = 10;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4: Type = 11;
    pub const GX2_SHADER_VAR_TYPE_INT2: Type = 15;
    pub const GX2_SHADER_VAR_TYPE_INT3: Type = 16;
    pub const GX2_SHADER_VAR_TYPE_INT4: Type = 17;
    pub const GX2_SHADER_VAR_TYPE_MATRIX4X4: Type = 29;
}
pub mod GX2StencilFunction {
    pub type Type = cty::c_uint;
    pub const GX2_STENCIL_FUNCTION_KEEP: Type = 0;
    pub const GX2_STENCIL_FUNCTION_ZERO: Type = 1;
    pub const GX2_STENCIL_FUNCTION_REPLACE: Type = 2;
    pub const GX2_STENCIL_FUNCTION_INCR_CLAMP: Type = 3;
    pub const GX2_STENCIL_FUNCTION_DECR_CLAMP: Type = 4;
    pub const GX2_STENCIL_FUNCTION_INV: Type = 5;
    pub const GX2_STENCIL_FUNCTION_INCR_WRAP: Type = 6;
    pub const GX2_STENCIL_FUNCTION_DECR_WRAP: Type = 7;
}
pub mod GX2SurfaceDim {
    pub type Type = cty::c_uint;
    pub const GX2_SURFACE_DIM_TEXTURE_1D: Type = 0;
    pub const GX2_SURFACE_DIM_TEXTURE_2D: Type = 1;
    pub const GX2_SURFACE_DIM_TEXTURE_3D: Type = 2;
    pub const GX2_SURFACE_DIM_TEXTURE_CUBE: Type = 3;
    pub const GX2_SURFACE_DIM_TEXTURE_1D_ARRAY: Type = 4;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_ARRAY: Type = 5;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA: Type = 6;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA_ARRAY: Type = 7;
}
pub mod GX2SurfaceFormat {
    pub type Type = cty::c_uint;
    pub const GX2_SURFACE_FORMAT_INVALID: Type = 0;
    pub const GX2_SURFACE_FORMAT_UNORM_R4_G4: Type = 2;
    pub const GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4: Type = 11;
    pub const GX2_SURFACE_FORMAT_UNORM_R8: Type = 1;
    pub const GX2_SURFACE_FORMAT_UNORM_R8_G8: Type = 7;
    pub const GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8: Type = 26;
    pub const GX2_SURFACE_FORMAT_UNORM_R16: Type = 5;
    pub const GX2_SURFACE_FORMAT_UNORM_R16_G16: Type = 15;
    pub const GX2_SURFACE_FORMAT_UNORM_R16_G16_B16_A16: Type = 31;
    pub const GX2_SURFACE_FORMAT_UNORM_R5_G6_B5: Type = 8;
    pub const GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1: Type = 10;
    pub const GX2_SURFACE_FORMAT_UNORM_A1_B5_G5_R5: Type = 12;
    pub const GX2_SURFACE_FORMAT_UNORM_R24_X8: Type = 17;
    pub const GX2_SURFACE_FORMAT_UNORM_A2_B10_G10_R10: Type = 27;
    pub const GX2_SURFACE_FORMAT_UNORM_R10_G10_B10_A2: Type = 25;
    pub const GX2_SURFACE_FORMAT_UNORM_BC1: Type = 49;
    pub const GX2_SURFACE_FORMAT_UNORM_BC2: Type = 50;
    pub const GX2_SURFACE_FORMAT_UNORM_BC3: Type = 51;
    pub const GX2_SURFACE_FORMAT_UNORM_BC4: Type = 52;
    pub const GX2_SURFACE_FORMAT_UNORM_BC5: Type = 53;
    pub const GX2_SURFACE_FORMAT_UNORM_NV12: Type = 129;
    pub const GX2_SURFACE_FORMAT_UINT_R8: Type = 257;
    pub const GX2_SURFACE_FORMAT_UINT_R8_G8: Type = 263;
    pub const GX2_SURFACE_FORMAT_UINT_R8_G8_B8_A8: Type = 282;
    pub const GX2_SURFACE_FORMAT_UINT_R16: Type = 261;
    pub const GX2_SURFACE_FORMAT_UINT_R16_G16: Type = 271;
    pub const GX2_SURFACE_FORMAT_UINT_R16_G16_B16_A16: Type = 287;
    pub const GX2_SURFACE_FORMAT_UINT_R32: Type = 269;
    pub const GX2_SURFACE_FORMAT_UINT_R32_G32: Type = 285;
    pub const GX2_SURFACE_FORMAT_UINT_R32_G32_B32_A32: Type = 290;
    pub const GX2_SURFACE_FORMAT_UINT_A2_B10_G10_R10: Type = 283;
    pub const GX2_SURFACE_FORMAT_UINT_R10_G10_B10_A2: Type = 281;
    pub const GX2_SURFACE_FORMAT_UINT_X24_G8: Type = 273;
    pub const GX2_SURFACE_FORMAT_UINT_G8_X24: Type = 284;
    pub const GX2_SURFACE_FORMAT_SNORM_R8: Type = 513;
    pub const GX2_SURFACE_FORMAT_SNORM_R8_G8: Type = 519;
    pub const GX2_SURFACE_FORMAT_SNORM_R8_G8_B8_A8: Type = 538;
    pub const GX2_SURFACE_FORMAT_SNORM_R16: Type = 517;
    pub const GX2_SURFACE_FORMAT_SNORM_R16_G16: Type = 527;
    pub const GX2_SURFACE_FORMAT_SNORM_R16_G16_B16_A16: Type = 543;
    pub const GX2_SURFACE_FORMAT_SNORM_R10_G10_B10_A2: Type = 537;
    pub const GX2_SURFACE_FORMAT_SNORM_BC4: Type = 564;
    pub const GX2_SURFACE_FORMAT_SNORM_BC5: Type = 565;
    pub const GX2_SURFACE_FORMAT_SINT_R8: Type = 769;
    pub const GX2_SURFACE_FORMAT_SINT_R8_G8: Type = 775;
    pub const GX2_SURFACE_FORMAT_SINT_R8_G8_B8_A8: Type = 794;
    pub const GX2_SURFACE_FORMAT_SINT_R16: Type = 773;
    pub const GX2_SURFACE_FORMAT_SINT_R16_G16: Type = 783;
    pub const GX2_SURFACE_FORMAT_SINT_R16_G16_B16_A16: Type = 799;
    pub const GX2_SURFACE_FORMAT_SINT_R32: Type = 781;
    pub const GX2_SURFACE_FORMAT_SINT_R32_G32: Type = 797;
    pub const GX2_SURFACE_FORMAT_SINT_R32_G32_B32_A32: Type = 802;
    pub const GX2_SURFACE_FORMAT_SINT_R10_G10_B10_A2: Type = 793;
    pub const GX2_SURFACE_FORMAT_SRGB_R8_G8_B8_A8: Type = 1050;
    pub const GX2_SURFACE_FORMAT_SRGB_BC1: Type = 1073;
    pub const GX2_SURFACE_FORMAT_SRGB_BC2: Type = 1074;
    pub const GX2_SURFACE_FORMAT_SRGB_BC3: Type = 1075;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32: Type = 2062;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32: Type = 2078;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32_B32_A32: Type = 2083;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16: Type = 2054;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16: Type = 2064;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16_B16_A16: Type = 2080;
    pub const GX2_SURFACE_FORMAT_FLOAT_R11_G11_B10: Type = 2070;
    pub const GX2_SURFACE_FORMAT_FLOAT_D24_S8: Type = 2065;
    pub const GX2_SURFACE_FORMAT_FLOAT_X8_X24: Type = 2076;
}
pub mod GX2SurfaceUse {
    pub type Type = cty::c_int;
    pub const GX2_SURFACE_USE_TEXTURE: Type = 1;
    pub const GX2_SURFACE_USE_COLOR_BUFFER: Type = 2;
    pub const GX2_SURFACE_USE_DEPTH_BUFFER: Type = 4;
    pub const GX2_SURFACE_USE_SCAN_BUFFER: Type = 8;
    pub const GX2_SURFACE_USE_TV: Type = -2147483648;
    pub const GX2_SURFACE_USE_TEXTURE_COLOR_BUFFER_TV: Type = -2147483645;
}
pub mod GX2TessellationMode {
    pub type Type = cty::c_uint;
    pub const GX2_TESSELLATION_MODE_DISCRETE: Type = 0;
    pub const GX2_TESSELLATION_MODE_CONTINUOUS: Type = 1;
    pub const GX2_TESSELLATION_MODE_ADAPTIVE: Type = 2;
}
pub mod GX2TexBorderType {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_BORDER_TYPE_TRANSPARENT_BLACK: Type = 0;
    pub const GX2_TEX_BORDER_TYPE_BLACK: Type = 1;
    pub const GX2_TEX_BORDER_TYPE_WHITE: Type = 2;
    pub const GX2_TEX_BORDER_TYPE_VARIABLE: Type = 3;
}
pub mod GX2TexClampMode {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_CLAMP_MODE_WRAP: Type = 0;
    pub const GX2_TEX_CLAMP_MODE_MIRROR: Type = 1;
    pub const GX2_TEX_CLAMP_MODE_CLAMP: Type = 2;
    pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE: Type = 3;
    pub const GX2_TEX_CLAMP_MODE_CLAMP_BORDER: Type = 6;
}
pub mod GX2TexMipFilterMode {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_MIP_FILTER_MODE_NONE: Type = 0;
    pub const GX2_TEX_MIP_FILTER_MODE_POINT: Type = 1;
    pub const GX2_TEX_MIP_FILTER_MODE_LINEAR: Type = 2;
}
pub mod GX2TexMipPerfMode {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_MIP_PERF_MODE_DISABLE: Type = 0;
}
pub mod GX2TexXYFilterMode {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_XY_FILTER_MODE_POINT: Type = 0;
    pub const GX2_TEX_XY_FILTER_MODE_LINEAR: Type = 1;
}
pub mod GX2TexAnisoRatio {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_ANISO_RATIO_NONE: Type = 0;
}
pub mod GX2TexZFilterMode {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_Z_FILTER_MODE_NONE: Type = 0;
    pub const GX2_TEX_Z_FILTER_MODE_POINT: Type = 1;
    pub const GX2_TEX_Z_FILTER_MODE_LINEAR: Type = 2;
}
pub mod GX2TexZPerfMode {
    pub type Type = cty::c_uint;
    pub const GX2_TEX_Z_PERF_MODE_DISABLED: Type = 0;
}
pub mod GX2TileMode {
    pub type Type = cty::c_uint;
    pub const GX2_TILE_MODE_DEFAULT: Type = 0;
    pub const GX2_TILE_MODE_LINEAR_ALIGNED: Type = 1;
    pub const GX2_TILE_MODE_TILED_1D_THIN1: Type = 2;
    pub const GX2_TILE_MODE_TILED_1D_THICK: Type = 3;
    pub const GX2_TILE_MODE_TILED_2D_THIN1: Type = 4;
    pub const GX2_TILE_MODE_TILED_2D_THIN2: Type = 5;
    pub const GX2_TILE_MODE_TILED_2D_THIN4: Type = 6;
    pub const GX2_TILE_MODE_TILED_2D_THICK: Type = 7;
    pub const GX2_TILE_MODE_TILED_2B_THIN1: Type = 8;
    pub const GX2_TILE_MODE_TILED_2B_THIN2: Type = 9;
    pub const GX2_TILE_MODE_TILED_2B_THIN4: Type = 10;
    pub const GX2_TILE_MODE_TILED_2B_THICK: Type = 11;
    pub const GX2_TILE_MODE_TILED_3D_THIN1: Type = 12;
    pub const GX2_TILE_MODE_TILED_3D_THICK: Type = 13;
    pub const GX2_TILE_MODE_TILED_3B_THIN1: Type = 14;
    pub const GX2_TILE_MODE_TILED_3B_THICK: Type = 15;
    pub const GX2_TILE_MODE_LINEAR_SPECIAL: Type = 16;
}
pub mod GX2TVRenderMode {
    pub type Type = cty::c_uint;
    pub const GX2_TV_RENDER_MODE_STANDARD_480P: Type = 1;
    pub const GX2_TV_RENDER_MODE_WIDE_480P: Type = 2;
    pub const GX2_TV_RENDER_MODE_WIDE_720P: Type = 3;
    pub const GX2_TV_RENDER_MODE_WIDE_1080P: Type = 5;
}
pub mod GX2TVScanMode {
    pub type Type = cty::c_uint;
    pub const GX2_TV_SCAN_MODE_NONE: Type = 0;
    pub const GX2_TV_SCAN_MODE_576I: Type = 1;
    pub const GX2_TV_SCAN_MODE_480I: Type = 2;
    pub const GX2_TV_SCAN_MODE_480P: Type = 3;
    pub const GX2_TV_SCAN_MODE_720P: Type = 4;
    pub const GX2_TV_SCAN_MODE_1080I: Type = 6;
    pub const GX2_TV_SCAN_MODE_1080P: Type = 7;
}
extern "C" {
    pub fn GX2ClearColor(
        colorBuffer: *mut GX2ColorBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
}
extern "C" {
    pub fn GX2ClearDepthStencilEx(
        depthBuffer: *mut GX2DepthBuffer,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags::Type,
    );
}
extern "C" {
    pub fn GX2ClearBuffersEx(
        colorBuffer: *mut GX2ColorBuffer,
        depthBuffer: *mut GX2DepthBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags::Type,
    );
}
extern "C" {
    pub fn GX2SetClearDepth(depthBuffer: *mut GX2DepthBuffer, depth: f32);
}
extern "C" {
    pub fn GX2SetClearStencil(depthBuffer: *mut GX2DepthBuffer, stencil: u8);
}
extern "C" {
    pub fn GX2SetClearDepthStencil(depthBuffer: *mut GX2DepthBuffer, depth: f32, stencil: u8);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2ShadowState {
    pub config: [u32; 2816usize],
    pub context: [u32; 1024usize],
    pub alu: [u32; 2048usize],
    pub loop_: [u32; 96usize],
    pub __unk43: [cty::c_char; 128usize],
    pub resource: [u32; 3486usize],
    pub __unk44: [cty::c_char; 136usize],
    pub sampler: [u32; 162usize],
    pub __unk45: [cty::c_char; 120usize],
}
#[test]
fn bindgen_test_layout_GX2ShadowState() {
    assert_eq!(
        ::core::mem::size_of::<GX2ShadowState>(),
        38912usize,
        concat!("Size of: ", stringify!(GX2ShadowState))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2ShadowState>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2ShadowState))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).context as *const _ as usize },
        11264usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).alu as *const _ as usize },
        15360usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(alu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).loop_ as *const _ as usize },
        23552usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).__unk43 as *const _ as usize },
        23936usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(__unk43)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).resource as *const _ as usize },
        24064usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).__unk44 as *const _ as usize },
        38008usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(__unk44)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).sampler as *const _ as usize },
        38144usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(sampler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ShadowState>())).__unk45 as *const _ as usize },
        38792usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ShadowState),
            "::",
            stringify!(__unk45)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2ContextState {
    pub shadowState: GX2ShadowState,
    pub __unk46: [cty::c_char; 4usize],
    pub shadowDisplayListSize: u32,
    pub __unk47: [cty::c_char; 1528usize],
    pub shadowDisplayList: [u32; 192usize],
}
#[test]
fn bindgen_test_layout_GX2ContextState() {
    assert_eq!(
        ::core::mem::size_of::<GX2ContextState>(),
        41216usize,
        concat!("Size of: ", stringify!(GX2ContextState))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2ContextState>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2ContextState))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ContextState>())).shadowState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ContextState),
            "::",
            stringify!(shadowState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ContextState>())).__unk46 as *const _ as usize },
        38912usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ContextState),
            "::",
            stringify!(__unk46)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ContextState>())).shadowDisplayListSize as *const _ as usize
        },
        38916usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ContextState),
            "::",
            stringify!(shadowDisplayListSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ContextState>())).__unk47 as *const _ as usize },
        38920usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ContextState),
            "::",
            stringify!(__unk47)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ContextState>())).shadowDisplayList as *const _ as usize
        },
        40448usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ContextState),
            "::",
            stringify!(shadowDisplayList)
        )
    );
}
extern "C" {
    pub fn GX2SetupContextStateEx(state: *mut GX2ContextState, unk1: BOOL);
}
extern "C" {
    pub fn GX2GetContextStateDisplayList(
        state: *const GX2ContextState,
        outDisplayList: *mut cty::c_void,
        outSize: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetContextState(state: *mut GX2ContextState);
}
extern "C" {
    pub fn GX2SetDefaultState();
}
pub mod GX2RResourceFlags {
    pub type Type = cty::c_uint;
    #[doc = "! This resource is to be used as a texture"]
    pub const GX2R_RESOURCE_BIND_TEXTURE: Type = 1;
    #[doc = "! This resource is to be used as a colour buffer"]
    pub const GX2R_RESOURCE_BIND_COLOR_BUFFER: Type = 2;
    #[doc = "! This resource is to be used as a depth buffer"]
    pub const GX2R_RESOURCE_BIND_DEPTH_BUFFER: Type = 4;
    #[doc = "! This resource is to be used as a scan buffer"]
    pub const GX2R_RESOURCE_BIND_SCAN_BUFFER: Type = 8;
    #[doc = "! This resource is to be used as a vertex buffer"]
    pub const GX2R_RESOURCE_BIND_VERTEX_BUFFER: Type = 16;
    #[doc = "! This resource is to be used as a index buffer"]
    pub const GX2R_RESOURCE_BIND_INDEX_BUFFER: Type = 32;
    #[doc = "! This resource is to be used as a uniform block"]
    pub const GX2R_RESOURCE_BIND_UNIFORM_BLOCK: Type = 64;
    #[doc = "! This resource is to be used as a shader program"]
    pub const GX2R_RESOURCE_BIND_SHADER_PROGRAM: Type = 128;
    #[doc = "! This resource is to be used as a stream output"]
    pub const GX2R_RESOURCE_BIND_STREAM_OUTPUT: Type = 256;
    #[doc = "! This resource is to be used as a display list"]
    pub const GX2R_RESOURCE_BIND_DISPLAY_LIST: Type = 512;
    #[doc = "! This resource is to be used as a geometry shader ring buffer"]
    pub const GX2R_RESOURCE_BIND_GS_RING_BUFFER: Type = 1024;
    #[doc = "! Invalidate resource for a CPU read"]
    pub const GX2R_RESOURCE_USAGE_CPU_READ: Type = 2048;
    #[doc = "! Invalidate resource for a CPU write"]
    pub const GX2R_RESOURCE_USAGE_CPU_WRITE: Type = 4096;
    #[doc = "! Invalidate resource for a GPU read"]
    pub const GX2R_RESOURCE_USAGE_GPU_READ: Type = 8192;
    #[doc = "! Invalidate resource for a GPU write"]
    pub const GX2R_RESOURCE_USAGE_GPU_WRITE: Type = 16384;
    #[doc = "! Invalidate resource for a DMA read"]
    pub const GX2R_RESOURCE_USAGE_DMA_READ: Type = 32768;
    #[doc = "! Invalidate resource for a DMA write"]
    pub const GX2R_RESOURCE_USAGE_DMA_WRITE: Type = 65536;
    #[doc = "! Force resource allocation to be in MEM1"]
    pub const GX2R_RESOURCE_USAGE_FORCE_MEM1: Type = 131072;
    #[doc = "! Force resource allocation to be in MEM2"]
    pub const GX2R_RESOURCE_USAGE_FORCE_MEM2: Type = 262144;
    #[doc = "! Disable CPU invalidation"]
    pub const GX2R_RESOURCE_DISABLE_CPU_INVALIDATE: Type = 1048576;
    #[doc = "! Disable GPU invalidation"]
    pub const GX2R_RESOURCE_DISABLE_GPU_INVALIDATE: Type = 2097152;
    #[doc = "! Resource is locked for read-only access"]
    pub const GX2R_RESOURCE_LOCKED_READ_ONLY: Type = 4194304;
    #[doc = "! Resource was allocated by GX2R."]
    pub const GX2R_RESOURCE_GX2R_ALLOCATED: Type = 536870912;
    #[doc = "! Resource is locked for all access"]
    pub const GX2R_RESOURCE_LOCKED: Type = 1073741824;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Surface {
    pub dim: GX2SurfaceDim::Type,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub mipLevels: u32,
    pub format: GX2SurfaceFormat::Type,
    pub aa: GX2AAMode::Type,
    pub __bindgen_anon_1: GX2Surface__bindgen_ty_1,
    pub imageSize: u32,
    pub image: *mut cty::c_void,
    pub mipmapSize: u32,
    pub mipmaps: *mut cty::c_void,
    pub tileMode: GX2TileMode::Type,
    pub swizzle: u32,
    pub alignment: u32,
    pub pitch: u32,
    pub mipLevelOffset: [u32; 13usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GX2Surface__bindgen_ty_1 {
    pub use_: GX2SurfaceUse::Type,
    pub resourceFlags: GX2RResourceFlags::Type,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_GX2Surface__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GX2Surface__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GX2Surface__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2Surface__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2Surface__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface__bindgen_ty_1>())).use_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface__bindgen_ty_1),
            "::",
            stringify!(use_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2Surface__bindgen_ty_1>())).resourceFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface__bindgen_ty_1),
            "::",
            stringify!(resourceFlags)
        )
    );
}
#[test]
fn bindgen_test_layout_GX2Surface() {
    assert_eq!(
        ::core::mem::size_of::<GX2Surface>(),
        116usize,
        concat!("Size of: ", stringify!(GX2Surface))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2Surface>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2Surface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).dim as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(dim)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).depth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).mipLevels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(mipLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).format as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).aa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(aa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).imageSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(imageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).image as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).mipmapSize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(mipmapSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).mipmaps as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(mipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).tileMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(tileMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).swizzle as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(swizzle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).alignment as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).pitch as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Surface>())).mipLevelOffset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Surface),
            "::",
            stringify!(mipLevelOffset)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2DepthBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub hiZPtr: *mut cty::c_void,
    pub hiZSize: u32,
    pub depthClear: f32,
    pub stencilClear: u32,
    pub regs: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_GX2DepthBuffer() {
    assert_eq!(
        ::core::mem::size_of::<GX2DepthBuffer>(),
        172usize,
        concat!("Size of: ", stringify!(GX2DepthBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2DepthBuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2DepthBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).surface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).viewMip as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(viewMip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).viewFirstSlice as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(viewFirstSlice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).viewNumSlices as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(viewNumSlices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).hiZPtr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(hiZPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).hiZSize as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(hiZSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).depthClear as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(depthClear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).stencilClear as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(stencilClear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2DepthBuffer>())).regs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthBuffer),
            "::",
            stringify!(regs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2ColorBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub aaBuffer: *mut cty::c_void,
    pub aaSize: u32,
    pub regs: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_GX2ColorBuffer() {
    assert_eq!(
        ::core::mem::size_of::<GX2ColorBuffer>(),
        156usize,
        concat!("Size of: ", stringify!(GX2ColorBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2ColorBuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2ColorBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ColorBuffer>())).surface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorBuffer),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ColorBuffer>())).viewMip as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorBuffer),
            "::",
            stringify!(viewMip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ColorBuffer>())).viewFirstSlice as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorBuffer),
            "::",
            stringify!(viewFirstSlice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ColorBuffer>())).viewNumSlices as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorBuffer),
            "::",
            stringify!(viewNumSlices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ColorBuffer>())).aaBuffer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorBuffer),
            "::",
            stringify!(aaBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ColorBuffer>())).aaSize as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorBuffer),
            "::",
            stringify!(aaSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2ColorBuffer>())).regs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorBuffer),
            "::",
            stringify!(regs)
        )
    );
}
extern "C" {
    pub fn GX2CalcSurfaceSizeAndAlignment(surface: *mut GX2Surface);
}
extern "C" {
    pub fn GX2CalcDepthBufferHiZInfo(
        depthBuffer: *mut GX2DepthBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
}
extern "C" {
    pub fn GX2CalcColorBufferAuxInfo(
        surface: *mut GX2ColorBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetColorBuffer(colorBuffer: *const GX2ColorBuffer, target: GX2RenderTarget::Type);
}
extern "C" {
    pub fn GX2SetDepthBuffer(depthBuffer: *const GX2DepthBuffer);
}
extern "C" {
    pub fn GX2InitColorBufferRegs(colorBuffer: *mut GX2ColorBuffer);
}
extern "C" {
    pub fn GX2InitDepthBufferRegs(depthBuffer: *mut GX2DepthBuffer);
}
extern "C" {
    pub fn GX2InitDepthBufferHiZEnable(depthBuffer: *mut GX2DepthBuffer, enable: BOOL);
}
extern "C" {
    pub fn GX2GetSurfaceSwizzle(surface: *const GX2Surface) -> u32;
}
extern "C" {
    pub fn GX2SetSurfaceSwizzle(surface: *mut GX2Surface, swizzle: u32);
}
extern "C" {
    pub fn GX2CopySurface(
        src: *const GX2Surface,
        srcLevel: u32,
        srcDepth: u32,
        dst: *mut GX2Surface,
        dstLevel: u32,
        dstDepth: u32,
    );
}
extern "C" {
    pub fn GX2ResolveAAColorBuffer(
        srcColorBuffer: *const GX2ColorBuffer,
        dstSurface: *mut GX2Surface,
        dstMip: u32,
        dstSlice: u32,
    );
}
pub mod GX2DebugCaptureInterfaceVersion {
    pub type Type = cty::c_uint;
    pub const GX2_DEBUG_CAPTURE_INTERFACE_VERSION: Type = 1;
}
pub mod GX2DebugCaptureStartFlags {
    pub type Type = cty::c_uint;
    pub const GX2_DEBUG_CAPTURE_START_FLAGS_NONE: Type = 0;
    #[doc = "! When set GX2DebugCaptureEnd will NOT call GX2DrawDone."]
    pub const GX2_DEBUG_CAPTURE_START_FLAGS_DISABLE_GX2DRAWDONE: Type = 1;
}
pub mod GX2DebugCaptureEndFlags {
    pub type Type = cty::c_uint;
    pub const GX2_DEBUG_CAPTURE_END_FLAGS_NONE: Type = 0;
    #[doc = "! When set GX2DebugCaptureEnd will NOT call GX2Flush."]
    pub const GX2_DEBUG_CAPTURE_END_FLAGS_DISABLE_GX2FLUSH: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DebugCaptureInterface {
    #[doc = "! Must be set to GX2_DEBUG_CAPTURE_INTERFACE_VERSION"]
    pub version: u32,
    #[doc = "! Called from GX2Shutdown."]
    pub onShutdown: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "! Called from GX2DebugSetCaptureInterface with the default gx2 allocators."]
    pub setAllocator: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "! Called from GX2DebugCaptureStart, the filename is first argument passed"]
    #[doc = "! in to GX2DebugCaptureStart."]
    pub onCaptureStart: ::core::option::Option<unsafe extern "C" fn(filename: *const cty::c_char)>,
    #[doc = "! Called from GX2DebugCaptureEnd."]
    pub onCaptureEnd: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "! Check if capture is enabled."]
    pub isCaptureEnabled: ::core::option::Option<unsafe extern "C" fn() -> BOOL>,
    #[doc = "! Called when GX2 memory is allocated."]
    pub onAlloc:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut cty::c_void, size: u32, align: u32)>,
    #[doc = "! Called when GX2 memory is freed."]
    pub onFree: ::core::option::Option<unsafe extern "C" fn(ptr: *mut cty::c_void)>,
    #[doc = "! UNKNOWN: Called when something happens with some memory."]
    pub onUnknownMemory:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut cty::c_void, size: u32)>,
    #[doc = "! Called from GX2DebugCaptureStart with the TV scan buffer."]
    pub setOutputSurface: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    #[doc = "! Called from GX2SwapScanBuffers with the TV scan buffer."]
    pub onSwapScanBuffers: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    #[doc = "! Called when a command buffer is ready to be submitted to ring buffer."]
    #[doc = "! Note that it seems we must call TCLSubmitToRing from this callback"]
    #[doc = "! because gx2 will not do it when capturing."]
    pub submitToRing: ::core::option::Option<
        unsafe extern "C" fn(
            unk1: *mut cty::c_void,
            unk2: u32,
            unk3: *mut u32,
            outSubmitTimestamp: *mut u64,
        ),
    >,
}
#[test]
fn bindgen_test_layout_GX2DebugCaptureInterface() {
    assert_eq!(
        ::core::mem::size_of::<GX2DebugCaptureInterface>(),
        48usize,
        concat!("Size of: ", stringify!(GX2DebugCaptureInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2DebugCaptureInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2DebugCaptureInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).onShutdown as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(onShutdown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).setAllocator as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(setAllocator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).onCaptureStart as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(onCaptureStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).onCaptureEnd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(onCaptureEnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).isCaptureEnabled as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(isCaptureEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).onAlloc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(onAlloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).onFree as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(onFree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).onUnknownMemory as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(onUnknownMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).setOutputSurface as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(setOutputSurface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).onSwapScanBuffers as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(onSwapScanBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DebugCaptureInterface>())).submitToRing as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DebugCaptureInterface),
            "::",
            stringify!(submitToRing)
        )
    );
}
extern "C" {
    pub fn _GX2DebugSetCaptureInterface(interface: *mut GX2DebugCaptureInterface) -> BOOL;
}
extern "C" {
    #[doc = " Starts a debug capture."]
    #[doc = ""]
    #[doc = " User must have set interface first via _GX2DebugSetCaptureInterface."]
    #[doc = ""]
    #[doc = " Note this doesn't write to filename, that is up to the implementor of the"]
    #[doc = " GX2DebugCaptureInterface. This argument might not even be filename but I at"]
    #[doc = " least know it is a string because GX2DebugCaptureFrame does a strncpy on it."]
    #[doc = ""]
    #[doc = " \\param filename"]
    #[doc = " This is passed as first argument to GX2DebugCaptureInterface.onCaptureStart"]
    pub fn GX2DebugCaptureStart(
        filename: *const cty::c_char,
        flags: GX2DebugCaptureStartFlags::Type,
    );
}
extern "C" {
    #[doc = " Ends a debug capture."]
    pub fn GX2DebugCaptureEnd(flags: GX2DebugCaptureEndFlags::Type);
}
extern "C" {
    #[doc = " Will capture the next frame."]
    #[doc = ""]
    #[doc = " Capture begins during the next call to GX2SwapScanBuffers, and will end"]
    #[doc = " at the next GX2SwapScanBuffers."]
    #[doc = ""]
    #[doc = " Equivalent to calling GX2DebugCaptureFrames(filename, 1)"]
    pub fn GX2DebugCaptureFrame(filename: *const cty::c_char);
}
extern "C" {
    #[doc = " Will capture count frames."]
    #[doc = ""]
    #[doc = " Capture begins during the next call to GX2SwapScanBuffers, and will end"]
    #[doc = " after count frames have been swapped in GX2SwapScanBuffers."]
    #[doc = ""]
    #[doc = " Capture begins and ends during GX2SwapScanBuffers."]
    pub fn GX2DebugCaptureFrames(filename: *const cty::c_char, count: u32);
}
extern "C" {
    pub fn GX2SetTVEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2SetDRCEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2CalcTVSize(
        tvRenderMode: GX2TVRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
        size: *mut u32,
        unkOut: *mut u32,
    );
}
extern "C" {
    pub fn GX2CalcDRCSize(
        drcRenderMode: GX2DrcRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
        size: *mut u32,
        unkOut: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetTVBuffer(
        buffer: *mut cty::c_void,
        size: u32,
        tvRenderMode: GX2TVRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
    );
}
extern "C" {
    pub fn GX2SetDRCBuffer(
        buffer: *mut cty::c_void,
        size: u32,
        drcRenderMode: GX2DrcRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
    );
}
extern "C" {
    pub fn GX2SetTVScale(x: u32, y: u32);
}
extern "C" {
    pub fn GX2SetDRCScale(x: u32, y: u32);
}
extern "C" {
    pub fn GX2GetSystemTVScanMode() -> GX2TVScanMode::Type;
}
extern "C" {
    pub fn GX2GetSystemDRCScanMode() -> GX2DrcRenderMode::Type;
}
extern "C" {
    pub fn GX2GetSystemDRCMode() -> GX2DrcRenderMode::Type;
}
extern "C" {
    pub fn GX2BeginDisplayListEx(displayList: *mut cty::c_void, bytes: u32, unk1: BOOL);
}
extern "C" {
    pub fn GX2EndDisplayList(displayList: *mut cty::c_void) -> u32;
}
extern "C" {
    pub fn GX2DirectCallDisplayList(displayList: *const cty::c_void, bytes: u32);
}
extern "C" {
    pub fn GX2CallDisplayList(displayList: *const cty::c_void, bytes: u32);
}
extern "C" {
    pub fn GX2GetDisplayListWriteStatus() -> BOOL;
}
extern "C" {
    pub fn GX2GetCurrentDisplayList(
        outDisplayList: *mut *mut cty::c_void,
        outSize: *mut u32,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2CopyDisplayList(displayList: *const cty::c_void, bytes: u32);
}
extern "C" {
    pub fn GX2SetAttribBuffer(index: u32, size: u32, stride: u32, buffer: *const cty::c_void);
}
extern "C" {
    pub fn GX2DrawEx(mode: GX2PrimitiveMode::Type, count: u32, offset: u32, numInstances: u32);
}
extern "C" {
    pub fn GX2DrawEx2(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedEx(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const cty::c_void,
        offset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedEx2(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const cty::c_void,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedImmediateEx(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const cty::c_void,
        offset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2SetPrimitiveRestartIndex(index: u32);
}
pub type GX2EventCallbackFunction =
    ::core::option::Option<unsafe extern "C" fn(arg1: GX2EventType::Type, arg2: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DisplayListOverrunData {
    #[doc = "! Pointer to overrun display list"]
    pub oldList: *mut cty::c_void,
    #[doc = "! Size of overrun display list"]
    pub oldSize: u32,
    #[doc = "! Pointer to new display list"]
    pub newList: *mut cty::c_void,
    #[doc = "! Size of new display list"]
    pub newSize: u32,
    pub __unk48: [cty::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_GX2DisplayListOverrunData() {
    assert_eq!(
        ::core::mem::size_of::<GX2DisplayListOverrunData>(),
        24usize,
        concat!("Size of: ", stringify!(GX2DisplayListOverrunData))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2DisplayListOverrunData>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2DisplayListOverrunData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DisplayListOverrunData>())).oldList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DisplayListOverrunData),
            "::",
            stringify!(oldList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DisplayListOverrunData>())).oldSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DisplayListOverrunData),
            "::",
            stringify!(oldSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DisplayListOverrunData>())).newList as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DisplayListOverrunData),
            "::",
            stringify!(newList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DisplayListOverrunData>())).newSize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DisplayListOverrunData),
            "::",
            stringify!(newSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DisplayListOverrunData>())).__unk48 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DisplayListOverrunData),
            "::",
            stringify!(__unk48)
        )
    );
}
extern "C" {
    pub fn GX2DrawDone() -> BOOL;
}
extern "C" {
    pub fn GX2WaitForVsync();
}
extern "C" {
    pub fn GX2WaitForFlip();
}
extern "C" {
    pub fn GX2SetEventCallback(
        type_: GX2EventType::Type,
        func: GX2EventCallbackFunction,
        userData: *mut cty::c_void,
    );
}
extern "C" {
    pub fn GX2GetEventCallback(
        type_: GX2EventType::Type,
        funcOut: *mut GX2EventCallbackFunction,
        userDataOut: *mut *mut cty::c_void,
    );
}
extern "C" {
    pub fn GX2GetRetiredTimeStamp() -> OSTime;
}
extern "C" {
    pub fn GX2GetLastSubmittedTimeStamp() -> OSTime;
}
extern "C" {
    pub fn GX2GetSwapStatus(
        swapCount: *mut u32,
        flipCount: *mut u32,
        lastFlip: *mut OSTime,
        lastVsync: *mut OSTime,
    );
}
extern "C" {
    pub fn GX2WaitTimeStamp(time: OSTime) -> BOOL;
}
extern "C" {
    pub fn GX2Invalidate(mode: GX2InvalidateMode::Type, buffer: *mut cty::c_void, size: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AAMaskReg {
    pub pa_sc_aa_mask: u32,
}
#[test]
fn bindgen_test_layout_GX2AAMaskReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2AAMaskReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2AAMaskReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2AAMaskReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2AAMaskReg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AAMaskReg>())).pa_sc_aa_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AAMaskReg),
            "::",
            stringify!(pa_sc_aa_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AlphaTestReg {
    pub sx_alpha_test_control: u32,
    pub sx_alpha_ref: u32,
}
#[test]
fn bindgen_test_layout_GX2AlphaTestReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2AlphaTestReg>(),
        8usize,
        concat!("Size of: ", stringify!(GX2AlphaTestReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2AlphaTestReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2AlphaTestReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2AlphaTestReg>())).sx_alpha_test_control as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AlphaTestReg),
            "::",
            stringify!(sx_alpha_test_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AlphaTestReg>())).sx_alpha_ref as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AlphaTestReg),
            "::",
            stringify!(sx_alpha_ref)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AlphaToMaskReg {
    pub db_alpha_to_mask: u32,
}
#[test]
fn bindgen_test_layout_GX2AlphaToMaskReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2AlphaToMaskReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2AlphaToMaskReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2AlphaToMaskReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2AlphaToMaskReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2AlphaToMaskReg>())).db_alpha_to_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AlphaToMaskReg),
            "::",
            stringify!(db_alpha_to_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2BlendControlReg {
    pub target: GX2RenderTarget::Type,
    pub cb_blend_control: u32,
}
#[test]
fn bindgen_test_layout_GX2BlendControlReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2BlendControlReg>(),
        8usize,
        concat!("Size of: ", stringify!(GX2BlendControlReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2BlendControlReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2BlendControlReg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2BlendControlReg>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2BlendControlReg),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2BlendControlReg>())).cb_blend_control as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2BlendControlReg),
            "::",
            stringify!(cb_blend_control)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2BlendConstantColorReg {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
#[test]
fn bindgen_test_layout_GX2BlendConstantColorReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2BlendConstantColorReg>(),
        16usize,
        concat!("Size of: ", stringify!(GX2BlendConstantColorReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2BlendConstantColorReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2BlendConstantColorReg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2BlendConstantColorReg>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2BlendConstantColorReg),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2BlendConstantColorReg>())).green as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2BlendConstantColorReg),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2BlendConstantColorReg>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2BlendConstantColorReg),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2BlendConstantColorReg>())).alpha as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2BlendConstantColorReg),
            "::",
            stringify!(alpha)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ColorControlReg {
    pub cb_color_control: u32,
}
#[test]
fn bindgen_test_layout_GX2ColorControlReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2ColorControlReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2ColorControlReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2ColorControlReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2ColorControlReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ColorControlReg>())).cb_color_control as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ColorControlReg),
            "::",
            stringify!(cb_color_control)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DepthStencilControlReg {
    pub db_depth_control: u32,
}
#[test]
fn bindgen_test_layout_GX2DepthStencilControlReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2DepthStencilControlReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2DepthStencilControlReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2DepthStencilControlReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2DepthStencilControlReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2DepthStencilControlReg>())).db_depth_control as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2DepthStencilControlReg),
            "::",
            stringify!(db_depth_control)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2StencilMaskReg {
    pub db_stencilrefmask: u32,
    pub db_stencilrefmask_bf: u32,
}
#[test]
fn bindgen_test_layout_GX2StencilMaskReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2StencilMaskReg>(),
        8usize,
        concat!("Size of: ", stringify!(GX2StencilMaskReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2StencilMaskReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2StencilMaskReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2StencilMaskReg>())).db_stencilrefmask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2StencilMaskReg),
            "::",
            stringify!(db_stencilrefmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2StencilMaskReg>())).db_stencilrefmask_bf as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2StencilMaskReg),
            "::",
            stringify!(db_stencilrefmask_bf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2LineWidthReg {
    pub pa_su_line_cntl: u32,
}
#[test]
fn bindgen_test_layout_GX2LineWidthReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2LineWidthReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2LineWidthReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2LineWidthReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2LineWidthReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2LineWidthReg>())).pa_su_line_cntl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2LineWidthReg),
            "::",
            stringify!(pa_su_line_cntl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PointSizeReg {
    pub pa_su_point_size: u32,
}
#[test]
fn bindgen_test_layout_GX2PointSizeReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2PointSizeReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2PointSizeReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2PointSizeReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2PointSizeReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PointSizeReg>())).pa_su_point_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PointSizeReg),
            "::",
            stringify!(pa_su_point_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PointLimitsReg {
    pub pa_su_point_minmax: u32,
}
#[test]
fn bindgen_test_layout_GX2PointLimitsReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2PointLimitsReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2PointLimitsReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2PointLimitsReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2PointLimitsReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PointLimitsReg>())).pa_su_point_minmax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PointLimitsReg),
            "::",
            stringify!(pa_su_point_minmax)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PolygonControlReg {
    pub pa_su_sc_mode_cntl: u32,
}
#[test]
fn bindgen_test_layout_GX2PolygonControlReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2PolygonControlReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2PolygonControlReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2PolygonControlReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2PolygonControlReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PolygonControlReg>())).pa_su_sc_mode_cntl as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PolygonControlReg),
            "::",
            stringify!(pa_su_sc_mode_cntl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PolygonOffsetReg {
    pub pa_su_poly_offset_front_scale: u32,
    pub pa_su_poly_offset_front_offset: u32,
    pub pa_su_poly_offset_back_scale: u32,
    pub pa_su_poly_offset_back_offset: u32,
    pub pa_su_poly_offset_clamp: u32,
}
#[test]
fn bindgen_test_layout_GX2PolygonOffsetReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2PolygonOffsetReg>(),
        20usize,
        concat!("Size of: ", stringify!(GX2PolygonOffsetReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2PolygonOffsetReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2PolygonOffsetReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PolygonOffsetReg>())).pa_su_poly_offset_front_scale
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PolygonOffsetReg),
            "::",
            stringify!(pa_su_poly_offset_front_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PolygonOffsetReg>())).pa_su_poly_offset_front_offset
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PolygonOffsetReg),
            "::",
            stringify!(pa_su_poly_offset_front_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PolygonOffsetReg>())).pa_su_poly_offset_back_scale
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PolygonOffsetReg),
            "::",
            stringify!(pa_su_poly_offset_back_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PolygonOffsetReg>())).pa_su_poly_offset_back_offset
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PolygonOffsetReg),
            "::",
            stringify!(pa_su_poly_offset_back_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PolygonOffsetReg>())).pa_su_poly_offset_clamp as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PolygonOffsetReg),
            "::",
            stringify!(pa_su_poly_offset_clamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ScissorReg {
    pub pa_sc_generic_scissor_tl: u32,
    pub pa_sc_generic_scissor_br: u32,
}
#[test]
fn bindgen_test_layout_GX2ScissorReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2ScissorReg>(),
        8usize,
        concat!("Size of: ", stringify!(GX2ScissorReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2ScissorReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2ScissorReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ScissorReg>())).pa_sc_generic_scissor_tl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ScissorReg),
            "::",
            stringify!(pa_sc_generic_scissor_tl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ScissorReg>())).pa_sc_generic_scissor_br as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ScissorReg),
            "::",
            stringify!(pa_sc_generic_scissor_br)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2TargetChannelMaskReg {
    pub cb_target_mask: u32,
}
#[test]
fn bindgen_test_layout_GX2TargetChannelMaskReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2TargetChannelMaskReg>(),
        4usize,
        concat!("Size of: ", stringify!(GX2TargetChannelMaskReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2TargetChannelMaskReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2TargetChannelMaskReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2TargetChannelMaskReg>())).cb_target_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2TargetChannelMaskReg),
            "::",
            stringify!(cb_target_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ViewportReg {
    pub pa_cl_vport_xscale: u32,
    pub pa_cl_vport_xoffset: u32,
    pub pa_cl_vport_yscale: u32,
    pub pa_cl_vport_yoffset: u32,
    pub pa_cl_vport_zscale: u32,
    pub pa_cl_vport_zoffset: u32,
    pub pa_cl_gb_vert_clip_adj: u32,
    pub pa_cl_gb_vert_disc_adj: u32,
    pub pa_cl_gb_horz_clip_adj: u32,
    pub pa_cl_gb_horz_disc_adj: u32,
    pub pa_sc_vport_zmin: u32,
    pub pa_sc_vport_zmax: u32,
}
#[test]
fn bindgen_test_layout_GX2ViewportReg() {
    assert_eq!(
        ::core::mem::size_of::<GX2ViewportReg>(),
        48usize,
        concat!("Size of: ", stringify!(GX2ViewportReg))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2ViewportReg>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2ViewportReg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_vport_xscale as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_vport_xscale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_vport_xoffset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_vport_xoffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_vport_yscale as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_vport_yscale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_vport_yoffset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_vport_yoffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_vport_zscale as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_vport_zscale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_vport_zoffset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_vport_zoffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_gb_vert_clip_adj as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_gb_vert_clip_adj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_gb_vert_disc_adj as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_gb_vert_disc_adj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_gb_horz_clip_adj as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_gb_horz_clip_adj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_cl_gb_horz_disc_adj as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_cl_gb_horz_disc_adj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_sc_vport_zmin as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_sc_vport_zmin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2ViewportReg>())).pa_sc_vport_zmax as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2ViewportReg),
            "::",
            stringify!(pa_sc_vport_zmax)
        )
    );
}
extern "C" {
    pub fn GX2SetAAMask(upperLeft: u8, upperRight: u8, lowerLeft: u8, lowerRight: u8);
}
extern "C" {
    pub fn GX2InitAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: u8,
        upperRight: u8,
        lowerLeft: u8,
        lowerRight: u8,
    );
}
extern "C" {
    pub fn GX2GetAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: *mut u8,
        upperRight: *mut u8,
        lowerLeft: *mut u8,
        lowerRight: *mut u8,
    );
}
extern "C" {
    pub fn GX2SetAAMaskReg(reg: *const GX2AAMaskReg);
}
extern "C" {
    pub fn GX2SetAlphaTest(alphaTest: BOOL, func: GX2CompareFunction::Type, ref_: f32);
}
extern "C" {
    pub fn GX2InitAlphaTestReg(
        reg: *mut GX2AlphaTestReg,
        alphaTest: BOOL,
        func: GX2CompareFunction::Type,
        ref_: f32,
    );
}
extern "C" {
    pub fn GX2GetAlphaTestReg(
        reg: *const GX2AlphaTestReg,
        alphaTest: *mut BOOL,
        func: *mut GX2CompareFunction::Type,
        ref_: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetAlphaTestReg(reg: *const GX2AlphaTestReg);
}
extern "C" {
    pub fn GX2SetAlphaToMask(alphaToMask: BOOL, mode: GX2AlphaToMaskMode::Type);
}
extern "C" {
    pub fn GX2InitAlphaToMaskReg(
        reg: *mut GX2AlphaToMaskReg,
        alphaToMask: BOOL,
        mode: GX2AlphaToMaskMode::Type,
    );
}
extern "C" {
    pub fn GX2GetAlphaToMaskReg(
        reg: *const GX2AlphaToMaskReg,
        alphaToMask: *mut BOOL,
        mode: *mut GX2AlphaToMaskMode::Type,
    );
}
extern "C" {
    pub fn GX2SetAlphaToMaskReg(reg: *const GX2AlphaToMaskReg);
}
extern "C" {
    pub fn GX2SetBlendConstantColor(red: f32, green: f32, blue: f32, alpha: f32);
}
extern "C" {
    pub fn GX2InitBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
}
extern "C" {
    pub fn GX2GetBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: *mut f32,
        green: *mut f32,
        blue: *mut f32,
        alpha: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetBlendConstantColorReg(reg: *const GX2BlendConstantColorReg);
}
extern "C" {
    pub fn GX2SetBlendControl(
        target: GX2RenderTarget::Type,
        colorSrcBlend: GX2BlendMode::Type,
        colorDstBlend: GX2BlendMode::Type,
        colorCombine: GX2BlendCombineMode::Type,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode::Type,
        alphaDstBlend: GX2BlendMode::Type,
        alphaCombine: GX2BlendCombineMode::Type,
    );
}
extern "C" {
    pub fn GX2InitBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: GX2RenderTarget::Type,
        colorSrcBlend: GX2BlendMode::Type,
        colorDstBlend: GX2BlendMode::Type,
        colorCombine: GX2BlendCombineMode::Type,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode::Type,
        alphaDstBlend: GX2BlendMode::Type,
        alphaCombine: GX2BlendCombineMode::Type,
    );
}
extern "C" {
    pub fn GX2GetBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: *mut GX2RenderTarget::Type,
        colorSrcBlend: *mut GX2BlendMode::Type,
        colorDstBlend: *mut GX2BlendMode::Type,
        colorCombine: *mut GX2BlendCombineMode::Type,
        useAlphaBlend: *mut BOOL,
        alphaSrcBlend: *mut GX2BlendMode::Type,
        alphaDstBlend: *mut GX2BlendMode::Type,
        alphaCombine: *mut GX2BlendCombineMode::Type,
    );
}
extern "C" {
    pub fn GX2SetBlendControlReg(reg: *const GX2BlendControlReg);
}
extern "C" {
    pub fn GX2SetColorControl(
        rop3: GX2LogicOp::Type,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2InitColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: GX2LogicOp::Type,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2GetColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: *mut GX2LogicOp::Type,
        targetBlendEnable: *mut u8,
        multiWriteEnable: *mut BOOL,
        colorWriteEnable: *mut BOOL,
    );
}
extern "C" {
    pub fn GX2SetColorControlReg(reg: *const GX2ColorControlReg);
}
extern "C" {
    pub fn GX2SetDepthOnlyControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
    );
}
extern "C" {
    pub fn GX2SetDepthStencilControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction::Type,
        frontStencilZPass: GX2StencilFunction::Type,
        frontStencilZFail: GX2StencilFunction::Type,
        frontStencilFail: GX2StencilFunction::Type,
        backStencilFunc: GX2CompareFunction::Type,
        backStencilZPass: GX2StencilFunction::Type,
        backStencilZFail: GX2StencilFunction::Type,
        backStencilFail: GX2StencilFunction::Type,
    );
}
extern "C" {
    pub fn GX2InitDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction::Type,
        frontStencilZPass: GX2StencilFunction::Type,
        frontStencilZFail: GX2StencilFunction::Type,
        frontStencilFail: GX2StencilFunction::Type,
        backStencilFunc: GX2CompareFunction::Type,
        backStencilZPass: GX2StencilFunction::Type,
        backStencilZFail: GX2StencilFunction::Type,
        backStencilFail: GX2StencilFunction::Type,
    );
}
extern "C" {
    pub fn GX2GetDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: *mut BOOL,
        depthWrite: *mut BOOL,
        depthCompare: *mut GX2CompareFunction::Type,
        stencilTest: *mut BOOL,
        backfaceStencil: *mut BOOL,
        frontStencilFunc: *mut GX2CompareFunction::Type,
        frontStencilZPass: *mut GX2StencilFunction::Type,
        frontStencilZFail: *mut GX2StencilFunction::Type,
        frontStencilFail: *mut GX2StencilFunction::Type,
        backStencilFunc: *mut GX2CompareFunction::Type,
        backStencilZPass: *mut GX2StencilFunction::Type,
        backStencilZFail: *mut GX2StencilFunction::Type,
        backStencilFail: *mut GX2StencilFunction::Type,
    );
}
extern "C" {
    pub fn GX2SetDepthStencilControlReg(reg: *const GX2DepthStencilControlReg);
}
extern "C" {
    pub fn GX2SetStencilMask(
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
}
extern "C" {
    pub fn GX2InitStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
}
extern "C" {
    pub fn GX2GetStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: *mut u8,
        frontWriteMask: *mut u8,
        frontRef: *mut u8,
        backMask: *mut u8,
        backWriteMask: *mut u8,
        backRef: *mut u8,
    );
}
extern "C" {
    pub fn GX2SetStencilMaskReg(reg: *const GX2StencilMaskReg);
}
extern "C" {
    pub fn GX2SetLineWidth(width: f32);
}
extern "C" {
    pub fn GX2InitLineWidthReg(reg: *mut GX2LineWidthReg, width: f32);
}
extern "C" {
    pub fn GX2GetLineWidthReg(reg: *mut GX2LineWidthReg, width: *mut f32);
}
extern "C" {
    pub fn GX2SetLineWidthReg(reg: *const GX2LineWidthReg);
}
extern "C" {
    pub fn GX2SetPointSize(width: f32, height: f32);
}
extern "C" {
    pub fn GX2InitPointSizeReg(reg: *mut GX2PointSizeReg, width: f32, height: f32);
}
extern "C" {
    pub fn GX2GetPointSizeReg(reg: *mut GX2PointSizeReg, width: *mut f32, height: *mut f32);
}
extern "C" {
    pub fn GX2SetPointSizeReg(reg: *const GX2PointSizeReg);
}
extern "C" {
    pub fn GX2SetPointLimits(min: f32, max: f32);
}
extern "C" {
    pub fn GX2InitPointLimitsReg(reg: *mut GX2PointLimitsReg, min: f32, max: f32);
}
extern "C" {
    pub fn GX2GetPointLimitsReg(reg: *mut GX2PointLimitsReg, min: *mut f32, max: *mut f32);
}
extern "C" {
    pub fn GX2SetPointLimitsReg(reg: *const GX2PointLimitsReg);
}
extern "C" {
    pub fn GX2SetCullOnlyControl(frontFace: GX2FrontFace::Type, cullFront: BOOL, cullBack: BOOL);
}
extern "C" {
    pub fn GX2SetPolygonControl(
        frontFace: GX2FrontFace::Type,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode::Type,
        polyModeBack: GX2PolygonMode::Type,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2InitPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: GX2FrontFace::Type,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode::Type,
        polyModeBack: GX2PolygonMode::Type,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2GetPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: *mut GX2FrontFace::Type,
        cullFront: *mut BOOL,
        cullBack: *mut BOOL,
        polyMode: *mut BOOL,
        polyModeFront: *mut GX2PolygonMode::Type,
        polyModeBack: *mut GX2PolygonMode::Type,
        polyOffsetFrontEnable: *mut BOOL,
        polyOffsetBackEnable: *mut BOOL,
        polyOffsetParaEnable: *mut BOOL,
    );
}
extern "C" {
    pub fn GX2SetPolygonControlReg(reg: *const GX2PolygonControlReg);
}
extern "C" {
    pub fn GX2SetPolygonOffset(
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
}
extern "C" {
    pub fn GX2InitPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
}
extern "C" {
    pub fn GX2GetPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: *mut f32,
        frontScale: *mut f32,
        backOffset: *mut f32,
        backScale: *mut f32,
        clamp: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetPolygonOffsetReg(reg: *const GX2PolygonOffsetReg);
}
extern "C" {
    pub fn GX2SetScissor(x: u32, y: u32, width: u32, height: u32);
}
extern "C" {
    pub fn GX2InitScissorReg(reg: *mut GX2ScissorReg, x: u32, y: u32, width: u32, height: u32);
}
extern "C" {
    pub fn GX2GetScissorReg(
        reg: *mut GX2ScissorReg,
        x: *mut u32,
        y: *mut u32,
        width: *mut u32,
        height: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetScissorReg(reg: *const GX2ScissorReg);
}
extern "C" {
    pub fn GX2SetTargetChannelMasks(
        mask0: GX2ChannelMask::Type,
        mask1: GX2ChannelMask::Type,
        mask2: GX2ChannelMask::Type,
        mask3: GX2ChannelMask::Type,
        mask4: GX2ChannelMask::Type,
        mask5: GX2ChannelMask::Type,
        mask6: GX2ChannelMask::Type,
        mask7: GX2ChannelMask::Type,
    );
}
extern "C" {
    pub fn GX2InitTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: GX2ChannelMask::Type,
        mask1: GX2ChannelMask::Type,
        mask2: GX2ChannelMask::Type,
        mask3: GX2ChannelMask::Type,
        mask4: GX2ChannelMask::Type,
        mask5: GX2ChannelMask::Type,
        mask6: GX2ChannelMask::Type,
        mask7: GX2ChannelMask::Type,
    );
}
extern "C" {
    pub fn GX2GetTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: *mut GX2ChannelMask::Type,
        mask1: *mut GX2ChannelMask::Type,
        mask2: *mut GX2ChannelMask::Type,
        mask3: *mut GX2ChannelMask::Type,
        mask4: *mut GX2ChannelMask::Type,
        mask5: *mut GX2ChannelMask::Type,
        mask6: *mut GX2ChannelMask::Type,
        mask7: *mut GX2ChannelMask::Type,
    );
}
extern "C" {
    pub fn GX2SetTargetChannelMasksReg(reg: *const GX2TargetChannelMaskReg);
}
extern "C" {
    pub fn GX2SetViewport(x: f32, y: f32, width: f32, height: f32, nearZ: f32, farZ: f32);
}
extern "C" {
    pub fn GX2InitViewportReg(
        reg: *mut GX2ViewportReg,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        nearZ: f32,
        farZ: f32,
    );
}
extern "C" {
    pub fn GX2GetViewportReg(
        reg: *mut GX2ViewportReg,
        x: *mut f32,
        y: *mut f32,
        width: *mut f32,
        height: *mut f32,
        nearZ: *mut f32,
        farZ: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetViewportReg(reg: *const GX2ViewportReg);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2Sampler {
    pub regs: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_GX2Sampler() {
    assert_eq!(
        ::core::mem::size_of::<GX2Sampler>(),
        12usize,
        concat!("Size of: ", stringify!(GX2Sampler))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2Sampler>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2Sampler))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Sampler>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Sampler),
            "::",
            stringify!(regs)
        )
    );
}
extern "C" {
    pub fn GX2InitSampler(
        sampler: *mut GX2Sampler,
        clampMode: GX2TexClampMode::Type,
        minMagFilterMode: GX2TexXYFilterMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerBorderType(sampler: *mut GX2Sampler, borderType: GX2TexBorderType::Type);
}
extern "C" {
    pub fn GX2InitSamplerClamping(
        sampler: *mut GX2Sampler,
        clampX: GX2TexClampMode::Type,
        clampY: GX2TexClampMode::Type,
        clampZ: GX2TexClampMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerDepthCompare(
        sampler: *mut GX2Sampler,
        depthCompare: GX2CompareFunction::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerFilterAdjust(
        sampler: *mut GX2Sampler,
        highPrecision: BOOL,
        perfMip: GX2TexMipPerfMode::Type,
        perfZ: GX2TexZPerfMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerLOD(sampler: *mut GX2Sampler, lodMin: f32, lodMax: f32, lodBias: f32);
}
extern "C" {
    pub fn GX2InitSamplerLODAdjust(sampler: *mut GX2Sampler, unk1: f32, unk2: BOOL);
}
extern "C" {
    pub fn GX2InitSamplerRoundingMode(
        sampler: *mut GX2Sampler,
        roundingMode: GX2RoundingMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerXYFilter(
        sampler: *mut GX2Sampler,
        filterMag: GX2TexXYFilterMode::Type,
        filterMin: GX2TexXYFilterMode::Type,
        maxAniso: GX2TexAnisoRatio::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerZMFilter(
        sampler: *mut GX2Sampler,
        filterZ: GX2TexZFilterMode::Type,
        filterMip: GX2TexMipFilterMode::Type,
    );
}
pub type wint_t = cty::c_int;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type __blkcnt_t = cty::c_long;
pub type __blksize_t = cty::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = cty::c_int;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = cty::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = cty::c_long;
pub type __size_t = cty::c_ulong;
pub type _ssize_t = cty::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _iconv_t = *mut cty::c_void;
pub type __clock_t = cty::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = cty::c_ulong;
pub type __timer_t = cty::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = cty::c_int;
pub type __nlink_t = cty::c_ushort;
pub type __suseconds_t = cty::c_long;
pub type __useconds_t = cty::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = cty::c_ulong;
pub type _LOCK_T = cty::c_int;
pub type _LOCK_RECURSIVE_T = cty::c_int;
extern "C" {
    pub fn __libc_lock_init(arg1: *mut cty::c_int, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn __libc_lock_close(arg1: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn __libc_lock_acquire(arg1: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire(arg1: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn __libc_lock_release(arg1: *mut cty::c_int) -> cty::c_int;
}
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: cty::c_int,
    pub _maxwds: cty::c_int,
    pub _sign: cty::c_int,
    pub _wds: cty::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._k as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._maxwds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._sign as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._wds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: cty::c_int,
    pub __tm_min: cty::c_int,
    pub __tm_hour: cty::c_int,
    pub __tm_mday: cty::c_int,
    pub __tm_mon: cty::c_int,
    pub __tm_year: cty::c_int,
    pub __tm_wday: cty::c_int,
    pub __tm_yday: cty::c_int,
    pub __tm_isdst: cty::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut cty::c_void; 32usize],
    pub _dso_handle: [*mut cty::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fnargs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._dso_handle as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fntypes as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._is_cxa as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: cty::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._ind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._fns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._on_exit_args as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut cty::c_uchar,
    pub _size: cty::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _cookie: *mut cty::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *mut cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: _fpos_t,
            arg4: cty::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut cty::c_uchar,
    pub _ur: cty::c_int,
    pub _ubuf: [cty::c_uchar; 3usize],
    pub _nbuf: [cty::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: cty::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: cty::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        112usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._r as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._file as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._read as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._write as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._close as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._up as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._data as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lock as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: cty::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._niobs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._iobs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [cty::c_ushort; 3usize],
    pub _mult: [cty::c_ushort; 3usize],
    pub _add: cty::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._mult as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._add as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: cty::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: cty::c_int,
    pub _emergency: [cty::c_char; 25usize],
    pub _unspecified_locale_info: cty::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: cty::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: cty::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: cty::c_int,
    pub _cvtbuf: *mut cty::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 30usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: cty::c_uint,
    pub _strtok_last: *mut cty::c_char,
    pub _asctime_buf: [cty::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: cty::c_int,
    pub _rand_next: cty::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [cty::c_char; 8usize],
    pub _signal_buf: [cty::c_char; 24usize],
    pub _getdate_err: cty::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: cty::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._unused_rand as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._strtok_last as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._asctime_buf as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._localtime_buf
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._gamma_signgam
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._rand_next as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._r48 as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mblen_state as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbtowc_state
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wctomb_state
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._l64a_buf as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._signal_buf as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._getdate_err as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrlen_state
                as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrtowc_state
                as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbsrtowcs_state
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcrtomb_state
                as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcsrtombs_state
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._h_errno as *const _
                as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut cty::c_uchar; 30usize],
    pub _nmalloc: [cty::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nextf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nmalloc as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._reent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1096usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._errno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stderr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._inc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._emergency as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent>()))._unspecified_locale_info as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._locale as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sdidinit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__cleanup as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result_k as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._p5s as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._freelist as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtlen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtbuf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit0 as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._sig_func as *const _ as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sglue as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sf as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).deviceData as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(deviceData)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const cty::c_void, arg2: *mut cty::c_void, arg3: size_t);
}
extern "C" {
    pub fn bzero(arg1: *mut cty::c_void, arg2: cty::c_ulong);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut cty::c_void, arg2: size_t);
}
extern "C" {
    pub fn ffs(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn fls(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn flsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn flsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn index(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const cty::c_void,
        arg2: cty::c_int,
        arg3: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(arg1: *mut cty::c_void, arg2: cty::c_int, arg3: cty::c_ulong)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strncat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strstr(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: cty::c_int, arg2: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_int,
        arg4: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn stpcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const cty::c_char, arg2: cty::c_ulong) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: size_t) -> cty::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: cty::c_int,
        arg4: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_ulong,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strnlen(arg1: *const cty::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__signo: cty::c_int) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2RBuffer {
    pub flags: GX2RResourceFlags::Type,
    pub elemSize: u32,
    pub elemCount: u32,
    pub buffer: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_GX2RBuffer() {
    assert_eq!(
        ::core::mem::size_of::<GX2RBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GX2RBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2RBuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2RBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2RBuffer>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2RBuffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2RBuffer>())).elemSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2RBuffer),
            "::",
            stringify!(elemSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2RBuffer>())).elemCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2RBuffer),
            "::",
            stringify!(elemCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2RBuffer>())).buffer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2RBuffer),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    pub fn GX2RBufferExists(buffer: *mut GX2RBuffer) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateBuffer(buffer: *mut GX2RBuffer) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateBufferUserMemory(
        buffer: *mut GX2RBuffer,
        memory: *mut cty::c_void,
        size: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RDestroyBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
}
extern "C" {
    pub fn GX2RGetBufferAlignment(flags: GX2RResourceFlags::Type) -> u32;
}
extern "C" {
    pub fn GX2RGetBufferAllocationSize(buffer: *mut GX2RBuffer) -> u32;
}
extern "C" {
    pub fn GX2RInvalidateBuffer(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
}
extern "C" {
    pub fn GX2RLockBufferEx(
        buffer: *mut GX2RBuffer,
        flags: GX2RResourceFlags::Type,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn GX2RUnlockBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
}
extern "C" {
    pub fn GX2RSetVertexUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
extern "C" {
    pub fn GX2RSetPixelUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
extern "C" {
    pub fn GX2RSetGeometryUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2FetchShader {
    pub type_: GX2FetchShaderType::Type,
    pub regs: GX2FetchShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut cty::c_void,
    pub attribCount: u32,
    pub numDivisors: u32,
    pub divisors: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2FetchShader__bindgen_ty_1 {
    pub sq_pgm_resources_fs: u32,
}
#[test]
fn bindgen_test_layout_GX2FetchShader__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GX2FetchShader__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GX2FetchShader__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2FetchShader__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2FetchShader__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2FetchShader__bindgen_ty_1>())).sq_pgm_resources_fs
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader__bindgen_ty_1),
            "::",
            stringify!(sq_pgm_resources_fs)
        )
    );
}
#[test]
fn bindgen_test_layout_GX2FetchShader() {
    assert_eq!(
        ::core::mem::size_of::<GX2FetchShader>(),
        32usize,
        concat!("Size of: ", stringify!(GX2FetchShader))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2FetchShader>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2FetchShader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2FetchShader>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2FetchShader>())).regs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2FetchShader>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2FetchShader>())).program as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader),
            "::",
            stringify!(program)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2FetchShader>())).attribCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader),
            "::",
            stringify!(attribCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2FetchShader>())).numDivisors as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader),
            "::",
            stringify!(numDivisors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2FetchShader>())).divisors as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2FetchShader),
            "::",
            stringify!(divisors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformBlock {
    pub name: *const cty::c_char,
    pub offset: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_GX2UniformBlock() {
    assert_eq!(
        ::core::mem::size_of::<GX2UniformBlock>(),
        12usize,
        concat!("Size of: ", stringify!(GX2UniformBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2UniformBlock>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2UniformBlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformBlock>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformBlock),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformBlock>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformBlock),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformBlock>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformBlock),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformVar {
    pub name: *const cty::c_char,
    pub type_: GX2ShaderVarType::Type,
    pub count: u32,
    pub offset: u32,
    pub block: i32,
}
#[test]
fn bindgen_test_layout_GX2UniformVar() {
    assert_eq!(
        ::core::mem::size_of::<GX2UniformVar>(),
        20usize,
        concat!("Size of: ", stringify!(GX2UniformVar))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2UniformVar>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2UniformVar))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformVar>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformVar),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformVar>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformVar),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformVar>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformVar),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformVar>())).offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformVar),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformVar>())).block as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformVar),
            "::",
            stringify!(block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformInitialValue {
    pub value: [f32; 4usize],
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_GX2UniformInitialValue() {
    assert_eq!(
        ::core::mem::size_of::<GX2UniformInitialValue>(),
        20usize,
        concat!("Size of: ", stringify!(GX2UniformInitialValue))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2UniformInitialValue>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2UniformInitialValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformInitialValue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformInitialValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2UniformInitialValue>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2UniformInitialValue),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2LoopVar {
    pub offset: u32,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_GX2LoopVar() {
    assert_eq!(
        ::core::mem::size_of::<GX2LoopVar>(),
        8usize,
        concat!("Size of: ", stringify!(GX2LoopVar))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2LoopVar>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2LoopVar))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2LoopVar>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2LoopVar),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2LoopVar>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2LoopVar),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2SamplerVar {
    pub name: *const cty::c_char,
    pub type_: GX2SamplerVarType::Type,
    pub location: u32,
}
#[test]
fn bindgen_test_layout_GX2SamplerVar() {
    assert_eq!(
        ::core::mem::size_of::<GX2SamplerVar>(),
        12usize,
        concat!("Size of: ", stringify!(GX2SamplerVar))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2SamplerVar>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2SamplerVar))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2SamplerVar>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2SamplerVar),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2SamplerVar>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2SamplerVar),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2SamplerVar>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2SamplerVar),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribVar {
    pub name: *const cty::c_char,
    pub type_: GX2ShaderVarType::Type,
    pub count: u32,
    pub location: u32,
}
#[test]
fn bindgen_test_layout_GX2AttribVar() {
    assert_eq!(
        ::core::mem::size_of::<GX2AttribVar>(),
        16usize,
        concat!("Size of: ", stringify!(GX2AttribVar))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2AttribVar>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2AttribVar))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribVar>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribVar),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribVar>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribVar),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribVar>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribVar),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribVar>())).location as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribVar),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2VertexShader {
    pub regs: GX2VertexShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut cty::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub attribVarCount: u32,
    pub attribVars: *mut GX2AttribVar,
    pub ringItemsize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2VertexShader__bindgen_ty_1 {
    pub sq_pgm_resources_vs: u32,
    pub vgt_primitiveid_en: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub pa_cl_vs_out_cntl: u32,
    pub sq_vtx_semantic_clear: u32,
    pub num_sq_vtx_semantic: u32,
    pub sq_vtx_semantic: [u32; 32usize],
    pub vgt_strmout_buffer_en: u32,
    pub vgt_vertex_reuse_block_cntl: u32,
    pub vgt_hos_reuse_depth: u32,
}
#[test]
fn bindgen_test_layout_GX2VertexShader__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GX2VertexShader__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(GX2VertexShader__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2VertexShader__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2VertexShader__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).sq_pgm_resources_vs
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(sq_pgm_resources_vs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).vgt_primitiveid_en
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(vgt_primitiveid_en)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).spi_vs_out_config as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(spi_vs_out_config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).num_spi_vs_out_id as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(num_spi_vs_out_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).spi_vs_out_id as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(spi_vs_out_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).pa_cl_vs_out_cntl as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(pa_cl_vs_out_cntl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).sq_vtx_semantic_clear
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(sq_vtx_semantic_clear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).num_sq_vtx_semantic
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(num_sq_vtx_semantic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).sq_vtx_semantic as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(sq_vtx_semantic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).vgt_strmout_buffer_en
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(vgt_strmout_buffer_en)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).vgt_vertex_reuse_block_cntl
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(vgt_vertex_reuse_block_cntl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader__bindgen_ty_1>())).vgt_hos_reuse_depth
                as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader__bindgen_ty_1),
            "::",
            stringify!(vgt_hos_reuse_depth)
        )
    );
}
#[test]
fn bindgen_test_layout_GX2VertexShader() {
    assert_eq!(
        ::core::mem::size_of::<GX2VertexShader>(),
        308usize,
        concat!("Size of: ", stringify!(GX2VertexShader))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2VertexShader>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2VertexShader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).size as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).program as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(program)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).mode as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader>())).uniformBlockCount as *const _ as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(uniformBlockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).uniformBlocks as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(uniformBlocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader>())).uniformVarCount as *const _ as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(uniformVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).uniformVars as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(uniformVars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader>())).initialValueCount as *const _ as usize
        },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(initialValueCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).initialValues as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(initialValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).loopVarCount as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(loopVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).loopVars as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(loopVars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader>())).samplerVarCount as *const _ as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(samplerVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).samplerVars as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(samplerVars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).attribVarCount as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(attribVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).attribVars as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(attribVars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).ringItemsize as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(ringItemsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).hasStreamOut as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(hasStreamOut)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2VertexShader>())).streamOutStride as *const _ as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(streamOutStride)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2VertexShader>())).gx2rBuffer as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2VertexShader),
            "::",
            stringify!(gx2rBuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PixelShader {
    pub regs: GX2PixelShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut cty::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PixelShader__bindgen_ty_1 {
    pub sq_pgm_resources_ps: u32,
    pub sq_pgm_exports_ps: u32,
    pub spi_ps_in_control_0: u32,
    pub spi_ps_in_control_1: u32,
    pub num_spi_ps_input_cntl: u32,
    pub spi_ps_input_cntls: [u32; 32usize],
    pub cb_shader_mask: u32,
    pub cb_shader_control: u32,
    pub db_shader_control: u32,
    pub spi_input_z: u32,
}
#[test]
fn bindgen_test_layout_GX2PixelShader__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GX2PixelShader__bindgen_ty_1>(),
        164usize,
        concat!("Size of: ", stringify!(GX2PixelShader__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2PixelShader__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2PixelShader__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).sq_pgm_resources_ps
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(sq_pgm_resources_ps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).sq_pgm_exports_ps as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(sq_pgm_exports_ps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).spi_ps_in_control_0
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(spi_ps_in_control_0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).spi_ps_in_control_1
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(spi_ps_in_control_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).num_spi_ps_input_cntl
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(num_spi_ps_input_cntl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).spi_ps_input_cntls as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(spi_ps_input_cntls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).cb_shader_mask as *const _
                as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(cb_shader_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).cb_shader_control as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(cb_shader_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).db_shader_control as *const _
                as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(db_shader_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader__bindgen_ty_1>())).spi_input_z as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader__bindgen_ty_1),
            "::",
            stringify!(spi_input_z)
        )
    );
}
#[test]
fn bindgen_test_layout_GX2PixelShader() {
    assert_eq!(
        ::core::mem::size_of::<GX2PixelShader>(),
        232usize,
        concat!("Size of: ", stringify!(GX2PixelShader))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2PixelShader>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2PixelShader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).size as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).program as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(program)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).mode as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader>())).uniformBlockCount as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(uniformBlockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).uniformBlocks as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(uniformBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).uniformVarCount as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(uniformVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).uniformVars as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(uniformVars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2PixelShader>())).initialValueCount as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(initialValueCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).initialValues as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(initialValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).loopVarCount as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(loopVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).loopVars as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(loopVars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).samplerVarCount as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(samplerVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).samplerVars as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(samplerVars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2PixelShader>())).gx2rBuffer as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2PixelShader),
            "::",
            stringify!(gx2rBuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2GeometryShader {
    pub regs: GX2GeometryShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut cty::c_void,
    pub vertexProgramSize: u32,
    pub vertexProgram: *mut cty::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub ringItemSize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2GeometryShader__bindgen_ty_1 {
    pub sq_pgm_resources_gs: u32,
    pub vgt_gs_out_prim_type: u32,
    pub vgt_gs_mode: u32,
    pub pa_cl_vs_out_cntl: u32,
    pub sq_pgm_resources_vs: u32,
    pub sq_gs_vert_itemsize: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub vgt_strmout_buffer_en: u32,
}
#[test]
fn bindgen_test_layout_GX2GeometryShader__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GX2GeometryShader__bindgen_ty_1>(),
        76usize,
        concat!("Size of: ", stringify!(GX2GeometryShader__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2GeometryShader__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2GeometryShader__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).sq_pgm_resources_gs
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(sq_pgm_resources_gs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).vgt_gs_out_prim_type
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(vgt_gs_out_prim_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).vgt_gs_mode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(vgt_gs_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).pa_cl_vs_out_cntl
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(pa_cl_vs_out_cntl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).sq_pgm_resources_vs
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(sq_pgm_resources_vs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).sq_gs_vert_itemsize
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(sq_gs_vert_itemsize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).spi_vs_out_config
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(spi_vs_out_config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).num_spi_vs_out_id
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(num_spi_vs_out_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).spi_vs_out_id as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(spi_vs_out_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader__bindgen_ty_1>())).vgt_strmout_buffer_en
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader__bindgen_ty_1),
            "::",
            stringify!(vgt_strmout_buffer_en)
        )
    );
}
#[test]
fn bindgen_test_layout_GX2GeometryShader() {
    assert_eq!(
        ::core::mem::size_of::<GX2GeometryShader>(),
        176usize,
        concat!("Size of: ", stringify!(GX2GeometryShader))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2GeometryShader>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2GeometryShader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).program as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(program)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).vertexProgramSize as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(vertexProgramSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).vertexProgram as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(vertexProgram)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).mode as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).uniformBlockCount as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(uniformBlockCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).uniformBlocks as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(uniformBlocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).uniformVarCount as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(uniformVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).uniformVars as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(uniformVars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).initialValueCount as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(initialValueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).initialValues as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(initialValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).loopVarCount as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(loopVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).loopVars as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(loopVars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).samplerVarCount as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(samplerVarCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).samplerVars as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(samplerVars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).ringItemSize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(ringItemSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).hasStreamOut as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(hasStreamOut)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<GX2GeometryShader>())).streamOutStride as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(streamOutStride)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2GeometryShader>())).gx2rBuffer as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2GeometryShader),
            "::",
            stringify!(gx2rBuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribStream {
    pub location: u32,
    pub buffer: u32,
    pub offset: u32,
    pub format: GX2AttribFormat::Type,
    pub type_: GX2AttribIndexType::Type,
    pub aluDivisor: u32,
    pub mask: u32,
    pub endianSwap: GX2EndianSwapMode::Type,
}
#[test]
fn bindgen_test_layout_GX2AttribStream() {
    assert_eq!(
        ::core::mem::size_of::<GX2AttribStream>(),
        32usize,
        concat!("Size of: ", stringify!(GX2AttribStream))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2AttribStream>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2AttribStream))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).buffer as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).aluDivisor as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(aluDivisor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2AttribStream>())).endianSwap as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2AttribStream),
            "::",
            stringify!(endianSwap)
        )
    );
}
extern "C" {
    pub fn GX2CalcGeometryShaderInputRingBufferSize(ringItemSize: u32) -> u32;
}
extern "C" {
    pub fn GX2CalcGeometryShaderOutputRingBufferSize(ringItemSize: u32) -> u32;
}
extern "C" {
    pub fn GX2CalcFetchShaderSizeEx(
        attribs: u32,
        fetchShaderType: GX2FetchShaderType::Type,
        tesellationMode: GX2TessellationMode::Type,
    ) -> u32;
}
extern "C" {
    pub fn GX2InitFetchShaderEx(
        fetchShader: *mut GX2FetchShader,
        buffer: *mut u8,
        attribCount: u32,
        attribs: *const GX2AttribStream,
        type_: GX2FetchShaderType::Type,
        tessMode: GX2TessellationMode::Type,
    );
}
extern "C" {
    pub fn GX2SetFetchShader(shader: *const GX2FetchShader);
}
extern "C" {
    pub fn GX2SetVertexShader(shader: *const GX2VertexShader);
}
extern "C" {
    pub fn GX2SetPixelShader(shader: *const GX2PixelShader);
}
extern "C" {
    pub fn GX2SetGeometryShader(shader: *const GX2GeometryShader);
}
extern "C" {
    pub fn GX2SetVertexSampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetPixelSampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetGeometrySampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetVertexUniformReg(offset: u32, count: u32, data: *const cty::c_void);
}
extern "C" {
    pub fn GX2SetPixelUniformReg(offset: u32, count: u32, data: *const cty::c_void);
}
extern "C" {
    pub fn GX2SetVertexUniformBlock(location: u32, size: u32, data: *const cty::c_void);
}
extern "C" {
    pub fn GX2SetPixelUniformBlock(location: u32, size: u32, data: *const cty::c_void);
}
extern "C" {
    pub fn GX2SetGeometryUniformBlock(location: u32, size: u32, data: *const cty::c_void);
}
extern "C" {
    pub fn GX2SetShaderModeEx(
        mode: GX2ShaderMode::Type,
        numVsGpr: u32,
        numVsStackEntries: u32,
        numGsGpr: u32,
        numGsStackEntries: u32,
        numPsGpr: u32,
        numPsStackEntries: u32,
    );
}
extern "C" {
    pub fn GX2SetStreamOutEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2SetGeometryShaderInputRingBuffer(buffer: *const cty::c_void, size: u32);
}
extern "C" {
    pub fn GX2SetGeometryShaderOutputRingBuffer(buffer: *mut cty::c_void, size: u32);
}
extern "C" {
    pub fn GX2GetPixelShaderGPRs(shader: *const GX2PixelShader) -> u32;
}
extern "C" {
    pub fn GX2GetPixelShaderStackEntries(shader: *const GX2PixelShader) -> u32;
}
extern "C" {
    pub fn GX2GetVertexShaderGPRs(shader: *const GX2VertexShader) -> u32;
}
extern "C" {
    pub fn GX2GetVertexShaderStackEntries(shader: *const GX2VertexShader) -> u32;
}
extern "C" {
    pub fn GX2GetGeometryShaderGPRs(shader: *const GX2GeometryShader) -> u32;
}
extern "C" {
    pub fn GX2GetGeometryShaderStackEntries(shader: *const GX2GeometryShader) -> u32;
}
extern "C" {
    pub fn GX2Init(attributes: *mut u32);
}
extern "C" {
    pub fn GX2Shutdown();
}
extern "C" {
    pub fn GX2Flush();
}
extern "C" {
    pub fn GX2ResetGPU(unknown: u32);
}
extern "C" {
    pub fn GX2CopyColorBufferToScanBuffer(
        buffer: *const GX2ColorBuffer,
        scanTarget: GX2ScanTarget::Type,
    );
}
extern "C" {
    pub fn GX2SwapScanBuffers();
}
extern "C" {
    pub fn GX2GetLastFrame(scanTarget: GX2ScanTarget::Type, texture: *mut GX2Texture) -> BOOL;
}
extern "C" {
    pub fn GX2GetLastFrameGamma(scanTarget: GX2ScanTarget::Type, gammaOut: *mut f32) -> BOOL;
}
extern "C" {
    pub fn GX2GetSwapInterval() -> u32;
}
extern "C" {
    pub fn GX2SetSwapInterval(interval: u32);
}
extern "C" {
    pub fn GX2TempGetGPUVersion() -> u32;
}
extern "C" {
    pub fn GX2SetTessellation(
        tessellationMode: GX2TessellationMode::Type,
        primitiveMode: GX2PrimitiveMode::Type,
        indexType: GX2IndexType::Type,
    );
}
extern "C" {
    pub fn GX2SetMinTessellationLevel(min: f32);
}
extern "C" {
    pub fn GX2SetMaxTessellationLevel(max: f32);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Texture {
    pub surface: GX2Surface,
    pub viewFirstMip: u32,
    pub viewNumMips: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub compMap: u32,
    pub regs: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_GX2Texture() {
    assert_eq!(
        ::core::mem::size_of::<GX2Texture>(),
        156usize,
        concat!("Size of: ", stringify!(GX2Texture))
    );
    assert_eq!(
        ::core::mem::align_of::<GX2Texture>(),
        4usize,
        concat!("Alignment of ", stringify!(GX2Texture))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Texture>())).surface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Texture),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Texture>())).viewFirstMip as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Texture),
            "::",
            stringify!(viewFirstMip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Texture>())).viewNumMips as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Texture),
            "::",
            stringify!(viewNumMips)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Texture>())).viewFirstSlice as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Texture),
            "::",
            stringify!(viewFirstSlice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Texture>())).viewNumSlices as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Texture),
            "::",
            stringify!(viewNumSlices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Texture>())).compMap as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Texture),
            "::",
            stringify!(compMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GX2Texture>())).regs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GX2Texture),
            "::",
            stringify!(regs)
        )
    );
}
extern "C" {
    pub fn GX2InitTextureRegs(texture: *mut GX2Texture);
}
extern "C" {
    pub fn GX2SetPixelTexture(texture: *const GX2Texture, unit: u32);
}
extern "C" {
    pub fn GX2SetVertexTexture(texture: *const GX2Texture, unit: u32);
}
extern "C" {
    pub fn GX2SetGeometryTexture(texture: *const GX2Texture, unit: u32);
}
pub mod GX2_SQ_SEL {
    pub type Type = cty::c_uint;
    pub const GX2_SQ_SEL_X: Type = 0;
    pub const GX2_SQ_SEL_Y: Type = 1;
    pub const GX2_SQ_SEL_Z: Type = 2;
    pub const GX2_SQ_SEL_W: Type = 3;
    pub const GX2_SQ_SEL_R: Type = 0;
    pub const GX2_SQ_SEL_G: Type = 1;
    pub const GX2_SQ_SEL_B: Type = 2;
    pub const GX2_SQ_SEL_A: Type = 3;
    pub const GX2_SQ_SEL_0: Type = 4;
    pub const GX2_SQ_SEL_1: Type = 5;
    pub const GX2_SQ_SEL_MASK: Type = 7;
}
extern "C" {
    pub fn GX2RBeginDisplayListEx(
        displayList: *mut GX2RBuffer,
        unknown: u32,
        flags: GX2RResourceFlags::Type,
    );
}
extern "C" {
    pub fn GX2REndDisplayList(displayList: *mut GX2RBuffer) -> u32;
}
extern "C" {
    pub fn GX2RCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
}
extern "C" {
    pub fn GX2RDirectCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
}
extern "C" {
    pub fn GX2RSetAttributeBuffer(buffer: *mut GX2RBuffer, index: u32, stride: u32, offset: u32);
}
extern "C" {
    pub fn GX2RDrawIndexed(
        mode: GX2PrimitiveMode::Type,
        buffer: *mut GX2RBuffer,
        indexType: GX2IndexType::Type,
        count: u32,
        indexOffset: u32,
        vertexOffset: u32,
        numInstances: u32,
    );
}
pub type GX2RAllocFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2RResourceFlags::Type, arg2: u32, arg3: u32) -> *mut cty::c_void,
>;
pub type GX2RFreeFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2RResourceFlags::Type, arg2: *mut cty::c_void),
>;
extern "C" {
    pub fn GX2RInvalidateMemory(
        flags: GX2RResourceFlags::Type,
        buffer: *mut cty::c_void,
        size: u32,
    );
}
extern "C" {
    pub fn GX2RIsUserMemory(flags: GX2RResourceFlags::Type) -> BOOL;
}
extern "C" {
    pub fn GX2RSetAllocator(allocFn: GX2RAllocFunction, freeFn: GX2RFreeFunction);
}
extern "C" {
    pub fn GX2RCreateSurface(surface: *mut GX2Surface, flags: GX2RResourceFlags::Type) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateSurfaceUserMemory(
        surface: *mut GX2Surface,
        image: *mut u8,
        mipmap: *mut u8,
        flags: GX2RResourceFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RDestroySurfaceEx(surface: *mut GX2Surface, flags: GX2RResourceFlags::Type) -> BOOL;
}
extern "C" {
    pub fn GX2RInvalidateSurface(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RLockSurfaceEx(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn GX2RUnlockSurfaceEx(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    );
}
pub type H264DECFptrOutputFn =
    ::core::option::Option<unsafe extern "C" fn(output: *mut H264DecodeOutput)>;
pub mod H264Error {
    #[doc = "! h264 library errors."]
    pub type Type = cty::c_uint;
    #[doc = "! No errors."]
    pub const H264_ERROR_OK: Type = 0;
    #[doc = "! Invalid picture parameter set."]
    pub const H264_ERROR_INVALID_PPS: Type = 24;
    #[doc = "! Invalid sequence parameter set."]
    pub const H264_ERROR_INVALID_SPS: Type = 26;
    #[doc = "! Invalid slice header."]
    pub const H264_ERROR_INVALID_SLICEHEADER: Type = 61;
    #[doc = "! Generic h264 error."]
    pub const H264_ERROR_GENERIC: Type = 16777216;
    #[doc = "! Invalid parameters passed."]
    pub const H264_ERROR_INVALID_PARAMETER: Type = 16842752;
    #[doc = "! The amount of memory provided to the h264 library"]
    #[doc = "! is insufficient."]
    pub const H264_ERROR_OUT_OF_MEMORY: Type = 16908288;
    #[doc = "! Invalid h264 stream profile. Only the baseline (66),"]
    #[doc = "! main (77) and high (100) profiles are allowed."]
    pub const H264_ERROR_INVALID_PROFILE: Type = 17301504;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodedVuiParameters {
    pub aspect_ratio_info_present_flag: u8,
    pub aspect_ratio_idc: u8,
    pub sar_width: i16,
    pub sar_height: i16,
    pub overscan_info_present_flag: u8,
    pub overscan_appropriate_flag: u8,
    pub video_signal_type_present_flag: u8,
    pub video_format: u8,
    pub video_full_range_flag: u8,
    pub colour_description_present_flag: u8,
    pub colour_primaries: u8,
    pub transfer_characteristics: u8,
    pub matrix_coefficients: u8,
    pub chroma_loc_info_present_flag: u8,
    pub chroma_sample_loc_type_top_field: u8,
    pub chroma_sample_loc_type_bottom_field: u8,
    pub timing_info_present_flag: u8,
    pub __unk49: [cty::c_char; 1usize],
    pub num_units_in_tick: u32,
    pub time_scale: u32,
    pub fixed_frame_rate_flag: u8,
    pub nal_hrd_parameters_present_flag: u8,
    pub vcl_hrd_parameters_present_flag: u8,
    pub low_delay_hrd_flag: u8,
    pub pic_struct_present_flag: u8,
    pub bitstream_restriction_flag: u8,
    pub motion_vectors_over_pic_boundaries_flag: u8,
    pub __unk50: [cty::c_char; 1usize],
    pub max_bytes_per_pic_denom: i16,
    pub max_bits_per_mb_denom: i16,
    pub log2_max_mv_length_horizontal: i16,
    pub log2_max_mv_length_vertical: i16,
    pub num_reorder_frames: i16,
    pub max_dec_frame_buffering: i16,
}
#[test]
fn bindgen_test_layout_H264DecodedVuiParameters() {
    assert_eq!(
        ::core::mem::size_of::<H264DecodedVuiParameters>(),
        48usize,
        concat!("Size of: ", stringify!(H264DecodedVuiParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<H264DecodedVuiParameters>(),
        1usize,
        concat!("Alignment of ", stringify!(H264DecodedVuiParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).aspect_ratio_info_present_flag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(aspect_ratio_info_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).aspect_ratio_idc as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(aspect_ratio_idc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).sar_width as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(sar_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).sar_height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(sar_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).overscan_info_present_flag
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(overscan_info_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).overscan_appropriate_flag
                as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(overscan_appropriate_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).video_signal_type_present_flag
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(video_signal_type_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).video_format as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(video_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).video_full_range_flag as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(video_full_range_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).colour_description_present_flag
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(colour_description_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).colour_primaries as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(colour_primaries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).transfer_characteristics
                as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(transfer_characteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).matrix_coefficients as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(matrix_coefficients)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).chroma_loc_info_present_flag
                as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(chroma_loc_info_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).chroma_sample_loc_type_top_field
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(chroma_sample_loc_type_top_field)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>()))
                .chroma_sample_loc_type_bottom_field as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(chroma_sample_loc_type_bottom_field)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).timing_info_present_flag
                as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(timing_info_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).__unk49 as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(__unk49)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).num_units_in_tick as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(num_units_in_tick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).time_scale as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(time_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).fixed_frame_rate_flag as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(fixed_frame_rate_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).nal_hrd_parameters_present_flag
                as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(nal_hrd_parameters_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).vcl_hrd_parameters_present_flag
                as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(vcl_hrd_parameters_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).low_delay_hrd_flag as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(low_delay_hrd_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).pic_struct_present_flag
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(pic_struct_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).bitstream_restriction_flag
                as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(bitstream_restriction_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>()))
                .motion_vectors_over_pic_boundaries_flag as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(motion_vectors_over_pic_boundaries_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).__unk50 as *const _ as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(__unk50)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).max_bytes_per_pic_denom
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(max_bytes_per_pic_denom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).max_bits_per_mb_denom as *const _
                as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(max_bits_per_mb_denom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).log2_max_mv_length_horizontal
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(log2_max_mv_length_horizontal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).log2_max_mv_length_vertical
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(log2_max_mv_length_vertical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).num_reorder_frames as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(num_reorder_frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodedVuiParameters>())).max_dec_frame_buffering
                as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodedVuiParameters),
            "::",
            stringify!(max_dec_frame_buffering)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct H264DecodeResult {
    pub status: i32,
    pub __unk51: [cty::c_char; 4usize],
    pub timestamp: f64,
    pub width: i32,
    pub height: i32,
    pub nextLine: i32,
    pub cropEnableFlag: u8,
    pub __unk52: [cty::c_char; 3usize],
    pub cropTop: i32,
    pub cropBottom: i32,
    pub cropLeft: i32,
    pub cropRight: i32,
    pub panScanEnableFlag: u8,
    pub __unk53: [cty::c_char; 3usize],
    pub panScanTop: i32,
    pub panScanBottom: i32,
    pub panScanLeft: i32,
    pub panScanRight: i32,
    pub framebuffer: *mut cty::c_void,
    pub vui_parameters_present_flag: u8,
    pub __unk54: [cty::c_char; 3usize],
    pub vui_parameters: *mut H264DecodedVuiParameters,
    pub __unk55: [cty::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_H264DecodeResult() {
    assert_eq!(
        ::core::mem::size_of::<H264DecodeResult>(),
        120usize,
        concat!("Size of: ", stringify!(H264DecodeResult))
    );
    assert_eq!(
        ::core::mem::align_of::<H264DecodeResult>(),
        1usize,
        concat!("Alignment of ", stringify!(H264DecodeResult))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).__unk51 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(__unk51)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).nextLine as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(nextLine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodeResult>())).cropEnableFlag as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(cropEnableFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).__unk52 as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(__unk52)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).cropTop as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(cropTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).cropBottom as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(cropBottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).cropLeft as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(cropLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).cropRight as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(cropRight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodeResult>())).panScanEnableFlag as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(panScanEnableFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).__unk53 as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(__unk53)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).panScanTop as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(panScanTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).panScanBottom as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(panScanBottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).panScanLeft as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(panScanLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).panScanRight as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(panScanRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).framebuffer as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodeResult>())).vui_parameters_present_flag as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(vui_parameters_present_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).__unk54 as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(__unk54)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<H264DecodeResult>())).vui_parameters as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(vui_parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeResult>())).__unk55 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeResult),
            "::",
            stringify!(__unk55)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodeOutput {
    #[doc = "! Number of frames output"]
    pub frameCount: i32,
    #[doc = "! Frames"]
    pub decodeResults: *mut *mut H264DecodeResult,
    #[doc = "! User memory pointer passed into SetParam"]
    pub userMemory: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_H264DecodeOutput() {
    assert_eq!(
        ::core::mem::size_of::<H264DecodeOutput>(),
        12usize,
        concat!("Size of: ", stringify!(H264DecodeOutput))
    );
    assert_eq!(
        ::core::mem::align_of::<H264DecodeOutput>(),
        1usize,
        concat!("Alignment of ", stringify!(H264DecodeOutput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeOutput>())).frameCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeOutput),
            "::",
            stringify!(frameCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeOutput>())).decodeResults as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeOutput),
            "::",
            stringify!(decodeResults)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<H264DecodeOutput>())).userMemory as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(H264DecodeOutput),
            "::",
            stringify!(userMemory)
        )
    );
}
extern "C" {
    #[doc = " Check that the stream contains sufficient data to decode an entire frame."]
    pub fn H264DECCheckDecunitLength(
        memory: *mut cty::c_void,
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outLength: *mut i32,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Check if the next NALU can be skipped without breaking decoding."]
    pub fn H264DECCheckSkipableFrame(
        buffer: *const u8,
        bufferLength: i32,
        outSkippable: *mut BOOL,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Find the first SPS in the stream."]
    pub fn H264DECFindDecstartpoint(
        buffer: *const u8,
        bufferLength: i32,
        outOffset: *mut i32,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Find the first \"IDR point\" in the stream."]
    #[doc = ""]
    #[doc = " An IDR point is either:"]
    #[doc = "  - If an SPS or PPS header is found before the IDR and there are no non-IDR"]
    #[doc = "    inbetween the SPS/PPS and IDR then return the first of the SPS/PPS."]
    #[doc = "  - The first found IDR."]
    pub fn H264DECFindIdrpoint(buffer: *const u8, bufferLength: i32, outOffset: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Parse the H264 stream and read the width & height from the first found SPS."]
    pub fn H264DECGetImageSize(
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outWidth: *mut i32,
        outHeight: *mut i32,
    ) -> H264Error::Type;
}
pub mod H264Parameter {
    #[doc = "! h264 decoder parameters for H264DECSetParam."]
    pub type Type = cty::c_uint;
    #[doc = "! Set the callback which is called when a frame is output from the decoder."]
    pub const H264_PARAMETER_FRAME_POINTER_OUTPUT: Type = 1;
    #[doc = "! Set whether the decoder should internally buffer frames or call the callback"]
    #[doc = "! immediately as soon as a frame is emitted."]
    pub const H264_PARAMETER_OUTPUT_PER_FRAME: Type = 536870914;
    #[doc = "! Set whether the decoder should internally buffer frames or call the callback"]
    #[doc = "! immediately as soon as a frame is emitted."]
    pub const H264_PARAMETER_UNKNOWN_20000010: Type = 536870928;
    #[doc = "! Set whether the decoder should internally buffer frames or call the callback"]
    #[doc = "! immediately as soon as a frame is emitted."]
    pub const H264_PARAMETER_UNKNOWN_20000030: Type = 536870960;
    #[doc = "! Set whether the decoder should internally buffer frames or call the callback"]
    #[doc = "! immediately as soon as a frame is emitted."]
    pub const H264_PARAMETER_UNKNOWN_20000040: Type = 536870976;
    #[doc = "! Set a user memory pointer which is passed to the frame output callback."]
    pub const H264_PARAMETER_USER_MEMORY: Type = 1879048193;
}
extern "C" {
    #[doc = " Calculate the amount of memory required for the specified parameters."]
    pub fn H264DECMemoryRequirement(
        profile: i32,
        level: i32,
        maxWidth: i32,
        maxHeight: i32,
        outMemoryRequirement: *mut u32,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Initialise a H264 decoder in the given memory."]
    pub fn H264DECInitParam(memorySize: i32, memory: *mut cty::c_void) -> H264Error::Type;
}
extern "C" {
    #[doc = " Set H264 decoder parameter."]
    pub fn H264DECSetParam(
        memory: *mut cty::c_void,
        parameter: H264Parameter::Type,
        value: *mut cty::c_void,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Set the callback which is called when a frame is output from the decoder."]
    pub fn H264DECSetParam_FPTR_OUTPUT(
        memory: *mut cty::c_void,
        value: H264DECFptrOutputFn,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Set whether the decoder should internally buffer frames or call the callback"]
    #[doc = " immediately as soon as a frame is emitted."]
    pub fn H264DECSetParam_OUTPUT_PER_FRAME(
        memory: *mut cty::c_void,
        value: u32,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Set a user memory pointer which is passed to the frame output callback."]
    pub fn H264DECSetParam_USER_MEMORY(
        memory: *mut cty::c_void,
        value: *mut cty::c_void,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Check if the provided memory can be used for decoding."]
    pub fn H264DECCheckMemSegmentation(memory: *mut cty::c_void, size: u32) -> H264Error::Type;
}
extern "C" {
    #[doc = " Open a H264 decoder."]
    pub fn H264DECOpen(memory: *mut cty::c_void) -> H264Error::Type;
}
extern "C" {
    #[doc = " Prepare for decoding."]
    pub fn H264DECBegin(memory: *mut cty::c_void) -> H264Error::Type;
}
extern "C" {
    #[doc = " Set the bit stream to be read for decoding."]
    pub fn H264DECSetBitstream(
        memory: *mut cty::c_void,
        buffer: *mut u8,
        bufferLength: u32,
        timestamp: f64,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Perform decoding of the bitstream and put the output frame into frameBuffer."]
    pub fn H264DECExecute(
        memory: *mut cty::c_void,
        frameBuffer: *mut cty::c_void,
    ) -> H264Error::Type;
}
extern "C" {
    #[doc = " Flush any internally buffered frames."]
    pub fn H264DECFlush(memory: *mut cty::c_void) -> H264Error::Type;
}
extern "C" {
    #[doc = " End decoding of the current stream."]
    pub fn H264DECEnd(memory: *mut cty::c_void) -> H264Error::Type;
}
extern "C" {
    #[doc = " Cleanup the decoder."]
    pub fn H264DECClose(memory: *mut cty::c_void) -> H264Error::Type;
}
#[doc = " Result structure for nn libraries"]
#[doc = " <!--"]
#[doc = "    TODO: the actual bitfield stuff?"]
#[doc = " -->"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NNResult {
    #[doc = "! Aggregate value of result bitfield"]
    pub value: i32,
}
#[test]
fn bindgen_test_layout_NNResult() {
    assert_eq!(
        ::core::mem::size_of::<NNResult>(),
        4usize,
        concat!("Size of: ", stringify!(NNResult))
    );
    assert_eq!(
        ::core::mem::align_of::<NNResult>(),
        4usize,
        concat!("Alignment of ", stringify!(NNResult))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NNResult>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NNResult),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " An ID number representing a network configuration. These are the same IDs as"]
#[doc = " shown in System Settings' Connection List."]
pub type ACConfigId = u32;
extern "C" {
    #[doc = " Initialise the Auto Connect library. Call this function before any other AC"]
    #[doc = " functions."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " A \\link nn_result Result\\endlink - see \\link NNResult_IsSuccess \\endlink"]
    #[doc = " and \\link NNResult_IsFailure \\endlink."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\link ACFinalize \\endlink"]
    pub fn ACInitialize() -> NNResult;
}
extern "C" {
    #[doc = " Cleanup the Auto Connect library. Do not call any AC functions (other than"]
    #[doc = " \\link ACInitialize \\endlink) after calling this function."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\link ACInitialize \\endlink"]
    pub fn ACFinalize();
}
extern "C" {
    #[doc = " Gets the default connection configuration id. This is the default as marked"]
    #[doc = " in System Settings."]
    #[doc = ""]
    #[doc = " \\param configId"]
    #[doc = " A pointer to an \\link ACConfigId \\endlink to write the config ID to. Must not"]
    #[doc = " be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " A \\link nn_result Result\\endlink - see \\link NNResult_IsSuccess \\endlink"]
    #[doc = " and \\link NNResult_IsFailure \\endlink."]
    pub fn ACGetStartupId(configId: *mut ACConfigId) -> NNResult;
}
extern "C" {
    #[doc = " Connects to a network, using the configuration represented by the given"]
    #[doc = " \\link ACConfigId \\endlink."]
    #[doc = ""]
    #[doc = " \\param configId"]
    #[doc = " The \\link ACConfigId \\endlink representing the network to connect to."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " A \\link nn_result Result\\endlink - see \\link NNResult_IsSuccess \\endlink"]
    #[doc = " and \\link NNResult_IsFailure \\endlink."]
    pub fn ACConnectWithConfigId(configId: ACConfigId) -> NNResult;
}
extern "C" {
    #[doc = " Gets the IP address assosciated with the currently active connection."]
    #[doc = ""]
    #[doc = " \\param ip"]
    #[doc = " A pointer to write the IP address to, in"]
    #[doc = " <a href=\"https://en.wikipedia.org/wiki/IPv4#Address_representations\""]
    #[doc = " target=\"_blank\">numerical</a> form."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " A \\link nn_result Result\\endlink - see \\link NNResult_IsSuccess \\endlink"]
    #[doc = " and \\link NNResult_IsFailure \\endlink."]
    pub fn ACGetAssignedAddress(ip: *mut u32) -> NNResult;
}
pub mod ACPResult {
    #[doc = " \\defgroup nn_acp_result Result"]
    #[doc = " \\ingroup nn_acp"]
    #[doc = " Result codes used by nn_acp"]
    #[doc = " @{"]
    pub type Type = cty::c_int;
    pub const ACP_RESULT_SUCCESS: Type = 0;
    pub const ACP_RESULT_INVALID: Type = -200;
    pub const ACP_RESULT_INVALID_PARAMETER: Type = -201;
    pub const ACP_RESULT_INVALID_FILE: Type = -202;
    pub const ACP_RESULT_INVALID_XML_FILE: Type = -203;
    pub const ACP_RESULT_FILE_ACCESS_MODE: Type = -204;
    pub const ACP_RESULT_INVALID_NETWORK_TIME: Type = -205;
    pub const ACP_RESULT_NOT_FOUND: Type = -500;
    pub const ACP_RESULT_FILE_NOT_FOUND: Type = -501;
    pub const ACP_RESULT_DIR_NOT_FOUND: Type = -502;
    pub const ACP_RESULT_DEVICE_NOT_FOUND: Type = -503;
    pub const ACP_RESULT_TITLE_NOT_FOUND: Type = -504;
    pub const ACP_RESULT_APPLICATION_NOT_FOUND: Type = -505;
    pub const ACP_RESULT_SYSTEM_CONFIG_NOT_FOUND: Type = -506;
    pub const ACP_RESULT_XML_ITEM_NOT_FOUND: Type = -507;
    pub const ACP_RESULT_ALREADY_EXISTS: Type = -600;
    pub const ACP_RESULT_FILE_ALREADY_EXISTS: Type = -601;
    pub const ACP_RESULT_DIR_ALREADY_EXISTS: Type = -602;
    pub const ACP_RESULT_ALREADY_DONE: Type = -700;
    pub const ACP_RESULT_AUTHENTICATION: Type = -1000;
    pub const ACP_RESULT_INVALID_REGION: Type = -1001;
    pub const ACP_RESULT_RESTRICTED_RATING: Type = -1002;
    pub const ACP_RESULT_NOT_PRESENT_RATING: Type = -1003;
    pub const ACP_RESULT_PENDING_RATING: Type = -1004;
    pub const ACP_RESULT_NET_SETTING_REQUIRED: Type = -1005;
    pub const ACP_RESULT_NET_ACCOUNT_REQUIRED: Type = -1006;
    pub const ACP_RESULT_NET_ACCOUNT_ERROR: Type = -1007;
    pub const ACP_RESULT_BROWSER_REQUIRED: Type = -1008;
    pub const ACP_RESULT_OLV_REQUIRED: Type = -1009;
    pub const ACP_RESULT_PINCODE_REQUIRED: Type = -1010;
    pub const ACP_RESULT_INCORRECT_PINCODE: Type = -1011;
    pub const ACP_RESULT_INVALID_LOGO: Type = -1012;
    pub const ACP_RESULT_DEMO_EXPIRED_NUMBER: Type = -1013;
    pub const ACP_RESULT_DRC_REQUIRED: Type = -1014;
    pub const ACP_RESULT_NO_PERMISSION: Type = -1100;
    pub const ACP_RESULT_NO_FILE_PERMISSION: Type = -1101;
    pub const ACP_RESULT_NO_DIR_PERMISSION: Type = -1102;
    pub const ACP_RESULT_BUSY: Type = -1300;
    pub const ACP_RESULT_USB_STORAGE_NOT_READY: Type = -1301;
    pub const ACP_RESULT_CANCELLED: Type = -1400;
    pub const ACP_RESULT_RESOURCE: Type = -1500;
    pub const ACP_RESULT_DEVICE_FULL: Type = -1501;
    pub const ACP_RESULT_JOURNAL_FULL: Type = -1502;
    pub const ACP_RESULT_SYSTEM_MEMORY: Type = -1503;
    pub const ACP_RESULT_FS_RESOURCE: Type = -1504;
    pub const ACP_RESULT_IPC_RESOURCE: Type = -1505;
    pub const ACP_RESULT_NOT_INITIALISED: Type = -1600;
    pub const ACP_RESULT_ACCOUNT_ERROR: Type = -1700;
    pub const ACP_RESULT_UNSUPPORTED: Type = -1800;
    pub const ACP_RESULT_DATA_CORRUPTED: Type = -2000;
    pub const ACP_RESULT_DEVICE: Type = -2001;
    pub const ACP_RESULT_SLC_DATA_CORRUPTED: Type = -2002;
    pub const ACP_RESULT_MLC_DATA_CORRUPTED: Type = -2003;
    pub const ACP_RESULT_USB_DATA_CORRUPTED: Type = -2004;
    pub const ACP_RESULT_MEDIA: Type = -2100;
    pub const ACP_RESULT_MEDIA_NOT_READY: Type = -2101;
    pub const ACP_RESULT_MEDIA_BROKEN: Type = -2102;
    pub const ACP_RESULT_ODD_MEDIA_NOT_READY: Type = -2103;
    pub const ACP_RESULT_ODD_MEDIA_BROKEN: Type = -2104;
    pub const ACP_RESULT_USB_MEDIA_NOT_READY: Type = -2105;
    pub const ACP_RESULT_USB_MEDIA_BROKEN: Type = -2106;
    pub const ACP_RESULT_MEDIA_WRITE_PROTECTED: Type = -2107;
    pub const ACP_RESULT_USB_WRITE_PROTECTED: Type = -2108;
    pub const ACP_RESULT_MII: Type = -2200;
    pub const ACP_RESULT_ENCRYPTION_ERROR: Type = -2201;
    pub const ACP_RESULT_GENERIC_ERROR: Type = -4096;
}
pub type ACPDeviceType = i32;
extern "C" {
    pub fn ACPCheckApplicationDeviceEmulation(emulation: *mut BOOL) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPCreateSaveDir(persistentId: u32, deviceType: ACPDeviceType) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPIsExternalStorageRequired(required: *mut BOOL) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPMountExternalStorage() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPMountSaveDir() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPRepairSaveMetaDir() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPUnmountExternalStorage() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPUnmountSaveDir() -> ACPResult::Type;
}
pub type ACPTitleId = u64;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ACPMetaXml {
    pub title_id: u64,
    pub boss_id: u64,
    pub os_version: u64,
    pub app_size: u64,
    pub common_save_size: u64,
    pub account_save_size: u64,
    pub common_boss_size: u64,
    pub account_boss_size: u64,
    pub join_game_mode_mask: u64,
    pub version: u32,
    pub product_code: [cty::c_char; 32usize],
    pub content_platform: [cty::c_char; 32usize],
    pub company_code: [cty::c_char; 8usize],
    pub mastering_date: [cty::c_char; 32usize],
    pub logo_type: u32,
    pub app_launch_type: u32,
    pub invisible_flag: u32,
    pub no_managed_flag: u32,
    pub no_event_log: u32,
    pub no_icon_database: u32,
    pub launching_flag: u32,
    pub install_flag: u32,
    pub closing_msg: u32,
    pub title_version: u32,
    pub group_id: u32,
    pub save_no_rollback: u32,
    pub bg_daemon_enable: u32,
    pub join_game_id: u32,
    pub olv_accesskey: u32,
    pub wood_tin: u32,
    pub e_manual: u32,
    pub e_manual_version: u32,
    pub region: u32,
    pub pc_cero: u32,
    pub pc_esrb: u32,
    pub pc_bbfc: u32,
    pub pc_usk: u32,
    pub pc_pegi_gen: u32,
    pub pc_pegi_fin: u32,
    pub pc_pegi_prt: u32,
    pub pc_pegi_bbfc: u32,
    pub pc_cob: u32,
    pub pc_grb: u32,
    pub pc_cgsrr: u32,
    pub pc_oflc: u32,
    pub pc_reserved0: u32,
    pub pc_reserved1: u32,
    pub pc_reserved2: u32,
    pub pc_reserved3: u32,
    pub ext_dev_nunchaku: u32,
    pub ext_dev_classic: u32,
    pub ext_dev_urcc: u32,
    pub ext_dev_board: u32,
    pub ext_dev_usb_keyboard: u32,
    pub ext_dev_etc: u32,
    pub ext_dev_etc_name: [cty::c_char; 512usize],
    pub eula_version: u32,
    pub drc_use: u32,
    pub network_use: u32,
    pub online_account_use: u32,
    pub direct_boot: u32,
    pub reserved_flag0: u32,
    pub reserved_flag1: u32,
    pub reserved_flag2: u32,
    pub reserved_flag3: u32,
    pub reserved_flag4: u32,
    pub reserved_flag5: u32,
    pub reserved_flag6: u32,
    pub reserved_flag7: u32,
    pub longname_ja: [cty::c_char; 512usize],
    pub longname_en: [cty::c_char; 512usize],
    pub longname_fr: [cty::c_char; 512usize],
    pub longname_de: [cty::c_char; 512usize],
    pub longname_it: [cty::c_char; 512usize],
    pub longname_es: [cty::c_char; 512usize],
    pub longname_zhs: [cty::c_char; 512usize],
    pub longname_ko: [cty::c_char; 512usize],
    pub longname_nl: [cty::c_char; 512usize],
    pub longname_pt: [cty::c_char; 512usize],
    pub longname_ru: [cty::c_char; 512usize],
    pub longname_zht: [cty::c_char; 512usize],
    pub shortname_ja: [cty::c_char; 256usize],
    pub shortname_en: [cty::c_char; 256usize],
    pub shortname_fr: [cty::c_char; 256usize],
    pub shortname_de: [cty::c_char; 256usize],
    pub shortname_it: [cty::c_char; 256usize],
    pub shortname_es: [cty::c_char; 256usize],
    pub shortname_zhs: [cty::c_char; 256usize],
    pub shortname_ko: [cty::c_char; 256usize],
    pub shortname_nl: [cty::c_char; 256usize],
    pub shortname_pt: [cty::c_char; 256usize],
    pub shortname_ru: [cty::c_char; 256usize],
    pub shortname_zht: [cty::c_char; 256usize],
    pub publisher_ja: [cty::c_char; 256usize],
    pub publisher_en: [cty::c_char; 256usize],
    pub publisher_fr: [cty::c_char; 256usize],
    pub publisher_de: [cty::c_char; 256usize],
    pub publisher_it: [cty::c_char; 256usize],
    pub publisher_es: [cty::c_char; 256usize],
    pub publisher_zhs: [cty::c_char; 256usize],
    pub publisher_ko: [cty::c_char; 256usize],
    pub publisher_nl: [cty::c_char; 256usize],
    pub publisher_pt: [cty::c_char; 256usize],
    pub publisher_ru: [cty::c_char; 256usize],
    pub publisher_zht: [cty::c_char; 256usize],
    pub add_on_unique_id: [u32; 32usize],
    pub __unk56: [cty::c_char; 52usize],
}
#[test]
fn bindgen_test_layout_ACPMetaXml() {
    assert_eq!(
        ::core::mem::size_of::<ACPMetaXml>(),
        13376usize,
        concat!("Size of: ", stringify!(ACPMetaXml))
    );
    assert_eq!(
        ::core::mem::align_of::<ACPMetaXml>(),
        1usize,
        concat!("Alignment of ", stringify!(ACPMetaXml))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).title_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(title_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).boss_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(boss_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).os_version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(os_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).app_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(app_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).common_save_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(common_save_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).account_save_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(account_save_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).common_boss_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(common_boss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).account_boss_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(account_boss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).join_game_mode_mask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(join_game_mode_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).version as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).product_code as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(product_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).content_platform as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(content_platform)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).company_code as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(company_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).mastering_date as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(mastering_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).logo_type as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(logo_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).app_launch_type as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(app_launch_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).invisible_flag as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(invisible_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).no_managed_flag as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(no_managed_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).no_event_log as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(no_event_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).no_icon_database as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(no_icon_database)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).launching_flag as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(launching_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).install_flag as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(install_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).closing_msg as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(closing_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).title_version as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(title_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).group_id as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).save_no_rollback as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(save_no_rollback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).bg_daemon_enable as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(bg_daemon_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).join_game_id as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(join_game_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).olv_accesskey as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(olv_accesskey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).wood_tin as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(wood_tin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).e_manual as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(e_manual)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).e_manual_version as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(e_manual_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).region as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_cero as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_cero)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_esrb as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_esrb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_bbfc as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_bbfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_usk as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_usk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_pegi_gen as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_pegi_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_pegi_fin as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_pegi_fin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_pegi_prt as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_pegi_prt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_pegi_bbfc as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_pegi_bbfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_cob as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_cob)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_grb as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_grb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_cgsrr as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_cgsrr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_oflc as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_oflc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_reserved0 as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_reserved1 as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_reserved2 as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).pc_reserved3 as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(pc_reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).ext_dev_nunchaku as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(ext_dev_nunchaku)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).ext_dev_classic as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(ext_dev_classic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).ext_dev_urcc as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(ext_dev_urcc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).ext_dev_board as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(ext_dev_board)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ACPMetaXml>())).ext_dev_usb_keyboard as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(ext_dev_usb_keyboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).ext_dev_etc as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(ext_dev_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).ext_dev_etc_name as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(ext_dev_etc_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).eula_version as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(eula_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).drc_use as *const _ as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(drc_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).network_use as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(network_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).online_account_use as *const _ as usize },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(online_account_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).direct_boot as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(direct_boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag0 as *const _ as usize },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag1 as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag2 as *const _ as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag3 as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag4 as *const _ as usize },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag5 as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag6 as *const _ as usize },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).reserved_flag7 as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(reserved_flag7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_ja as *const _ as usize },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_ja)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_en as *const _ as usize },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_fr as *const _ as usize },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_fr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_de as *const _ as usize },
        2444usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_de)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_it as *const _ as usize },
        2956usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_it)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_es as *const _ as usize },
        3468usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_es)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_zhs as *const _ as usize },
        3980usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_zhs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_ko as *const _ as usize },
        4492usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_ko)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_nl as *const _ as usize },
        5004usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_pt as *const _ as usize },
        5516usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_pt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_ru as *const _ as usize },
        6028usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_ru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).longname_zht as *const _ as usize },
        6540usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(longname_zht)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_ja as *const _ as usize },
        7052usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_ja)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_en as *const _ as usize },
        7308usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_fr as *const _ as usize },
        7564usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_fr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_de as *const _ as usize },
        7820usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_de)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_it as *const _ as usize },
        8076usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_it)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_es as *const _ as usize },
        8332usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_es)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_zhs as *const _ as usize },
        8588usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_zhs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_ko as *const _ as usize },
        8844usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_ko)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_nl as *const _ as usize },
        9100usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_pt as *const _ as usize },
        9356usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_pt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_ru as *const _ as usize },
        9612usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_ru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).shortname_zht as *const _ as usize },
        9868usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(shortname_zht)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_ja as *const _ as usize },
        10124usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_ja)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_en as *const _ as usize },
        10380usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_fr as *const _ as usize },
        10636usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_fr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_de as *const _ as usize },
        10892usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_de)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_it as *const _ as usize },
        11148usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_it)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_es as *const _ as usize },
        11404usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_es)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_zhs as *const _ as usize },
        11660usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_zhs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_ko as *const _ as usize },
        11916usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_ko)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_nl as *const _ as usize },
        12172usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_pt as *const _ as usize },
        12428usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_pt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_ru as *const _ as usize },
        12684usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_ru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).publisher_zht as *const _ as usize },
        12940usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(publisher_zht)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).add_on_unique_id as *const _ as usize },
        13196usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(add_on_unique_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ACPMetaXml>())).__unk56 as *const _ as usize },
        13324usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPMetaXml),
            "::",
            stringify!(__unk56)
        )
    );
}
extern "C" {
    pub fn ACPGetTitleIdOfMainApplication(titleId: *mut ACPTitleId) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleMetaXml(titleId: ACPTitleId, metaXml: *mut ACPMetaXml) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleMetaDirByDevice(
        titleId: ACPTitleId,
        directory: *mut cty::c_char,
        directoryLen: size_t,
        deviceType: ACPDeviceType,
    ) -> ACPResult::Type;
}
pub mod FFLCreateIDFlags {
    pub type Type = cty::c_uint;
    pub const FFL_CREATE_ID_FLAG_WII_U: Type = 5;
    pub const FFL_CREATE_ID_FLAG_TEMPORARY: Type = 2;
    pub const FFL_CREATE_ID_FLAG_NORMAL: Type = 8;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLCreateID {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub deviceHash: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_FFLCreateID() {
    assert_eq!(
        ::core::mem::size_of::<FFLCreateID>(),
        10usize,
        concat!("Size of: ", stringify!(FFLCreateID))
    );
    assert_eq!(
        ::core::mem::align_of::<FFLCreateID>(),
        1usize,
        concat!("Alignment of ", stringify!(FFLCreateID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLCreateID>())).deviceHash as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLCreateID),
            "::",
            stringify!(deviceHash)
        )
    );
}
impl FFLCreateID {
    #[inline]
    pub fn flags(&self) -> FFLCreateIDFlags::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: FFLCreateIDFlags::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: FFLCreateIDFlags::Type,
        timestamp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataCore {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub mii_version: u8,
    pub author_id: u64,
    pub mii_id: FFLCreateID,
    pub unk_0x16: u16,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub mii_name: [u16; 10usize],
    pub size: u8,
    pub fatness: u8,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub hair_type: u8,
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 20usize], u8>,
}
#[test]
fn bindgen_test_layout_FFLiMiiDataCore() {
    assert_eq!(
        ::core::mem::size_of::<FFLiMiiDataCore>(),
        72usize,
        concat!("Size of: ", stringify!(FFLiMiiDataCore))
    );
    assert_eq!(
        ::core::mem::align_of::<FFLiMiiDataCore>(),
        1usize,
        concat!("Alignment of ", stringify!(FFLiMiiDataCore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).mii_version as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(mii_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).author_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(author_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).mii_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(mii_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).unk_0x16 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(unk_0x16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).mii_name as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(mii_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).size as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).fatness as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(fatness)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataCore>())).hair_type as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataCore),
            "::",
            stringify!(hair_type)
        )
    );
}
impl FFLiMiiDataCore {
    #[inline]
    pub fn birth_platform(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_birth_platform(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x00_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x00_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn font_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_font_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn region_move(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_move(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x02_b6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x02_b6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn copyable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_copyable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        birth_platform: u8,
        unk_0x00_b4: u8,
        unk_0x01_b0: u8,
        unk_0x01_b4: u8,
        font_region: u8,
        region_move: u8,
        unk_0x02_b6: u8,
        copyable: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let birth_platform: u8 = unsafe { ::core::mem::transmute(birth_platform) };
            birth_platform as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let unk_0x00_b4: u8 = unsafe { ::core::mem::transmute(unk_0x00_b4) };
            unk_0x00_b4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let unk_0x01_b0: u8 = unsafe { ::core::mem::transmute(unk_0x01_b0) };
            unk_0x01_b0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let unk_0x01_b4: u8 = unsafe { ::core::mem::transmute(unk_0x01_b4) };
            unk_0x01_b4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let font_region: u8 = unsafe { ::core::mem::transmute(font_region) };
            font_region as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let region_move: u8 = unsafe { ::core::mem::transmute(region_move) };
            region_move as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let unk_0x02_b6: u8 = unsafe { ::core::mem::transmute(unk_0x02_b6) };
            unk_0x02_b6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let copyable: u8 = unsafe { ::core::mem::transmute(copyable) };
            copyable as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn unk_0x18_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x18_b1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_day(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_birth_day(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_month(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_birth_month(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn gender(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gender(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        unk_0x18_b0: u16,
        unk_0x18_b1: u16,
        color: u16,
        birth_day: u16,
        birth_month: u16,
        gender: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk_0x18_b0: u16 = unsafe { ::core::mem::transmute(unk_0x18_b0) };
            unk_0x18_b0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let unk_0x18_b1: u16 = unsafe { ::core::mem::transmute(unk_0x18_b1) };
            unk_0x18_b1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let birth_day: u16 = unsafe { ::core::mem::transmute(birth_day) };
            birth_day as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let birth_month: u16 = unsafe { ::core::mem::transmute(birth_month) };
            birth_month as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let gender: u16 = unsafe { ::core::mem::transmute(gender) };
            gender as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn blush_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blush_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_style(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_style(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_face_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn face_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn local_only(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_local_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_mirrored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hair_mirrored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(21usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_hair_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        blush_type: u8,
        face_style: u8,
        face_color: u8,
        face_type: u8,
        local_only: u8,
        hair_mirrored: u8,
        hair_color: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let blush_type: u8 = unsafe { ::core::mem::transmute(blush_type) };
            blush_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let face_style: u8 = unsafe { ::core::mem::transmute(face_style) };
            face_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let face_color: u8 = unsafe { ::core::mem::transmute(face_color) };
            face_color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let face_type: u8 = unsafe { ::core::mem::transmute(face_type) };
            face_type as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let local_only: u8 = unsafe { ::core::mem::transmute(local_only) };
            local_only as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let hair_mirrored: u8 = unsafe { ::core::mem::transmute(hair_mirrored) };
            hair_mirrored as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let hair_color: u8 = unsafe { ::core::mem::transmute(hair_color) };
            hair_color as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn eye_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_eye_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eye_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eye_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(36usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(40usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(40usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(43usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(43usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(48usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(48usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(55usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(55usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(59usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(64usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_nose_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(64usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(71usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_nose_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(71usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(75usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_nose_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(75usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(80usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(80usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(83usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(83usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(87usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(87usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(90usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(90usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x40(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unk_0x40(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(104usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(104usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(107usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(107usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(112usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(112usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(118usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(118usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(122usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(122usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(125usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(125usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_height(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(128usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_glass_height(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(128usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(133usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(133usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(137usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_glass_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(137usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_type(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(140usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(140usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x46_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(144usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x46_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(144usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_ypos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(145usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_ypos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(145usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_xpos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(150usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_xpos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(150usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(155usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_mole_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(155usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_enabled(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(159usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mole_enabled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(159usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        eye_thickness: u32,
        eye_scale: u32,
        eye_color: u32,
        eye_type: u32,
        eye_height: u32,
        eye_distance: u32,
        eye_rotation: u32,
        eyebrow_thickness: u32,
        eyebrow_scale: u32,
        eyebrow_color: u32,
        eyebrow_type: u32,
        eyebrow_height: u32,
        eyebrow_distance: u32,
        eyebrow_rotation: u32,
        nose_height: u32,
        nose_scale: u32,
        nose_type: u32,
        mouth_thickness: u32,
        mouth_scale: u32,
        mouth_color: u32,
        mouth_type: u32,
        unk_0x40: u32,
        mustache_type: u32,
        mouth_height: u32,
        mustache_height: u32,
        mustache_scale: u32,
        beard_color: u32,
        beard_type: u32,
        glass_height: u16,
        glass_scale: u16,
        glass_color: u16,
        glass_type: u16,
        unk_0x46_b0: u16,
        mole_ypos: u16,
        mole_xpos: u16,
        mole_scale: u16,
        mole_enabled: u16,
    ) -> __BindgenBitfieldUnit<[u8; 20usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 20usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let eye_thickness: u32 = unsafe { ::core::mem::transmute(eye_thickness) };
            eye_thickness as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let eye_scale: u32 = unsafe { ::core::mem::transmute(eye_scale) };
            eye_scale as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let eye_color: u32 = unsafe { ::core::mem::transmute(eye_color) };
            eye_color as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let eye_type: u32 = unsafe { ::core::mem::transmute(eye_type) };
            eye_type as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let eye_height: u32 = unsafe { ::core::mem::transmute(eye_height) };
            eye_height as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let eye_distance: u32 = unsafe { ::core::mem::transmute(eye_distance) };
            eye_distance as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let eye_rotation: u32 = unsafe { ::core::mem::transmute(eye_rotation) };
            eye_rotation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let eyebrow_thickness: u32 = unsafe { ::core::mem::transmute(eyebrow_thickness) };
            eyebrow_thickness as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let eyebrow_scale: u32 = unsafe { ::core::mem::transmute(eyebrow_scale) };
            eyebrow_scale as u64
        });
        __bindgen_bitfield_unit.set(40usize, 3u8, {
            let eyebrow_color: u32 = unsafe { ::core::mem::transmute(eyebrow_color) };
            eyebrow_color as u64
        });
        __bindgen_bitfield_unit.set(43usize, 5u8, {
            let eyebrow_type: u32 = unsafe { ::core::mem::transmute(eyebrow_type) };
            eyebrow_type as u64
        });
        __bindgen_bitfield_unit.set(48usize, 7u8, {
            let eyebrow_height: u32 = unsafe { ::core::mem::transmute(eyebrow_height) };
            eyebrow_height as u64
        });
        __bindgen_bitfield_unit.set(55usize, 4u8, {
            let eyebrow_distance: u32 = unsafe { ::core::mem::transmute(eyebrow_distance) };
            eyebrow_distance as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let eyebrow_rotation: u32 = unsafe { ::core::mem::transmute(eyebrow_rotation) };
            eyebrow_rotation as u64
        });
        __bindgen_bitfield_unit.set(64usize, 7u8, {
            let nose_height: u32 = unsafe { ::core::mem::transmute(nose_height) };
            nose_height as u64
        });
        __bindgen_bitfield_unit.set(71usize, 4u8, {
            let nose_scale: u32 = unsafe { ::core::mem::transmute(nose_scale) };
            nose_scale as u64
        });
        __bindgen_bitfield_unit.set(75usize, 5u8, {
            let nose_type: u32 = unsafe { ::core::mem::transmute(nose_type) };
            nose_type as u64
        });
        __bindgen_bitfield_unit.set(80usize, 3u8, {
            let mouth_thickness: u32 = unsafe { ::core::mem::transmute(mouth_thickness) };
            mouth_thickness as u64
        });
        __bindgen_bitfield_unit.set(83usize, 4u8, {
            let mouth_scale: u32 = unsafe { ::core::mem::transmute(mouth_scale) };
            mouth_scale as u64
        });
        __bindgen_bitfield_unit.set(87usize, 3u8, {
            let mouth_color: u32 = unsafe { ::core::mem::transmute(mouth_color) };
            mouth_color as u64
        });
        __bindgen_bitfield_unit.set(90usize, 6u8, {
            let mouth_type: u32 = unsafe { ::core::mem::transmute(mouth_type) };
            mouth_type as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let unk_0x40: u32 = unsafe { ::core::mem::transmute(unk_0x40) };
            unk_0x40 as u64
        });
        __bindgen_bitfield_unit.set(104usize, 3u8, {
            let mustache_type: u32 = unsafe { ::core::mem::transmute(mustache_type) };
            mustache_type as u64
        });
        __bindgen_bitfield_unit.set(107usize, 5u8, {
            let mouth_height: u32 = unsafe { ::core::mem::transmute(mouth_height) };
            mouth_height as u64
        });
        __bindgen_bitfield_unit.set(112usize, 6u8, {
            let mustache_height: u32 = unsafe { ::core::mem::transmute(mustache_height) };
            mustache_height as u64
        });
        __bindgen_bitfield_unit.set(118usize, 4u8, {
            let mustache_scale: u32 = unsafe { ::core::mem::transmute(mustache_scale) };
            mustache_scale as u64
        });
        __bindgen_bitfield_unit.set(122usize, 3u8, {
            let beard_color: u32 = unsafe { ::core::mem::transmute(beard_color) };
            beard_color as u64
        });
        __bindgen_bitfield_unit.set(125usize, 3u8, {
            let beard_type: u32 = unsafe { ::core::mem::transmute(beard_type) };
            beard_type as u64
        });
        __bindgen_bitfield_unit.set(128usize, 5u8, {
            let glass_height: u16 = unsafe { ::core::mem::transmute(glass_height) };
            glass_height as u64
        });
        __bindgen_bitfield_unit.set(133usize, 4u8, {
            let glass_scale: u16 = unsafe { ::core::mem::transmute(glass_scale) };
            glass_scale as u64
        });
        __bindgen_bitfield_unit.set(137usize, 3u8, {
            let glass_color: u16 = unsafe { ::core::mem::transmute(glass_color) };
            glass_color as u64
        });
        __bindgen_bitfield_unit.set(140usize, 4u8, {
            let glass_type: u16 = unsafe { ::core::mem::transmute(glass_type) };
            glass_type as u64
        });
        __bindgen_bitfield_unit.set(144usize, 1u8, {
            let unk_0x46_b0: u16 = unsafe { ::core::mem::transmute(unk_0x46_b0) };
            unk_0x46_b0 as u64
        });
        __bindgen_bitfield_unit.set(145usize, 5u8, {
            let mole_ypos: u16 = unsafe { ::core::mem::transmute(mole_ypos) };
            mole_ypos as u64
        });
        __bindgen_bitfield_unit.set(150usize, 5u8, {
            let mole_xpos: u16 = unsafe { ::core::mem::transmute(mole_xpos) };
            mole_xpos as u64
        });
        __bindgen_bitfield_unit.set(155usize, 4u8, {
            let mole_scale: u16 = unsafe { ::core::mem::transmute(mole_scale) };
            mole_scale as u64
        });
        __bindgen_bitfield_unit.set(159usize, 1u8, {
            let mole_enabled: u16 = unsafe { ::core::mem::transmute(mole_enabled) };
            mole_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataOfficial {
    pub core: FFLiMiiDataCore,
    pub creator_name: [u16; 10usize],
}
#[test]
fn bindgen_test_layout_FFLiMiiDataOfficial() {
    assert_eq!(
        ::core::mem::size_of::<FFLiMiiDataOfficial>(),
        92usize,
        concat!("Size of: ", stringify!(FFLiMiiDataOfficial))
    );
    assert_eq!(
        ::core::mem::align_of::<FFLiMiiDataOfficial>(),
        1usize,
        concat!("Alignment of ", stringify!(FFLiMiiDataOfficial))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLiMiiDataOfficial>())).core as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataOfficial),
            "::",
            stringify!(core)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FFLiMiiDataOfficial>())).creator_name as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLiMiiDataOfficial),
            "::",
            stringify!(creator_name)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLStoreData {
    pub data: FFLiMiiDataOfficial,
    pub unk_0x5C: u16,
    pub checksum: u16,
}
#[test]
fn bindgen_test_layout_FFLStoreData() {
    assert_eq!(
        ::core::mem::size_of::<FFLStoreData>(),
        96usize,
        concat!("Size of: ", stringify!(FFLStoreData))
    );
    assert_eq!(
        ::core::mem::align_of::<FFLStoreData>(),
        1usize,
        concat!("Alignment of ", stringify!(FFLStoreData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLStoreData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLStoreData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLStoreData>())).unk_0x5C as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLStoreData),
            "::",
            stringify!(unk_0x5C)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FFLStoreData>())).checksum as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(FFLStoreData),
            "::",
            stringify!(checksum)
        )
    );
}
extern "C" {
    #[doc = " Initializes PDM."]
    #[doc = " Needs to be called before using other functions."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " 0 on success."]
    pub fn PDMInitialize() -> u32;
}
extern "C" {
    #[doc = " Finalize PDM."]
    pub fn PDMFinalize();
}
extern "C" {
    #[doc = " Close all opened PDM Files."]
    pub fn PDMCloseAllFiles();
}
extern "C" {
    pub fn PDMNotifySetTimeBeginEvent();
}
extern "C" {
    pub fn PDMNotifySetTimeEndEvent();
}
pub mod WPADChan {
    #[doc = "! Wii Remote channel."]
    pub type Type = cty::c_uint;
    #[doc = "! Channel 0."]
    pub const WPAD_CHAN_0: Type = 0;
    #[doc = "! Channel 1."]
    pub const WPAD_CHAN_1: Type = 1;
    #[doc = "! Channel 2."]
    pub const WPAD_CHAN_2: Type = 2;
    #[doc = "! Channel 3."]
    pub const WPAD_CHAN_3: Type = 3;
}
pub mod WPADDataFormat {
    #[doc = "! Data format."]
    pub type Type = cty::c_uint;
    pub const WPAD_FMT_PRO_CONTROLLER: Type = 22;
}
pub mod WPADExtensionType {
    #[doc = "! Extension type."]
    pub type Type = cty::c_uint;
    #[doc = "! Wii Remote with no extension."]
    pub const WPAD_EXT_CORE: Type = 0;
    #[doc = "! Nunchuk."]
    pub const WPAD_EXT_NUNCHUK: Type = 1;
    #[doc = "! Classic Controller."]
    pub const WPAD_EXT_CLASSIC: Type = 2;
    #[doc = "! Motion Plus."]
    pub const WPAD_EXT_MPLUS: Type = 5;
    #[doc = "! Motion Plus with Nunchuk."]
    pub const WPAD_EXT_MPLUS_NUNCHUK: Type = 6;
    #[doc = "! Motion Plus with Classic Controller."]
    pub const WPAD_EXT_MPLUS_CLASSIC: Type = 7;
    #[doc = "! Pro Controller."]
    pub const WPAD_EXT_PRO_CONTROLLER: Type = 31;
}
pub mod WPADButton {
    #[doc = "! Wii Remote buttons."]
    pub type Type = cty::c_uint;
    #[doc = "! The left button of the D-pad."]
    pub const WPAD_BUTTON_LEFT: Type = 1;
    #[doc = "! The right button of the D-pad."]
    pub const WPAD_BUTTON_RIGHT: Type = 2;
    #[doc = "! The down button of the D-pad."]
    pub const WPAD_BUTTON_DOWN: Type = 4;
    #[doc = "! The up button of the D-pad."]
    pub const WPAD_BUTTON_UP: Type = 8;
    #[doc = "! The + button."]
    pub const WPAD_BUTTON_PLUS: Type = 16;
    #[doc = "! The 2 button."]
    pub const WPAD_BUTTON_2: Type = 256;
    #[doc = "! The 1 button."]
    pub const WPAD_BUTTON_1: Type = 512;
    #[doc = "! The B button."]
    pub const WPAD_BUTTON_B: Type = 1024;
    #[doc = "! The A button."]
    pub const WPAD_BUTTON_A: Type = 2048;
    #[doc = "! The - button."]
    pub const WPAD_BUTTON_MINUS: Type = 4096;
    #[doc = "! The Z button on the Nunchuk extension."]
    pub const WPAD_BUTTON_Z: Type = 8192;
    #[doc = "! The C button on the Nunchuk extension."]
    pub const WPAD_BUTTON_C: Type = 16384;
    #[doc = "! The HOME button."]
    pub const WPAD_BUTTON_HOME: Type = 32768;
}
pub mod WPADNunchukButton {
    #[doc = "! Nunchuk buttons."]
    pub type Type = cty::c_uint;
    #[doc = "! The emulated left button on the Nunchuk stick or the left button of the D-pad on the Wii Remote."]
    pub const WPAD_NUNCHUK_STICK_EMULATION_LEFT: Type = 1;
    #[doc = "! The emulated right button on the Nunchuk stick or the right button of the D-pad on the Wii Remote."]
    pub const WPAD_NUNCHUK_STICK_EMULATION_RIGHT: Type = 2;
    #[doc = "! The emulated down button on the Nunchuk stick or the down button of the D-pad on the Wii Remote."]
    pub const WPAD_NUNCHUK_STICK_EMULATION_DOWN: Type = 4;
    #[doc = "! The emulated up button on the Nunchuk stick or the up button of the D-pad on the Wii Remote."]
    pub const WPAD_NUNCHUK_STICK_EMULATION_UP: Type = 8;
    #[doc = "! The Z button."]
    pub const WPAD_NUNCHUK_BUTTON_Z: Type = 8192;
    #[doc = "! The C button."]
    pub const WPAD_NUNCHUK_BUTTON_C: Type = 16384;
}
pub mod WPADClassicButton {
    #[doc = "! Classic Controller buttons."]
    pub type Type = cty::c_uint;
    #[doc = "! The up button of the D-pad."]
    pub const WPAD_CLASSIC_BUTTON_UP: Type = 1;
    #[doc = "! The left button of the D-pad."]
    pub const WPAD_CLASSIC_BUTTON_LEFT: Type = 2;
    #[doc = "! The ZR button."]
    pub const WPAD_CLASSIC_BUTTON_ZR: Type = 4;
    #[doc = "! The X button."]
    pub const WPAD_CLASSIC_BUTTON_X: Type = 8;
    #[doc = "! The A button."]
    pub const WPAD_CLASSIC_BUTTON_A: Type = 16;
    #[doc = "! The Y button."]
    pub const WPAD_CLASSIC_BUTTON_Y: Type = 32;
    #[doc = "! The B button."]
    pub const WPAD_CLASSIC_BUTTON_B: Type = 64;
    #[doc = "! The ZL button."]
    pub const WPAD_CLASSIC_BUTTON_ZL: Type = 128;
    #[doc = "! The R button."]
    pub const WPAD_CLASSIC_BUTTON_R: Type = 512;
    #[doc = "! The + button."]
    pub const WPAD_CLASSIC_BUTTON_PLUS: Type = 1024;
    #[doc = "! The HOME button."]
    pub const WPAD_CLASSIC_BUTTON_HOME: Type = 2048;
    #[doc = "! The - button."]
    pub const WPAD_CLASSIC_BUTTON_MINUS: Type = 4096;
    #[doc = "! The L button."]
    pub const WPAD_CLASSIC_BUTTON_L: Type = 8192;
    #[doc = "! The down button of the D-pad."]
    pub const WPAD_CLASSIC_BUTTON_DOWN: Type = 16384;
    #[doc = "! The right button of the D-pad."]
    pub const WPAD_CLASSIC_BUTTON_RIGHT: Type = 32768;
    #[doc = "! The emulated left button on the left stick."]
    pub const WPAD_CLASSIC_STICK_L_EMULATION_LEFT: Type = 65536;
    #[doc = "! The emulated right button on the left stick."]
    pub const WPAD_CLASSIC_STICK_L_EMULATION_RIGHT: Type = 131072;
    #[doc = "! The emulated down button on the left stick."]
    pub const WPAD_CLASSIC_STICK_L_EMULATION_DOWN: Type = 262144;
    #[doc = "! The emulated up button on the left stick."]
    pub const WPAD_CLASSIC_STICK_L_EMULATION_UP: Type = 524288;
    #[doc = "! The emulated left button on the right stick."]
    pub const WPAD_CLASSIC_STICK_R_EMULATION_LEFT: Type = 1048576;
    #[doc = "! The emulated right button on the right stick."]
    pub const WPAD_CLASSIC_STICK_R_EMULATION_RIGHT: Type = 2097152;
    #[doc = "! The emulated down button on the right stick."]
    pub const WPAD_CLASSIC_STICK_R_EMULATION_DOWN: Type = 4194304;
    #[doc = "! The emulated up button on the right stick."]
    pub const WPAD_CLASSIC_STICK_R_EMULATION_UP: Type = 8388608;
}
pub mod WPADProButton {
    #[doc = "! Pro Controller buttons."]
    pub type Type = cty::c_uint;
    #[doc = "! The up button of the D-pad."]
    pub const WPAD_PRO_BUTTON_UP: Type = 1;
    #[doc = "! The left button of the D-pad."]
    pub const WPAD_PRO_BUTTON_LEFT: Type = 2;
    #[doc = "! The ZR button."]
    pub const WPAD_PRO_TRIGGER_ZR: Type = 4;
    #[doc = "! The X button."]
    pub const WPAD_PRO_BUTTON_X: Type = 8;
    #[doc = "! The A button."]
    pub const WPAD_PRO_BUTTON_A: Type = 16;
    #[doc = "! The Y button."]
    pub const WPAD_PRO_BUTTON_Y: Type = 32;
    #[doc = "! The B button."]
    pub const WPAD_PRO_BUTTON_B: Type = 64;
    #[doc = "! The ZL button."]
    pub const WPAD_PRO_TRIGGER_ZL: Type = 128;
    #[doc = "! Reserved."]
    pub const WPAD_PRO_RESERVED: Type = 256;
    #[doc = "! The right trigger button."]
    pub const WPAD_PRO_TRIGGER_R: Type = 512;
    #[doc = "! The + button."]
    pub const WPAD_PRO_BUTTON_PLUS: Type = 1024;
    #[doc = "! The HOME button."]
    pub const WPAD_PRO_BUTTON_HOME: Type = 2048;
    #[doc = "! The - button."]
    pub const WPAD_PRO_BUTTON_MINUS: Type = 4096;
    #[doc = "! The left trigger button."]
    pub const WPAD_PRO_TRIGGER_L: Type = 8192;
    #[doc = "! The down button of the D-pad."]
    pub const WPAD_PRO_BUTTON_DOWN: Type = 16384;
    #[doc = "! The right button of the D-pad."]
    pub const WPAD_PRO_BUTTON_RIGHT: Type = 32768;
    #[doc = "! The right stick button."]
    pub const WPAD_PRO_BUTTON_STICK_R: Type = 65536;
    #[doc = "! The left stick button."]
    pub const WPAD_PRO_BUTTON_STICK_L: Type = 131072;
    #[doc = "! The emulated up button on the left stick."]
    pub const WPAD_PRO_STICK_L_EMULATION_UP: Type = 2097152;
    #[doc = "! The emulated down button on the left stick."]
    pub const WPAD_PRO_STICK_L_EMULATION_DOWN: Type = 1048576;
    #[doc = "! The emulated left button on the left stick."]
    pub const WPAD_PRO_STICK_L_EMULATION_LEFT: Type = 262144;
    #[doc = "! The emulated right button on the left stick."]
    pub const WPAD_PRO_STICK_L_EMULATION_RIGHT: Type = 524288;
    #[doc = "! The emulated up button on the right stick."]
    pub const WPAD_PRO_STICK_R_EMULATION_UP: Type = 33554432;
    #[doc = "! The emulated down button on the right stick."]
    pub const WPAD_PRO_STICK_R_EMULATION_DOWN: Type = 16777216;
    #[doc = "! The emulated left button on the right stick."]
    pub const WPAD_PRO_STICK_R_EMULATION_LEFT: Type = 4194304;
    #[doc = "! The emulated right button on the right stick."]
    pub const WPAD_PRO_STICK_R_EMULATION_RIGHT: Type = 8388608;
}
#[doc = "! 2D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADVec2D {
    #[doc = "! x."]
    pub x: i16,
    #[doc = "! y."]
    pub y: i16,
}
#[test]
fn bindgen_test_layout_WPADVec2D() {
    assert_eq!(
        ::core::mem::size_of::<WPADVec2D>(),
        4usize,
        concat!("Size of: ", stringify!(WPADVec2D))
    );
    assert_eq!(
        ::core::mem::align_of::<WPADVec2D>(),
        2usize,
        concat!("Alignment of ", stringify!(WPADVec2D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WPADVec2D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADVec2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WPADVec2D>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADVec2D),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WPADStatusProController {
    pub __unk57: [cty::c_char; 40usize],
    #[doc = "! A value from WPADExtensionType."]
    pub extensionType: u8,
    pub err: u8,
    pub __unk58: [cty::c_char; 2usize],
    pub buttons: u32,
    pub leftStick: WPADVec2D,
    pub rightStick: WPADVec2D,
    pub __unk59: [cty::c_char; 8usize],
    pub dataFormat: WPADDataFormat::Type,
}
#[test]
fn bindgen_test_layout_WPADStatusProController() {
    assert_eq!(
        ::core::mem::size_of::<WPADStatusProController>(),
        68usize,
        concat!("Size of: ", stringify!(WPADStatusProController))
    );
    assert_eq!(
        ::core::mem::align_of::<WPADStatusProController>(),
        4usize,
        concat!("Alignment of ", stringify!(WPADStatusProController))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).__unk57 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(__unk57)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).extensionType as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(extensionType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WPADStatusProController>())).err as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).__unk58 as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(__unk58)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).buttons as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).leftStick as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(leftStick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).rightStick as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(rightStick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).__unk59 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(__unk59)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<WPADStatusProController>())).dataFormat as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WPADStatusProController),
            "::",
            stringify!(dataFormat)
        )
    );
}
pub type WPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type)>;
pub type WPADExtensionCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
extern "C" {
    #[doc = " Initialises the WPAD library for use."]
    pub fn WPADInit();
}
extern "C" {
    #[doc = " Cleans up and frees the WPAD library."]
    pub fn WPADShutdown();
}
extern "C" {
    pub fn WPADProbe(chan: WPADChan::Type, outExtensionType: *mut WPADExtensionType::Type) -> i32;
}
extern "C" {
    pub fn WPADSetDataFormat(chan: WPADChan::Type, format: WPADDataFormat::Type) -> i32;
}
extern "C" {
    pub fn WPADEnableURCC(enable: i32);
}
extern "C" {
    pub fn WPADEnableWiiRemote(enable: i32);
}
extern "C" {
    pub fn WPADRead(chan: WPADChan::Type, data: *mut cty::c_void);
}
extern "C" {
    pub fn WPADSetAutoSleepTime(time: u8);
}
extern "C" {
    pub fn WPADDisconnect(chan: WPADChan::Type);
}
extern "C" {
    pub fn WPADSetConnectCallback(
        chan: WPADChan::Type,
        callback: WPADConnectCallback,
    ) -> WPADConnectCallback;
}
extern "C" {
    pub fn WPADSetExtensionCallback(
        chan: WPADChan::Type,
        callback: WPADExtensionCallback,
    ) -> WPADExtensionCallback;
}
extern "C" {
    pub fn WPADSetSamplingCallback(
        chan: WPADChan::Type,
        callback: WPADSamplingCallback,
    ) -> WPADSamplingCallback;
}
#[doc = "! Wii Remote channel."]
pub use self::WPADChan::Type as KPADChan;
#[doc = "! Data format."]
pub use self::WPADDataFormat::Type as KPADDataFormat;
#[doc = "! Extension type."]
pub use self::WPADExtensionType::Type as KPADExtensionType;
pub mod KPADError {
    #[doc = "! Error."]
    pub type Type = cty::c_uint;
    #[doc = "! No errors."]
    pub const KPAD_ERROR_OK: Type = 0;
}
#[doc = "! 2D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADVec2D {
    #[doc = "! x."]
    pub x: f32,
    #[doc = "! y."]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_KPADVec2D() {
    assert_eq!(
        ::core::mem::size_of::<KPADVec2D>(),
        8usize,
        concat!("Size of: ", stringify!(KPADVec2D))
    );
    assert_eq!(
        ::core::mem::align_of::<KPADVec2D>(),
        4usize,
        concat!("Alignment of ", stringify!(KPADVec2D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADVec2D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADVec2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADVec2D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADVec2D),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "! 3D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADVec3D {
    #[doc = "! x."]
    pub x: f32,
    #[doc = "! y."]
    pub y: f32,
    #[doc = "! z."]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_KPADVec3D() {
    assert_eq!(
        ::core::mem::size_of::<KPADVec3D>(),
        12usize,
        concat!("Size of: ", stringify!(KPADVec3D))
    );
    assert_eq!(
        ::core::mem::align_of::<KPADVec3D>(),
        4usize,
        concat!("Alignment of ", stringify!(KPADVec3D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADVec3D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADVec3D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADVec3D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADVec3D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADVec3D>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADVec3D),
            "::",
            stringify!(z)
        )
    );
}
#[doc = "! A structure conataining the Wii Remote data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KPADStatus {
    #[doc = "! Indicates what KPADButtons are held down."]
    pub hold: u32,
    #[doc = "! Indicates what KPADButtons have been pressed since last sample."]
    pub trigger: u32,
    #[doc = "! Indicates what KPADButtons have been released since last sample."]
    pub release: u32,
    #[doc = "! Indicates the value of the acceleration sensor."]
    pub acc: KPADVec3D,
    #[doc = "! Indicates the magnitude of acceleration."]
    pub accMagnitude: f32,
    #[doc = "! Indicates the variation in acceleration."]
    pub accVariation: f32,
    #[doc = "! Indicates the position where the Wii Remote is pointing."]
    pub pos: KPADVec2D,
    pub __unk60: [cty::c_char; 12usize],
    #[doc = "! Angle."]
    pub angle: KPADVec2D,
    pub __unk61: [cty::c_char; 32usize],
    #[doc = "! Value from KPADExtensionType."]
    pub extensionType: u8,
    #[doc = "! Value from KPADError."]
    pub error: i8,
    #[doc = "! Validity of the result."]
    pub posValid: i8,
    #[doc = "! Value from KPADDataFormat."]
    pub format: u8,
    pub __bindgen_anon_1: KPADStatus__bindgen_ty_1,
    pub __unk63: [cty::c_char; 64usize],
}
#[doc = "! Extension data, check with extensionType to see what is valid to read."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union KPADStatus__bindgen_ty_1 {
    pub nunchuck: KPADStatus__bindgen_ty_1__bindgen_ty_1,
    pub classic: KPADStatus__bindgen_ty_1__bindgen_ty_2,
    pub pro: KPADStatus__bindgen_ty_1__bindgen_ty_3,
    pub __unk62: [cty::c_char; 80usize],
    _bindgen_union_align: [u32; 20usize],
}
#[doc = "! Structure to use when extension type is set to \\link WPAD_EXT_NUNCHUK \\endlink."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "! Position of the analog stick."]
    pub stick: KPADVec2D,
    #[doc = "! Indicates the value of the acceleration sensor."]
    pub acc: KPADVec3D,
    #[doc = "! Indicates the magnitude of acceleration."]
    pub accMagnitude: f32,
    #[doc = "! Indicates the variation in acceleration."]
    pub accVariation: f32,
    #[doc = "! Indicates what buttons are held down."]
    pub hold: u32,
    #[doc = "! Indicates what buttons have been pressed since last sample."]
    pub trigger: u32,
    #[doc = "! Indicates what buttons have been released since last sample."]
    pub release: u32,
}
#[test]
fn bindgen_test_layout_KPADStatus__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<KPADStatus__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<KPADStatus__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_1>())).stick as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(stick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_1>())).acc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_1>())).accMagnitude
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(accMagnitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_1>())).accVariation
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(accVariation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_1>())).hold as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_1>())).trigger as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_1>())).release as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(release)
        )
    );
}
#[doc = "! Structure to use when extension type is set to \\link WPAD_EXT_CLASSIC \\endlink."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "! Indicates what buttons are held down."]
    pub hold: u32,
    #[doc = "! Indicates what buttons have been pressed since last sample."]
    pub trigger: u32,
    #[doc = "! Indicates what buttons have been released since last sample."]
    pub release: u32,
    #[doc = "! Position of left analog stick."]
    pub leftStick: KPADVec2D,
    #[doc = "! Position of right analog stick."]
    pub rightStick: KPADVec2D,
    #[doc = "! Left trigger."]
    pub leftTrigger: f32,
    #[doc = "! Right trigger."]
    pub rightTrigger: f32,
}
#[test]
fn bindgen_test_layout_KPADStatus__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<KPADStatus__bindgen_ty_1__bindgen_ty_2>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<KPADStatus__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_2>())).hold as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_2>())).trigger as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_2>())).release as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_2>())).leftStick
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(leftStick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_2>())).rightStick
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rightStick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_2>())).leftTrigger
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(leftTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_2>())).rightTrigger
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rightTrigger)
        )
    );
}
#[doc = "! Structure to use when extension type is set to \\link WPAD_EXT_PRO_CONTROLLER \\endlink."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "! Indicates what buttons are held down."]
    pub hold: u32,
    #[doc = "! Indicates what buttons have been pressed since last sample."]
    pub trigger: u32,
    #[doc = "! Indicates what buttons have been released since last sample."]
    pub release: u32,
    #[doc = "! Position of left analog stick."]
    pub leftStick: KPADVec2D,
    #[doc = "! Position of right analog stick."]
    pub rightStick: KPADVec2D,
    #[doc = "! Is charging flag."]
    pub charging: i32,
    #[doc = "! Is wired flag."]
    pub wired: i32,
}
#[test]
fn bindgen_test_layout_KPADStatus__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<KPADStatus__bindgen_ty_1__bindgen_ty_3>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<KPADStatus__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_3>())).hold as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_3>())).trigger as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_3>())).release as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_3>())).leftStick
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(leftStick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_3>())).rightStick
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(rightStick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_3>())).charging as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(charging)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1__bindgen_ty_3>())).wired as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(wired)
        )
    );
}
#[test]
fn bindgen_test_layout_KPADStatus__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<KPADStatus__bindgen_ty_1>(),
        80usize,
        concat!("Size of: ", stringify!(KPADStatus__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<KPADStatus__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(KPADStatus__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1>())).nunchuck as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1),
            "::",
            stringify!(nunchuck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1>())).classic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1),
            "::",
            stringify!(classic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1>())).pro as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1),
            "::",
            stringify!(pro)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<KPADStatus__bindgen_ty_1>())).__unk62 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus__bindgen_ty_1),
            "::",
            stringify!(__unk62)
        )
    );
}
#[test]
fn bindgen_test_layout_KPADStatus() {
    assert_eq!(
        ::core::mem::size_of::<KPADStatus>(),
        240usize,
        concat!("Size of: ", stringify!(KPADStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<KPADStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(KPADStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).hold as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).trigger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).acc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).accMagnitude as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(accMagnitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).accVariation as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(accVariation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).pos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).__unk60 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(__unk60)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).angle as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).__unk61 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(__unk61)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).extensionType as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(extensionType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).error as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).posValid as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(posValid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).format as *const _ as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KPADStatus>())).__unk63 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(KPADStatus),
            "::",
            stringify!(__unk63)
        )
    );
}
extern "C" {
    #[doc = " Initialises the KPAD library for use."]
    pub fn KPADInit();
}
extern "C" {
    #[doc = " Read data from the desired Wii Remote."]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel of the controller to read from."]
    #[doc = ""]
    #[doc = " \\param data"]
    #[doc = " The KPADStatus to fill."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The maximum number of data to read."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The number of data read."]
    pub fn KPADRead(chan: KPADChan, data: *mut KPADStatus, size: u32) -> i32;
}
extern "C" {
    #[doc = " Read data from the desired Wii Remote."]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel of the controller to read from."]
    #[doc = ""]
    #[doc = " \\param data"]
    #[doc = " The KPADStatus to fill."]
    #[doc = ""]
    #[doc = " \\param size"]
    #[doc = " The maximum number of data to read."]
    #[doc = ""]
    #[doc = " \\param error"]
    #[doc = " A pointer to an error code."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The number of data read."]
    pub fn KPADReadEx(chan: KPADChan, data: *mut KPADStatus, size: u32, error: *mut i32) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADGyroStatus {
    _unused: [u8; 0],
}
pub mod VPADButtons {
    #[doc = "! Wii U GamePad buttons."]
    pub type Type = cty::c_uint;
    #[doc = "! The A button."]
    pub const VPAD_BUTTON_A: Type = 32768;
    #[doc = "! The B button."]
    pub const VPAD_BUTTON_B: Type = 16384;
    #[doc = "! The X button."]
    pub const VPAD_BUTTON_X: Type = 8192;
    #[doc = "! The Y button."]
    pub const VPAD_BUTTON_Y: Type = 4096;
    #[doc = "! The left button of the D-pad."]
    pub const VPAD_BUTTON_LEFT: Type = 2048;
    #[doc = "! The right button of the D-pad."]
    pub const VPAD_BUTTON_RIGHT: Type = 1024;
    #[doc = "! The up button of the D-pad."]
    pub const VPAD_BUTTON_UP: Type = 512;
    #[doc = "! The down button of the D-pad."]
    pub const VPAD_BUTTON_DOWN: Type = 256;
    #[doc = "! The ZL button."]
    pub const VPAD_BUTTON_ZL: Type = 128;
    #[doc = "! The ZR button."]
    pub const VPAD_BUTTON_ZR: Type = 64;
    #[doc = "! The L button."]
    pub const VPAD_BUTTON_L: Type = 32;
    #[doc = "! The R button."]
    pub const VPAD_BUTTON_R: Type = 16;
    #[doc = "! The + button."]
    pub const VPAD_BUTTON_PLUS: Type = 8;
    #[doc = "! The - button."]
    pub const VPAD_BUTTON_MINUS: Type = 4;
    #[doc = "! The HOME button."]
    pub const VPAD_BUTTON_HOME: Type = 2;
    #[doc = "! The SYNC button."]
    pub const VPAD_BUTTON_SYNC: Type = 1;
    #[doc = "! The right stick button."]
    pub const VPAD_BUTTON_STICK_R: Type = 131072;
    #[doc = "! The left stick button."]
    pub const VPAD_BUTTON_STICK_L: Type = 262144;
    #[doc = "! The TV button."]
    pub const VPAD_BUTTON_TV: Type = 65536;
    #[doc = "! The emulated left button on the right stick."]
    pub const VPAD_STICK_R_EMULATION_LEFT: Type = 67108864;
    #[doc = "! The emulated right button on the right stick."]
    pub const VPAD_STICK_R_EMULATION_RIGHT: Type = 33554432;
    #[doc = "! The emulated up button on the right stick."]
    pub const VPAD_STICK_R_EMULATION_UP: Type = 16777216;
    #[doc = "! The emulated down button on the right stick."]
    pub const VPAD_STICK_R_EMULATION_DOWN: Type = 8388608;
    #[doc = "! The emulated left button on the left stick."]
    pub const VPAD_STICK_L_EMULATION_LEFT: Type = 1073741824;
    #[doc = "! The emulated right button on the left stick."]
    pub const VPAD_STICK_L_EMULATION_RIGHT: Type = 536870912;
    #[doc = "! The emulated up button on the left stick."]
    pub const VPAD_STICK_L_EMULATION_UP: Type = 268435456;
    #[doc = "! The emulated down button on the left stick."]
    pub const VPAD_STICK_L_EMULATION_DOWN: Type = 134217728;
}
pub mod VPADChan {
    #[doc = "! Wii U GamePad channel."]
    pub type Type = cty::c_uint;
    #[doc = "! Channel 0."]
    pub const VPAD_CHAN_0: Type = 0;
}
pub mod VPADTouchPadValidity {
    #[doc = "! Touch pad validity."]
    pub type Type = cty::c_uint;
    #[doc = "! Both X and Y touchpad positions are accurate."]
    pub const VPAD_VALID: Type = 0;
    #[doc = "! X position is inaccurate."]
    pub const VPAD_INVALID_X: Type = 1;
    #[doc = "! Y position is inaccurate."]
    pub const VPAD_INVALID_Y: Type = 2;
}
pub mod VPADTouchPadResolution {
    #[doc = "! Touch pad resolution."]
    pub type Type = cty::c_uint;
    #[doc = "! 1920 x 1080 resolution."]
    pub const VPAD_TP_1920X1080: Type = 0;
    #[doc = "! 1280 x 720 resolution."]
    pub const VPAD_TP_1280X720: Type = 1;
    #[doc = "! 854 x 480 resolution."]
    pub const VPAD_TP_854X480: Type = 2;
}
pub mod VPADReadError {
    #[doc = "! Read error."]
    pub type Type = cty::c_int;
    #[doc = "! No error occurred, and data was written to the buffers."]
    pub const VPAD_READ_SUCCESS: Type = 0;
    #[doc = "! There was no sample new data available to write."]
    pub const VPAD_READ_NO_SAMPLES: Type = -1;
    #[doc = "! The requested controller or channel was invalid."]
    pub const VPAD_READ_INVALID_CONTROLLER: Type = -2;
}
pub mod VPADLcdMode {
    #[doc = "! LCD mode."]
    pub type Type = cty::c_uint;
    #[doc = "! Display is in standby and will turn back on if any buttons are pressed."]
    pub const VPAD_LCD_STANDBY: Type = 0;
    #[doc = "! Display is completely off and will remain so until explicitly changed."]
    pub const VPAD_LCD_OFF: Type = 1;
    #[doc = "! Display is on as normal."]
    pub const VPAD_LCD_ON: Type = 255;
}
#[doc = "! 2D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADVec2D {
    #[doc = "! x."]
    pub x: f32,
    #[doc = "! y."]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_VPADVec2D() {
    assert_eq!(
        ::core::mem::size_of::<VPADVec2D>(),
        8usize,
        concat!("Size of: ", stringify!(VPADVec2D))
    );
    assert_eq!(
        ::core::mem::align_of::<VPADVec2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VPADVec2D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADVec2D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADVec2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADVec2D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADVec2D),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "! 3D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADVec3D {
    #[doc = "! x."]
    pub x: f32,
    #[doc = "! y."]
    pub y: f32,
    #[doc = "! z."]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_VPADVec3D() {
    assert_eq!(
        ::core::mem::size_of::<VPADVec3D>(),
        12usize,
        concat!("Size of: ", stringify!(VPADVec3D))
    );
    assert_eq!(
        ::core::mem::align_of::<VPADVec3D>(),
        4usize,
        concat!("Alignment of ", stringify!(VPADVec3D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADVec3D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADVec3D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADVec3D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADVec3D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADVec3D>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADVec3D),
            "::",
            stringify!(z)
        )
    );
}
#[doc = "! Direction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADDirection {
    #[doc = "! x."]
    pub x: VPADVec3D,
    #[doc = "! y."]
    pub y: VPADVec3D,
    #[doc = "! z."]
    pub z: VPADVec3D,
}
#[test]
fn bindgen_test_layout_VPADDirection() {
    assert_eq!(
        ::core::mem::size_of::<VPADDirection>(),
        36usize,
        concat!("Size of: ", stringify!(VPADDirection))
    );
    assert_eq!(
        ::core::mem::align_of::<VPADDirection>(),
        4usize,
        concat!("Alignment of ", stringify!(VPADDirection))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADDirection>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADDirection),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADDirection>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADDirection),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADDirection>())).z as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADDirection),
            "::",
            stringify!(z)
        )
    );
}
#[doc = "! Touch calibration parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADTouchCalibrationParam {
    #[doc = "! X offset."]
    pub adjustX: u16,
    #[doc = "! Y offset."]
    pub adjustY: u16,
    #[doc = "! X scale."]
    pub scaleX: f32,
    #[doc = "! Y scale."]
    pub scaleY: f32,
}
#[test]
fn bindgen_test_layout_VPADTouchCalibrationParam() {
    assert_eq!(
        ::core::mem::size_of::<VPADTouchCalibrationParam>(),
        12usize,
        concat!("Size of: ", stringify!(VPADTouchCalibrationParam))
    );
    assert_eq!(
        ::core::mem::align_of::<VPADTouchCalibrationParam>(),
        4usize,
        concat!("Alignment of ", stringify!(VPADTouchCalibrationParam))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<VPADTouchCalibrationParam>())).adjustX as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchCalibrationParam),
            "::",
            stringify!(adjustX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<VPADTouchCalibrationParam>())).adjustY as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchCalibrationParam),
            "::",
            stringify!(adjustY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<VPADTouchCalibrationParam>())).scaleX as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchCalibrationParam),
            "::",
            stringify!(scaleX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<VPADTouchCalibrationParam>())).scaleY as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchCalibrationParam),
            "::",
            stringify!(scaleY)
        )
    );
}
#[doc = "! Touch data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADTouchData {
    #[doc = "! The x-coordinate of a touched point."]
    pub x: u16,
    #[doc = "! The y-coordinate of a touched point."]
    pub y: u16,
    #[doc = "! 0 if screen is not currently being touched."]
    pub touched: u16,
    #[doc = "! Bitfield of #VPADTouchPadValidity to indicate how touch sample accuracy."]
    pub validity: u16,
}
#[test]
fn bindgen_test_layout_VPADTouchData() {
    assert_eq!(
        ::core::mem::size_of::<VPADTouchData>(),
        8usize,
        concat!("Size of: ", stringify!(VPADTouchData))
    );
    assert_eq!(
        ::core::mem::align_of::<VPADTouchData>(),
        2usize,
        concat!("Alignment of ", stringify!(VPADTouchData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADTouchData>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchData),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADTouchData>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchData),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADTouchData>())).touched as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchData),
            "::",
            stringify!(touched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADTouchData>())).validity as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADTouchData),
            "::",
            stringify!(validity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADAccStatus {
    pub acc: VPADVec3D,
    pub magnitude: f32,
    pub variation: f32,
    pub vertical: VPADVec2D,
}
#[test]
fn bindgen_test_layout_VPADAccStatus() {
    assert_eq!(
        ::core::mem::size_of::<VPADAccStatus>(),
        28usize,
        concat!("Size of: ", stringify!(VPADAccStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<VPADAccStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(VPADAccStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADAccStatus>())).acc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADAccStatus),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADAccStatus>())).magnitude as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADAccStatus),
            "::",
            stringify!(magnitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADAccStatus>())).variation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADAccStatus),
            "::",
            stringify!(variation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADAccStatus>())).vertical as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADAccStatus),
            "::",
            stringify!(vertical)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADStatus {
    #[doc = "! Indicates what VPADButtons are held down."]
    pub hold: u32,
    #[doc = "! Indicates what VPADButtons have been pressed since last sample."]
    pub trigger: u32,
    #[doc = "! Indicates what VPADButtons have been released since last sample."]
    pub release: u32,
    #[doc = "! Position of left analog stick."]
    pub leftStick: VPADVec2D,
    #[doc = "! Position of right analog stick."]
    pub rightStick: VPADVec2D,
    #[doc = "! Status of DRC accelorometer."]
    pub accelorometer: VPADAccStatus,
    #[doc = "! Status of DRC gyro."]
    pub gyro: VPADVec3D,
    #[doc = "! Status of DRC angle."]
    pub angle: VPADVec3D,
    pub error: u8,
    pub __unk64: [cty::c_char; 1usize],
    #[doc = "! Current touch position on DRC."]
    pub tpNormal: VPADTouchData,
    #[doc = "! Filtered touch position, first level of smoothing."]
    pub tpFiltered1: VPADTouchData,
    #[doc = "! Filtered touch position, second level of smoothing."]
    pub tpFiltered2: VPADTouchData,
    pub __unk65: [cty::c_char; 2usize],
    pub direction: VPADDirection,
    #[doc = "! Set to 1 if headphones are plugged in, 0 otherwise."]
    pub usingHeadphones: BOOL,
    #[doc = "! Status of DRC magnetometer."]
    pub mag: VPADVec3D,
    #[doc = "! Current volume set by the slide control."]
    pub slideVolume: u8,
    #[doc = "! Battery level of controller."]
    pub battery: u8,
    #[doc = "! Status of DRC microphone."]
    pub micStatus: u8,
    #[doc = "! Unknown volume related value."]
    pub slideVolumeEx: u8,
    pub __unk66: [cty::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_VPADStatus() {
    assert_eq!(
        ::core::mem::size_of::<VPADStatus>(),
        172usize,
        concat!("Size of: ", stringify!(VPADStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<VPADStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(VPADStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).hold as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).trigger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).leftStick as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(leftStick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).rightStick as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(rightStick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).accelorometer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(accelorometer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).gyro as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(gyro)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).angle as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).error as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).__unk64 as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(__unk64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).tpNormal as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(tpNormal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).tpFiltered1 as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(tpFiltered1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).tpFiltered2 as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(tpFiltered2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).__unk65 as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(__unk65)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).direction as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).usingHeadphones as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(usingHeadphones)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).mag as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(mag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).slideVolume as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(slideVolume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).battery as *const _ as usize },
        161usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(battery)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).micStatus as *const _ as usize },
        162usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(micStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).slideVolumeEx as *const _ as usize },
        163usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(slideVolumeEx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<VPADStatus>())).__unk66 as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(VPADStatus),
            "::",
            stringify!(__unk66)
        )
    );
}
extern "C" {
    #[doc = " Initialises the VPAD library for use."]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = " As of Cafe OS 5.5.x (OSv10 v15702) this function simply logs a deprecation"]
    #[doc = " message and returns. However, this may not be the case on older versions."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\link VPADShutdown \\endlink"]
    pub fn VPADInit();
}
extern "C" {
    #[doc = " Cleans up and frees the VPAD library."]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = " As of Cafe OS 5.5.x (OSv10 v15702) this function simply logs a deprecation"]
    #[doc = " message and returns. However, this may not be the case on older versions."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\link VPADShutdown \\endlink"]
    pub fn VPADShutdown();
}
extern "C" {
    #[doc = " Read controller data from the desired Gamepad."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel to read from."]
    #[doc = ""]
    #[doc = " \\param buffers"]
    #[doc = " Pointer to an array of VPADStatus buffers to fill."]
    #[doc = ""]
    #[doc = " \\param count"]
    #[doc = " Number of buffers to fill."]
    #[doc = ""]
    #[doc = " \\param outError"]
    #[doc = " Pointer to write read error to (if any). See #VPADReadError for meanings."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " You must check outError - the VPADStatus buffers may be filled with random"]
    #[doc = " or invalid data on error, not necessarily zeroes."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " 0 on success or 1 on failure. Check outError for reason."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - VPADStatus"]
    pub fn VPADRead(
        chan: VPADChan::Type,
        buffers: *mut VPADStatus,
        count: u32,
        outError: *mut VPADReadError::Type,
    ) -> i32;
}
extern "C" {
    #[doc = " Get touch pad calibration parameters."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " Denotes which channel to get the calibration parameter from."]
    #[doc = ""]
    #[doc = " \\param outParam"]
    #[doc = " Pointer to the calibration to get."]
    pub fn VPADGetTPCalibrationParam(
        chan: VPADChan::Type,
        outParam: *mut VPADTouchCalibrationParam,
    );
}
extern "C" {
    #[doc = " Set touch pad calibration parameters."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " Denotes which channel to set the calibration parameter to."]
    #[doc = ""]
    #[doc = " \\param param"]
    #[doc = " Pointer to the calibration to set."]
    pub fn VPADSetTPCalibrationParam(chan: VPADChan::Type, param: *const VPADTouchCalibrationParam);
}
extern "C" {
    #[doc = " Transform touch data according to the current calibration data."]
    #[doc = " The calibration used may either be the system default or set by the"]
    #[doc = " application via VPADSetTPCalibrationParam()."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " Denotes which channel to get the calibration data from."]
    #[doc = ""]
    #[doc = " \\param calibratedData"]
    #[doc = " Pointer to write calibrated touch data to."]
    #[doc = ""]
    #[doc = " \\param uncalibratedData"]
    #[doc = " Pointer to the source data to apply the calibration to."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - VPADTouchData"]
    pub fn VPADGetTPCalibratedPoint(
        chan: VPADChan::Type,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
}
extern "C" {
    #[doc = " Transform touch data according to the current calibration data."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " Denotes which channel to get the calibration data from."]
    #[doc = ""]
    #[doc = " \\param tpResolution"]
    #[doc = " Touchpad resolution."]
    #[doc = ""]
    #[doc = " \\param calibratedData"]
    #[doc = " Pointer to write calibrated touch data to."]
    #[doc = ""]
    #[doc = " \\param uncalibratedData"]
    #[doc = " Pointer to the source data to apply the calibration to."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - VPADTouchData"]
    pub fn VPADGetTPCalibratedPointEx(
        chan: VPADChan::Type,
        tpResolution: VPADTouchPadResolution::Type,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
}
extern "C" {
    #[doc = " Return a count representing the amount of time left for the given Gamepad's"]
    #[doc = " rumble pattern."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " Denotes which channel to get the rumble time from."]
    pub fn VPADBASEGetMotorOnRemainingCount(chan: VPADChan::Type) -> i32;
}
extern "C" {
    #[doc = " Set a count representing the amount of time left for the given Gamepad's"]
    #[doc = " rumble pattern."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " Denotes which channel to set the rumble count for."]
    #[doc = ""]
    #[doc = " \\param counter"]
    #[doc = " The value of the new rumble count."]
    #[doc = ""]
    #[doc = " <!-- meta: I assume this affects the index into the rumble pattern? -->"]
    pub fn VPADBASESetMotorOnRemainingCount(chan: VPADChan::Type, counter: i32) -> i32;
}
extern "C" {
    pub fn VPADSetAccParam(chan: VPADChan::Type, playRadius: f32, sensitivity: f32);
}
extern "C" {
    pub fn VPADGetAccParam(chan: VPADChan::Type, outPlayRadius: *mut f32, outSensitivity: *mut f32);
}
extern "C" {
    #[doc = " Set a repeat for held buttons - instead of appearing to be continually held,"]
    #[doc = " repeated presses and releases will be simulated at the given frequency. This"]
    #[doc = " is similar to what happens with most computer keyboards when you hold a key."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " Denotes which channel to set up button repeat on."]
    #[doc = ""]
    #[doc = " \\param delaySec"]
    #[doc = " The amount of time, in seconds, to wait until a button should start"]
    #[doc = " repeating."]
    #[doc = ""]
    #[doc = " \\param pulseSec"]
    #[doc = " The amount of time to wait between simulated presses - effectively setting"]
    #[doc = " the period of the repetition."]
    pub fn VPADSetBtnRepeat(chan: VPADChan::Type, delaySec: f32, pulseSec: f32);
}
extern "C" {
    pub fn VPADEnableStickCrossClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableStickCrossClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADSetLStickClampThreshold(chan: VPADChan::Type, max: i32, min: i32);
}
extern "C" {
    pub fn VPADSetRStickClampThreshold(chan: VPADChan::Type, max: i32, min: i32);
}
extern "C" {
    pub fn VPADGetLStickClampThreshold(chan: VPADChan::Type, max: *mut i32, min: *mut i32);
}
extern "C" {
    pub fn VPADGetRStickClampThreshold(chan: VPADChan::Type, max: *mut i32, min: *mut i32);
}
extern "C" {
    pub fn VPADSetStickOrigin(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableLStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableRStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableLStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableRStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADSetCrossStickEmulationParamsL(
        chan: VPADChan::Type,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
}
extern "C" {
    pub fn VPADSetCrossStickEmulationParamsR(
        chan: VPADChan::Type,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
}
extern "C" {
    pub fn VPADGetCrossStickEmulationParamsL(
        chan: VPADChan::Type,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
}
extern "C" {
    pub fn VPADGetCrossStickEmulationParamsR(
        chan: VPADChan::Type,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
}
extern "C" {
    pub fn VPADSetGyroAngle(chan: VPADChan::Type, ax: f32, ay: f32, az: f32);
}
extern "C" {
    pub fn VPADSetGyroDirection(chan: VPADChan::Type, dir: *mut VPADDirection);
}
extern "C" {
    pub fn VPADSetGyroDirectionMag(chan: VPADChan::Type, mag: f32);
}
extern "C" {
    pub fn VPADSetGyroMagnification(chan: VPADChan::Type, pitch: f32, yaw: f32, roll: f32);
}
extern "C" {
    pub fn VPADEnableGyroZeroPlay(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableGyroDirRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableGyroAccRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableGyroZeroPlay(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableGyroDirRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableGyroAccRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADIsEnableGyroZeroPlay(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroZeroDrift(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroDirRevise(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroAccRevise(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADSetGyroZeroPlayParam(chan: VPADChan::Type, radius: f32);
}
extern "C" {
    pub fn VPADInitGyroZeroPlayParam(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADInitGyroDirReviseParam(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADInitGyroAccReviseParam(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADInitGyroZeroDriftMode(chan: VPADChan::Type);
}
extern "C" {
    #[doc = " Turns on the rumble motor on the desired Gamepad."]
    #[doc = " A custom rumble pattern can be set by setting bytes in the input buffer."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel of the Gamepad to rumble."]
    #[doc = ""]
    #[doc = " \\param pattern"]
    #[doc = " Pointer to an array of bytes, where each byte represents the status of the"]
    #[doc = " rumble at a given time. 0xFF denotes rumble while 0x00 denotes no rumble."]
    #[doc = ""]
    #[doc = " \\param length"]
    #[doc = " The size of the rumble pattern, in bytes."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " meta: find out if the bytes in buffer are an analog intensity control (e.g"]
    #[doc = " is 0x7F \"half intensity\"?) or are simply binary motor on/off toggles"]
    #[doc = " \\endif"]
    pub fn VPADControlMotor(chan: VPADChan::Type, pattern: *mut u8, length: u8) -> i32;
}
extern "C" {
    #[doc = " Stops the desired Gamepad's rumble motor and cancels any ongoing rumble"]
    #[doc = " pattern."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel of the Gamepad to stop rumbling."]
    pub fn VPADStopMotor(chan: VPADChan::Type);
}
extern "C" {
    #[doc = " Sets the current mode of the display on the given Gamepad. This function can"]
    #[doc = " be used to turn the display on and off, or place it in standby."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel of the Gamepad to have its display mode changed."]
    #[doc = ""]
    #[doc = " \\param lcdMode"]
    #[doc = " One of \\link VPADLcdMode \\endlink representing the new status of the display."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value on error."]
    pub fn VPADSetLcdMode(chan: VPADChan::Type, lcdMode: VPADLcdMode::Type) -> i32;
}
extern "C" {
    #[doc = " Get the current status of the given Gamepad's display."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel of the Gamepad to get the display mode from."]
    #[doc = ""]
    #[doc = " \\param outLcdMode"]
    #[doc = " Pointer to write a value of \\link VPADLcdMode \\endlink into."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value on error."]
    pub fn VPADGetLcdMode(chan: VPADChan::Type, outLcdMode: *mut VPADLcdMode::Type) -> i32;
}
extern "C" {
    pub fn VPADBASESetSensorBarSetting(chan: VPADChan::Type, setting: i8);
}
extern "C" {
    pub fn VPADBASEGetSensorBarSetting(chan: VPADChan::Type, outSetting: *mut i8);
}
extern "C" {
    #[doc = " Turn the given Gamepad's sensor bar on or off. Enabling the sensor bar allows"]
    #[doc = " any Wii Remote to position itself relative to the GamePad."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Retail Wii U systems have a single Gamepad on \\link VPADChan::VPAD_CHAN_0"]
    #[doc = " VPAD_CHAN_0. \\endlink"]
    #[doc = ""]
    #[doc = " \\param chan"]
    #[doc = " The channel of the Gamepad to control the sensor bar on."]
    #[doc = ""]
    #[doc = " \\param on"]
    #[doc = " \\c true to enable the sensor bar, \\c false to disable it."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value on error."]
    pub fn VPADSetSensorBar(chan: VPADChan::Type, on: BOOL) -> i32;
}
pub mod HIDAttachEvent {
    pub type Type = cty::c_uint;
    pub const HID_DEVICE_DETACH: Type = 0;
    pub const HID_DEVICE_ATTACH: Type = 1;
}
pub type HIDAttachCallback = ::core::option::Option<
    unsafe extern "C" fn(
        client: *mut HIDClient,
        device: *mut HIDDevice,
        attach: HIDAttachEvent::Type,
    ) -> i32,
>;
pub type HIDCallback = ::core::option::Option<
    unsafe extern "C" fn(
        handle: u32,
        error: i32,
        buffer: *mut u8,
        bytesTransferred: u32,
        userContext: *mut cty::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIDDevice {
    pub handle: u32,
    pub physicalDeviceInst: u32,
    pub vid: u16,
    pub pid: u16,
    pub interfaceIndex: u8,
    pub subClass: u8,
    pub protocol: u8,
    pub __unk67: [cty::c_char; 1usize],
    pub maxPacketSizeRx: u16,
    pub maxPacketSizeTx: u16,
}
#[test]
fn bindgen_test_layout_HIDDevice() {
    assert_eq!(
        ::core::mem::size_of::<HIDDevice>(),
        20usize,
        concat!("Size of: ", stringify!(HIDDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<HIDDevice>(),
        4usize,
        concat!("Alignment of ", stringify!(HIDDevice))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).physicalDeviceInst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(physicalDeviceInst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).vid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(vid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).pid as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).interfaceIndex as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(interfaceIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).subClass as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(subClass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).protocol as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).__unk67 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(__unk67)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).maxPacketSizeRx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(maxPacketSizeRx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDDevice>())).maxPacketSizeTx as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDDevice),
            "::",
            stringify!(maxPacketSizeTx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIDClient {
    pub next: *mut HIDClient,
    pub attachCallback: HIDAttachCallback,
}
#[test]
fn bindgen_test_layout_HIDClient() {
    assert_eq!(
        ::core::mem::size_of::<HIDClient>(),
        8usize,
        concat!("Size of: ", stringify!(HIDClient))
    );
    assert_eq!(
        ::core::mem::align_of::<HIDClient>(),
        4usize,
        concat!("Alignment of ", stringify!(HIDClient))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDClient>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDClient),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HIDClient>())).attachCallback as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HIDClient),
            "::",
            stringify!(attachCallback)
        )
    );
}
extern "C" {
    pub fn HIDSetup() -> i32;
}
extern "C" {
    pub fn HIDTeardown() -> i32;
}
extern "C" {
    pub fn HIDAddClient(client: *mut HIDClient, attachCallback: HIDAttachCallback) -> i32;
}
extern "C" {
    pub fn HIDDelClient(client: *mut HIDClient) -> i32;
}
extern "C" {
    pub fn HIDGetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetIdle(
        handle: u32,
        interfaceIndex: u8,
        duration: u8,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: u8,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: *mut u8,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDRead(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDWrite(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        hc: HIDCallback,
        userContext: *mut cty::c_void,
    ) -> i32;
}
#[doc = "! A handle to a NSSL context created with NSSLCreateContext()."]
pub type NSSLContextHandle = i32;
#[doc = "! A handle to a NSSL connection created with NSSLCreateConnection()."]
pub type NSSLConnectionHandle = i32;
pub mod NSSLServerCertId {
    #[doc = " The IDs of a system CA. These certificates are built-in to the system and can"]
    #[doc = " be added to a NSSL context with NSSLAddServerPKI()."]
    #[doc = ""]
    #[doc = " The names and fingerprints given in this documentation are taken from the"]
    #[doc = " real certificates inside the Wii U's CDN package."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " Certificate list taken from 0005001B-10054000/content/certstore_metadata.txt"]
    #[doc = " \\endif"]
    pub type Type = cty::c_uint;
    #[doc = "! Represents the first certificate in the Nintendo CA group."]
    pub const NSSL_SERVER_CERT_GROUP_NINTENDO_FIRST: Type = 100;
    #[doc = "! Nintendo CA"]
    #[doc = "! (SHA1: B5 22 94 55 DD 26 C1 F5 3C 73 06 0E 90 89 B3 91 38 9E 1F 75)"]
    pub const NSSL_SERVER_CERT_NINTENDO_CA: Type = 100;
    #[doc = "! Nintendo CA - G2"]
    #[doc = "! (SHA1: C6 0B 2A 5C C9 0F 06 30 CC A3 30 40 DF 6B 33 78 23 9F 3B FA)"]
    pub const NSSL_SERVER_CERT_NINTENDO_CA_G2: Type = 101;
    #[doc = "! Nintendo CA - G3"]
    #[doc = "! (SHA1: 68 A0 77 05 CC C7 A4 08 41 6E 0E D7 AD 65 F2 EC 3F EA 98 62)"]
    pub const NSSL_SERVER_CERT_NINTENDO_CA_G3: Type = 102;
    #[doc = "! Nintendo Class 2 CA"]
    #[doc = "! (SHA1: AA 8E F6 6A E0 F8 07 ED B8 41 C8 89 EE 36 66 A2 59 A2 8C CC)"]
    pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA: Type = 103;
    #[doc = "! Nintendo Class 2 CA - G2"]
    #[doc = "! (SHA1: 03 9D E5 37 3A C6 5E 1A EE 89 8D 54 E7 56 35 76 EB BE 54 9B)"]
    pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA_G2: Type = 104;
    #[doc = "! Nintendo Class 2 CA - G3"]
    #[doc = "! (SHA1: FA B5 6C 4C C7 CF F5 07 1D 40 B6 B0 07 38 61 D2 90 CA 2A 1A)"]
    pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA_G3: Type = 105;
    #[doc = "! Represents the last certificate in the Nintendo CA group."]
    pub const NSSL_SERVER_CERT_GROUP_NINTENDO_LAST: Type = 105;
    #[doc = "! Represents the first certificate in the commercial CA group."]
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_FIRST: Type = 1001;
    #[doc = "! Baltimore CyberTrust Root"]
    #[doc = "! (SHA1: D4 DE 20 D0 5E 66 FC 53 FE 1A 50 88 2C 78 DB 28 52 CA E4 74)"]
    pub const NSSL_SERVER_CERT_BALTIMORE_CYBERTRUST_ROOT_CA: Type = 1001;
    #[doc = "! Cybertrust Global Root"]
    #[doc = "! (SHA1: 5F 43 E5 B1 BF F8 78 8C AC 1C C7 CA 4A 9A C6 22 2B CC 34 C6)"]
    pub const NSSL_SERVER_CERT_CYBERTRUST_GLOBAL_ROOT_CA: Type = 1002;
    #[doc = "! Verizon Global Root"]
    #[doc = "! (SHA1: 91 21 98 EE F2 3D CA C4 09 39 31 2F EE 97 DD 56 0B AE 49 B1)"]
    pub const NSSL_SERVER_CERT_VERIZON_GLOBAL_ROOT_CA: Type = 1003;
    #[doc = "! GlobalSign Root CA"]
    #[doc = "! (SHA1: B1 BC 96 8B D4 F4 9D 62 2A A8 9A 81 F2 15 01 52 A4 1D 82 9C)"]
    pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA: Type = 1004;
    #[doc = "! GlobalSign"]
    #[doc = "! (SHA1: 75 E0 AB B6 13 85 12 27 1C 04 F8 5F DD DE 38 E4 B7 24 2E FE)"]
    pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA_R2: Type = 1005;
    #[doc = "! GlobalSign"]
    #[doc = "! (SHA1: D6 9B 56 11 48 F0 1C 77 C5 45 78 C1 09 26 DF 5B 85 69 76 AD)"]
    pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA_R3: Type = 1006;
    #[doc = "! VeriSign Class 3 Public Primary Certification Authority - G3"]
    #[doc = "! (SHA1: 13 2D 0D 45 53 4B 69 97 CD B2 D5 C3 39 E2 55 76 60 9B 5C C6)"]
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G3: Type = 1007;
    #[doc = "! VeriSign Universal Root Certification Authority"]
    #[doc = "! (SHA1: 36 79 CA 35 66 87 72 30 4D 30 A5 FB 87 3B 0F A7 7B B7 0D 54)"]
    pub const NSSL_SERVER_CERT_VERISIGN_UNIVERSAL_ROOT_CA: Type = 1008;
    #[doc = "! VeriSign Class 3 Public Primary Certification Authority - G5"]
    #[doc = "! (SHA1: 4E B6 D5 78 49 9B 1C CF 5F 58 1E AD 56 BE 3D 9B 67 44 A5 E5)"]
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G5: Type = 1009;
    #[doc = "! thawte Primary Root CA - G3"]
    #[doc = "! (SHA1: F1 8B 53 8D 1B E9 03 B6 A6 F0 56 43 5B 17 15 89 CA F3 6B F2)"]
    pub const NSSL_SERVER_CERT_THAWTE_PRIMARY_ROOT_CA_G3: Type = 1010;
    #[doc = "! thawte Primary Root CA"]
    #[doc = "! (SHA1: 91 C6 D6 EE 3E 8A C8 63 84 E5 48 C2 99 29 5C 75 6C 81 7B 81)"]
    pub const NSSL_SERVER_CERT_THAWTE_PRIMARY_ROOT_CA: Type = 1011;
    #[doc = "! GeoTrust Global CA"]
    #[doc = "! (SHA1: DE 28 F4 A4 FF E5 B9 2F A3 C5 03 D1 A3 49 A7 F9 96 2A 82 12)"]
    pub const NSSL_SERVER_CERT_GEOTRUST_GLOBAL_CA: Type = 1012;
    #[doc = "! GeoTrust Global CA 2"]
    #[doc = "! (SHA1: A9 E9 78 08 14 37 58 88 F2 05 19 B0 6D 2B 0D 2B 60 16 90 7D)"]
    pub const NSSL_SERVER_CERT_GEOTRUST_GLOBAL_CA2: Type = 1013;
    #[doc = "! GeoTrust Primary Certification Authority"]
    #[doc = "! (SHA1: 32 3C 11 8E 1B F7 B8 B6 52 54 E2 E2 10 0D D6 02 90 37 F0 96)"]
    pub const NSSL_SERVER_CERT_GEOTRUST_PRIMARY_CA: Type = 1014;
    #[doc = "! GeoTrust Primary Certification Authority - G3"]
    #[doc = "! (SHA1: 03 9E ED B8 0B E7 A0 3C 69 53 89 3B 20 D2 D9 32 3A 4C 2A FD)"]
    pub const NSSL_SERVER_CERT_GEOTRUST_PRIMARY_CA_G3: Type = 1015;
    #[doc = "! AddTrust External CA Root"]
    #[doc = "! (SHA1: 02 FA F3 E2 91 43 54 68 60 78 57 69 4D F5 E4 5B 68 85 18 68)"]
    pub const NSSL_SERVER_CERT_ADDTRUST_EXT_CA_ROOT: Type = 1016;
    #[doc = "! COMODO Certification Authority"]
    #[doc = "! (SHA1: EE 86 93 87 FF FD 83 49 AB 5A D1 43 22 58 87 89 A4 57 B0 12)"]
    pub const NSSL_SERVER_CERT_COMODO_CA: Type = 1017;
    #[doc = "! UTN - DATACorp SGC"]
    #[doc = "! (SHA1: 58 11 9F 0E 12 82 87 EA 50 FD D9 87 45 6F 4F 78 DC FA D6 D4)"]
    pub const NSSL_SERVER_CERT_UTN_DATACORP_SGC_CA: Type = 1018;
    #[doc = "! UTN-USERFirst-Hardware"]
    #[doc = "! (SHA1: 04 83 ED 33 99 AC 36 08 05 87 22 ED BC 5E 46 00 E3 BE F9 D7)"]
    pub const NSSL_SERVER_CERT_UTN_USERFIRST_HARDWARE_CA: Type = 1019;
    #[doc = "! DigiCert High Assurance EV Root CA"]
    #[doc = "! (SHA1: 5F B7 EE 06 33 E2 59 DB AD 0C 4C 9A E6 D3 8F 1A 61 C7 DC 25)"]
    pub const NSSL_SERVER_CERT_DIGICERT_HIGH_ASSURANCE_EV_ROOT_CA: Type = 1020;
    #[doc = "! DigiCert Assured ID Root CA"]
    #[doc = "! (SHA1: 05 63 B8 63 0D 62 D7 5A BB C8 AB 1E 4B DF B5 A8 99 B2 4D 43)"]
    pub const NSSL_SERVER_CERT_DIGICERT_ASSURED_ID_ROOT_CA: Type = 1021;
    #[doc = "! DigiCert Global Root CA"]
    #[doc = "! (SHA1: A8 98 5D 3A 65 E5 E5 C4 B2 D7 D6 6D 40 C6 DD 2F B1 9C 54 36)"]
    pub const NSSL_SERVER_CERT_DIGICERT_GLOBAL_ROOT_CA: Type = 1022;
    #[doc = "! GTE CyberTrust Global Root"]
    #[doc = "! (SHA1: 97 81 79 50 D8 1C 96 70 CC 34 D8 09 CF 79 44 31 36 7E F4 74)"]
    pub const NSSL_SERVER_CERT_GTE_CYBERTRUST_GLOBAL_ROOT: Type = 1023;
    #[doc = "! [No common name]"]
    #[doc = "! (SHA1: A1 DB 63 93 91 6F 17 E4 18 55 09 40 04 15 C7 02 40 B0 AE 6B)"]
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA: Type = 1024;
    #[doc = "! Thawte Premium Server CA"]
    #[doc = "! (SHA1: 62 7F 8D 78 27 65 63 99 D2 7D 7F 90 44 C9 FE B3 F3 3E FA 9A)"]
    pub const NSSL_SERVER_CERT_THAWTE_PREMIUM_SERVER_CA: Type = 1025;
    #[doc = "! [No common name]"]
    #[doc = "! (SHA1: D2 32 09 AD 23 D3 14 23 21 74 E4 0D 7F 9D 62 13 97 86 63 3A)"]
    pub const NSSL_SERVER_CERT_EQUIFAX_SECURE_CA: Type = 1026;
    #[doc = "! Entrust.net Secure Server Certification Authority"]
    #[doc = "! (SHA1: 99 A6 9B E6 1A FE 88 6B 4D 2B 82 00 7C B8 54 FC 31 7E 15 39)"]
    pub const NSSL_SERVER_CERT_ENTRUST_SECURE_SERVER_CA: Type = 1027;
    #[doc = "! [No common name]"]
    #[doc = "! (SHA1: 85 37 1C A6 E5 50 14 3D CE 28 03 47 1B DE 3A 09 E8 F8 77 0F)"]
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G2: Type = 1028;
    #[doc = "! Entrust.net Certification Authority (2048)"]
    #[doc = "! (SHA1: 50 30 06 09 1D 97 D4 F5 AE 39 F7 CB E7 92 7D 7D 65 2D 34 31)"]
    pub const NSSL_SERVER_CERT_ENTRUST_CA_2048: Type = 1029;
    #[doc = "! Entrust Root Certification Authority"]
    #[doc = "! (SHA1: B3 1E B1 B7 40 E3 6C 84 02 DA DC 37 D4 4D F5 D4 67 49 52 F9)"]
    pub const NSSL_SERVER_CERT_ENTRUST_ROOT_CA: Type = 1030;
    #[doc = "! Entrust Root Certification Authority - G2"]
    #[doc = "! (SHA1: 8C F4 27 FD 79 0C 3A D1 66 06 8D E8 1E 57 EF BB 93 22 72 D4)"]
    pub const NSSL_SERVER_CERT_ENTRUST_ROOT_CA_G2: Type = 1031;
    #[doc = "! DigiCert Assured ID Root G2"]
    #[doc = "! (SHA1: A1 4B 48 D9 43 EE 0A 0E 40 90 4F 3C E0 A4 C0 91 93 51 5D 3F)"]
    pub const NSSL_SERVER_CERT_DIGICERT_ASSURED_ID_ROOT_CA_G2: Type = 1032;
    #[doc = "! DigiCert Global Root G2"]
    #[doc = "! (SHA1: DF 3C 24 F9 BF D6 66 76 1B 26 80 73 FE 06 D1 CC 8D 4F 82 A4)"]
    pub const NSSL_SERVER_CERT_DIGICERT_GLOBAL_ROOT_CA_G2: Type = 1033;
    #[doc = "! Represents the last certificate in the commerical CA group."]
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_LAST: Type = 1033;
    #[doc = "! Represents the first certificate in the 4096-bit commercial CA group."]
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_4096_FIRST: Type = 1900;
    #[doc = "! COMODO RSA Certification Authority"]
    #[doc = "! (SHA1: AF E5 D2 44 A8 D1 19 42 30 FF 47 9F E2 F8 97 BB CD 7A 8C B4)"]
    pub const NSSL_SERVER_CERT_COMODO_RSA_CA: Type = 1900;
    #[doc = "! USERTrust RSA Certification Authority"]
    #[doc = "! (SHA1: 2B 8F 1B 57 33 0D BB A2 D0 7A 6C 51 F7 0E E9 0D DA B9 AD 8E)"]
    pub const NSSL_SERVER_CERT_USERTRUST_RSA_CA: Type = 1901;
    #[doc = "! Represents the last certificate in the 4096-bit commercial CA group."]
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_4096_LAST: Type = 1901;
}
extern "C" {
    #[doc = " Initialises the NSSL library for use. This must be called before any other"]
    #[doc = " NSSL functions."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative error code on failure."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - NSSLFinish()"]
    pub fn NSSLInit() -> i32;
}
extern "C" {
    #[doc = " Cleans up and finishes use of the NSSL library."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or -1 on error."]
    pub fn NSSLFinish() -> i32;
}
extern "C" {
    #[doc = " Creates a context to use with the NSSL library. A context contains root CAs"]
    #[doc = " and connections."]
    #[doc = ""]
    #[doc = " \\param unk"]
    #[doc = " Unknown. A value of 0 appears to work."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A #NSSLContextHandle representing the newly created context, or a negative"]
    #[doc = " value on error."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - NSSLDestroyContext()"]
    pub fn NSSLCreateContext(unk: i32) -> NSSLContextHandle;
}
extern "C" {
    #[doc = " Destroys a NSSL context."]
    #[doc = ""]
    #[doc = " \\param context"]
    #[doc = " The NSSL context to destroy."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value if an error occurred."]
    pub fn NSSLDestroyContext(context: NSSLContextHandle) -> i32;
}
extern "C" {
    #[doc = " Add a custom root CA to the given NSSL context."]
    #[doc = ""]
    #[doc = " \\param context"]
    #[doc = " The NSSL context to add a root CA to."]
    #[doc = ""]
    #[doc = " \\param cert"]
    #[doc = " A pointer to a buffer containing the certificate data."]
    #[doc = ""]
    #[doc = " \\param length"]
    #[doc = " The length of the certificate buffer."]
    #[doc = ""]
    #[doc = " \\param unk"]
    #[doc = " Unknown."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value on error."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - NSSLAddServerPKI()"]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " meta: what format does the certificate need to be? The internal ones are"]
    #[doc = " x509 in binary DER. What's a working value for unk? 0?"]
    #[doc = " \\endif"]
    pub fn NSSLAddServerPKIExternal(
        context: NSSLContextHandle,
        cert: *const cty::c_void,
        length: i32,
        unk: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Add a system root CA (one of #NSSLServerCertId) to the given NSSL context."]
    #[doc = ""]
    #[doc = " \\param context"]
    #[doc = " The NSSL context to add a root CA to."]
    #[doc = ""]
    #[doc = " \\param pki"]
    #[doc = " The #NSSLServerCertId representing the system CA to add."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value on error."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - NSSLAddServerPKIExternal()"]
    pub fn NSSLAddServerPKI(context: NSSLContextHandle, pki: NSSLServerCertId::Type) -> i32;
}
extern "C" {
    #[doc = " Open an SSL connection."]
    #[doc = ""]
    #[doc = " \\param context"]
    #[doc = " The context to open the connection under."]
    #[doc = ""]
    #[doc = " \\param host"]
    #[doc = " The domain or IP of the host to connect to."]
    #[doc = ""]
    #[doc = " \\param hostLength"]
    #[doc = " The length of the \"host\" buffer."]
    #[doc = ""]
    #[doc = " \\param options"]
    #[doc = " Options for the underlying socket."]
    #[doc = ""]
    #[doc = " \\param socket"]
    #[doc = " An existing socket to use for the connection, or NULL."]
    #[doc = ""]
    #[doc = " \\param block"]
    #[doc = " If opening a new underlying socket, whether to open it in blocking mode."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A #NSSLConnectionHandle representing the current connection."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - NSSLRead()"]
    #[doc = " - NSSLWrite()"]
    #[doc = " - NSSLDestroyConnection()"]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " meta: kinda guessing socket and options here, needs confirmation"]
    #[doc = " \\endif"]
    pub fn NSSLCreateConnection(
        context: NSSLContextHandle,
        host: *const cty::c_char,
        hostLength: i32,
        options: i32,
        socket: i32,
        block: i32,
    ) -> NSSLConnectionHandle;
}
extern "C" {
    #[doc = " Close and destroy a NSSL connection."]
    #[doc = ""]
    #[doc = " \\param connection"]
    #[doc = " The connection to destroy."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success or a negative error value."]
    pub fn NSSLDestroyConnection(connection: NSSLConnectionHandle) -> i32;
}
extern "C" {
    #[doc = " Read data from an open NSSL connection into a given buffer."]
    #[doc = ""]
    #[doc = " \\param connection"]
    #[doc = " The connection to read data from."]
    #[doc = ""]
    #[doc = " \\param buffer"]
    #[doc = " A buffer to read decrypted data into."]
    #[doc = ""]
    #[doc = " \\param length"]
    #[doc = " The length of the given buffer."]
    #[doc = ""]
    #[doc = " \\param outBytesRead"]
    #[doc = " A pointer to write the actual number of read bytes into. This may be smaller"]
    #[doc = " than the input buffer."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value on error."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - NSSLWrite()"]
    pub fn NSSLRead(
        connection: NSSLConnectionHandle,
        buffer: *const cty::c_void,
        length: i32,
        outBytesRead: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Write data to an open NSSL connection from a given buffer."]
    #[doc = ""]
    #[doc = " \\param connection"]
    #[doc = " The connection to write data to."]
    #[doc = ""]
    #[doc = " \\param buffer"]
    #[doc = " A buffer containing the data to be sent."]
    #[doc = ""]
    #[doc = " \\param length"]
    #[doc = " The length of the given buffer."]
    #[doc = ""]
    #[doc = " \\param outBytesWritten"]
    #[doc = " A pointer to write the actual number of written bytes into. This may be"]
    #[doc = " smaller than the input buffer."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " 0 on success, or a negative value on error."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - NSSLRead()"]
    pub fn NSSLWrite(
        connection: NSSLConnectionHandle,
        buffer: *const cty::c_void,
        length: i32,
        outBytesWritten: *mut i32,
    ) -> i32;
}
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        4usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: cty::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pselect(
        __n: cty::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> cty::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type ulong = cty::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = cty::c_ulong;
pub type daddr_t = cty::c_long;
pub type caddr_t = *mut cty::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: cty::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: cty::c_int,
    pub stackaddr: *mut cty::c_void,
    pub stacksize: cty::c_int,
    pub contentionscope: cty::c_int,
    pub inheritsched: cty::c_int,
    pub schedpolicy: cty::c_int,
    pub schedparam: sched_param,
    pub detachstate: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).contentionscope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).inheritsched as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedpolicy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: cty::c_int,
    pub recursive: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutexattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).recursive as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: cty::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_condattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).clock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: cty::c_int,
    pub init_executed: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).init_executed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: cty::c_int,
    pub tz_dsttime: cty::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::core::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::core::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(
        ::core::mem::size_of::<bintime>(),
        16usize,
        concat!("Size of: ", stringify!(bintime))
    );
    assert_eq!(
        ::core::mem::align_of::<bintime>(),
        8usize,
        concat!("Alignment of ", stringify!(bintime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bintime>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bintime>())).frac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(frac)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::core::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: cty::c_int,
    pub tm_min: cty::c_int,
    pub tm_hour: cty::c_int,
    pub tm_mday: cty::c_int,
    pub tm_mon: cty::c_int,
    pub tm_year: cty::c_int,
    pub tm_wday: cty::c_int,
    pub tm_yday: cty::c_int,
    pub tm_isdst: cty::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut cty::c_char,
        _maxsize: size_t,
        _fmt: *const cty::c_char,
        _t: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut cty::c_char,
        _maxsize: size_t,
        _fmt: *const cty::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzrule_struct {
    pub ch: cty::c_char,
    pub m: cty::c_int,
    pub n: cty::c_int,
    pub d: cty::c_int,
    pub s: cty::c_int,
    pub change: time_t,
    pub offset: cty::c_long,
}
#[test]
fn bindgen_test_layout___tzrule_struct() {
    assert_eq!(
        ::core::mem::size_of::<__tzrule_struct>(),
        40usize,
        concat!("Size of: ", stringify!(__tzrule_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__tzrule_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__tzrule_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzrule_struct>())).ch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzrule_struct>())).m as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzrule_struct>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzrule_struct>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzrule_struct>())).s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzrule_struct>())).change as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzrule_struct>())).offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(offset)
        )
    );
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzinfo_struct {
    pub __tznorth: cty::c_int,
    pub __tzyear: cty::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
#[test]
fn bindgen_test_layout___tzinfo_struct() {
    assert_eq!(
        ::core::mem::size_of::<__tzinfo_struct>(),
        88usize,
        concat!("Size of: ", stringify!(__tzinfo_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__tzinfo_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__tzinfo_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzinfo_struct>())).__tznorth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tznorth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzinfo_struct>())).__tzyear as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tzyear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tzinfo_struct>())).__tzrule as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tzrule)
        )
    );
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: cty::c_long;
}
extern "C" {
    pub static mut _daylight: cty::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut cty::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: cty::c_int,
    pub sival_ptr: *mut cty::c_void,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::core::mem::size_of::<sigval>(),
        4usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::core::mem::align_of::<sigval>(),
        4usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: cty::c_int,
    pub sigev_signo: cty::c_int,
    pub sigev_value: sigval,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::core::mem::size_of::<sigevent>(),
        12usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent>(),
        4usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: cty::c_int,
    pub si_code: cty::c_int,
    pub si_value: sigval,
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>())).si_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_value)
        )
    );
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: cty::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::core::mem::size_of::<sigaction>(),
        12usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut cty::c_void,
    pub ss_flags: cty::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        ::core::mem::size_of::<sigaltstack>(),
        12usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaltstack>(),
        4usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(arg1: cty::c_int, arg2: *const sigset_t, arg3: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: cty::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigaction(arg1: cty::c_int, arg2: *const sigaction, arg3: *mut sigaction) -> cty::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigpause(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> cty::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: cty::c_int, arg3: sigval) -> cty::c_int;
}
pub type sig_atomic_t = cty::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(arg1: *mut _reent, arg2: cty::c_int, arg3: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn signal(arg1: cty::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn psignal(arg1: cty::c_int, arg2: *const cty::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: cty::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> cty::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn utimes(__path: *const cty::c_char, __tvp: *const timeval) -> cty::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> cty::c_int;
}
extern "C" {
    pub fn futimes(arg1: cty::c_int, arg2: *const timeval) -> cty::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const cty::c_char, arg2: *const timeval) -> cty::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> cty::c_int;
}
extern "C" {
    pub fn getitimer(__which: cty::c_int, __value: *mut itimerval) -> cty::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: cty::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut cty::c_void) -> cty::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<cty::c_char>,
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr>(),
        2usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub ss_padding: [cty::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_storage>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_storage>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: cty::c_int,
    pub l_linger: cty::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::core::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::core::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: cty::c_uint,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::core::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: cty::c_ushort,
    pub sin_port: cty::c_ushort,
    pub sin_addr: in_addr,
    pub sin_zero: [cty::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
extern "C" {
    pub fn socket_lib_init();
}
extern "C" {
    pub fn socket_lib_finish();
}
extern "C" {
    pub fn accept(sockfd: cty::c_int, addr: *mut sockaddr, addrlen: *mut socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn bind(sockfd: cty::c_int, addr: *const sockaddr, addrlen: socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn socketclose(sockfd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn connect(sockfd: cty::c_int, addr: *const sockaddr, addrlen: socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn getpeername(
        sockfd: cty::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn getsockname(
        sockfd: cty::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn getsockopt(
        sockfd: cty::c_int,
        level: cty::c_int,
        optname: cty::c_int,
        optval: *mut cty::c_void,
        optlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn listen(sockfd: cty::c_int, backlog: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn recv(
        sockfd: cty::c_int,
        buf: *mut cty::c_void,
        len: size_t,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn recvfrom(
        sockfd: cty::c_int,
        buf: *mut cty::c_void,
        len: size_t,
        flags: cty::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn send(
        sockfd: cty::c_int,
        buf: *const cty::c_void,
        len: size_t,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sendto(
        sockfd: cty::c_int,
        buf: *const cty::c_void,
        len: size_t,
        flags: cty::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn setsockopt(
        sockfd: cty::c_int,
        level: cty::c_int,
        optname: cty::c_int,
        optval: *const cty::c_void,
        optlen: socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: cty::c_int, how: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn socket(domain: cty::c_int, type_: cty::c_int, protocol: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn inet_ntoa(in_: in_addr) -> *const cty::c_char;
}
extern "C" {
    pub fn inet_ntoa_r(in_: in_addr, buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn inet_ntop(
        af: cty::c_int,
        src: *const cty::c_void,
        dst: *mut cty::c_char,
        size: socklen_t,
    ) -> *const cty::c_char;
}
extern "C" {
    pub fn inet_pton(af: cty::c_int, src: *const cty::c_char, dst: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn inet_aton(cp: *const cty::c_char, inp: *mut in_addr) -> cty::c_int;
}
extern "C" {
    pub fn socketlasterr() -> cty::c_int;
}
extern "C" {
    pub fn htonl(val: u32) -> u32;
}
extern "C" {
    pub fn htons(val: u16) -> u16;
}
extern "C" {
    pub fn ntohl(val: u32) -> u32;
}
extern "C" {
    pub fn ntohs(val: u16) -> u16;
}
#[doc = " Called when the application needs to save."]
pub type ProcUISaveCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Called when the application needs to save."]
#[doc = " void* argument is provided in ProcUIInitEx()."]
pub type ProcUISaveCallbackEx =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void) -> u32>;
#[doc = " Generic ProcUI callback."]
#[doc = " void* argument is provided in ProcUIRegisterCallback()."]
pub type ProcUICallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void) -> u32>;
pub mod ProcUICallbackType {
    pub type Type = cty::c_uint;
    #[doc = "! Application acquires the foreground"]
    pub const PROCUI_CALLBACK_ACQUIRE: Type = 0;
    #[doc = "! Application must release the foreground"]
    pub const PROCUI_CALLBACK_RELEASE: Type = 1;
    #[doc = "! Application must exit"]
    pub const PROCUI_CALLBACK_EXIT: Type = 2;
    #[doc = "! Application may start using networking"]
    pub const PROCUI_CALLBACK_NET_IO_START: Type = 3;
    #[doc = "! Application must stop using networking"]
    pub const PROCUI_CALLBACK_NET_IO_STOP: Type = 4;
    #[doc = "! The user attempted to press the HOME button but was denied"]
    pub const PROCUI_CALLBACK_HOME_BUTTON_DENIED: Type = 5;
}
pub mod ProcUIStatus {
    pub type Type = cty::c_uint;
    #[doc = "! The application is in the foreground. All resources may be used."]
    pub const PROCUI_STATUS_IN_FOREGROUND: Type = 0;
    #[doc = "! The application is in the background, only limited resources are usable."]
    pub const PROCUI_STATUS_IN_BACKGROUND: Type = 1;
    #[doc = "! The application must release the foregound - see ProcUIDrawDoneRelease()"]
    pub const PROCUI_STATUS_RELEASE_FOREGROUND: Type = 2;
    #[doc = "! The application must release all resources (including ProcUI) and quit"]
    pub const PROCUI_STATUS_EXITING: Type = 3;
}
extern "C" {
    pub fn ProcUICalcMemorySize(unk: u32) -> u32;
}
extern "C" {
    #[doc = " Unregister all ProcUI callbacks."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - ProcUIRegisterCallback()"]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " Would a currently executing async operation keep or lose the callbacks?"]
    #[doc = " does this block?"]
    #[doc = " \\endif"]
    pub fn ProcUIClearCallbacks();
}
extern "C" {
    #[doc = " Signifies to ProcUI that the current application has released all foreground"]
    #[doc = " resources, drawn its last frame, and is ready to be moved into the"]
    #[doc = " background. Should only be called when the application is in the"]
    #[doc = " #PROCUI_STATUS_RELEASE_FOREGROUND state."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " After calling this function, the context will switch next time"]
    #[doc = " ProcUIProcessMessages() is called. All user threads on core 0 and 1 will"]
    #[doc = " be suspended once this happens."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " Do not attempt to use foreground-only resources after calling this function"]
    #[doc = " and its accompanying ProcUIProcessMessages()."]
    #[doc = " You should wait until ProcUI indicates #PROCUI_STATUS_IN_FOREGROUND."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " how does SubProcessMessages fit in?"]
    #[doc = " doxy: how do you link to the description of coreinit/thread? would like to"]
    #[doc = " note that threads can't be suspended immediately"]
    #[doc = " \\endif"]
    pub fn ProcUIDrawDoneRelease();
}
extern "C" {
    #[doc = " Determines whether the application is in the foreground."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " \\c true if the application status is #PROCUI_STATUS_IN_FOREGROUND."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - #PROCUI_STATUS_IN_FOREGROUND"]
    #[doc = " - ProcUIRegisterCallback()"]
    pub fn ProcUIInForeground() -> BOOL;
}
extern "C" {
    #[doc = " Determines whether the application is in shutdown and should quit."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " \\c true if the application status is #PROCUI_STATUS_EXITING."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - #PROCUI_STATUS_EXITING"]
    #[doc = " - ProcUIRegisterCallback()"]
    pub fn ProcUIInShutdown() -> BOOL;
}
extern "C" {
    #[doc = " Initialises the ProcUI library for use."]
    #[doc = ""]
    #[doc = " \\param saveCallback"]
    #[doc = " A callback to be called when the application needs to save. The callback"]
    #[doc = " cannot be NULL and it must call OSSavesDone_ReadyToRelease()."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - OSSavesDone_ReadyToRelease()"]
    #[doc = " - ProcUISetSaveCallback()"]
    #[doc = " - ProcUIShutdown()"]
    pub fn ProcUIInit(saveCallback: ProcUISaveCallback);
}
extern "C" {
    #[doc = " Initialises the ProcUI library for use; using a save callback that takes"]
    #[doc = " arguments."]
    #[doc = ""]
    #[doc = " \\param saveCallback"]
    #[doc = " A callback to be called when the application needs to save. The callback"]
    #[doc = " cannot be NULL and it must call OSSavesDone_ReadyToRelease()."]
    #[doc = ""]
    #[doc = " \\param arg"]
    #[doc = " An argument to pass into saveCallbackEx."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - OSSavesDone_ReadyToRelease()"]
    #[doc = " - ProcUISetSaveCallback()"]
    #[doc = " - ProcUIShutdown()"]
    pub fn ProcUIInitEx(saveCallback: ProcUISaveCallbackEx, arg: *mut cty::c_void);
}
extern "C" {
    #[doc = " Determines whether the application is running."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " \\c true if the application is running."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " running? what does that actually mean? any state except exiting?"]
    #[doc = " \\endif"]
    pub fn ProcUIIsRunning() -> BOOL;
}
extern "C" {
    #[doc = " Main runloop for ProcUI. This function processes messages from the OS and"]
    #[doc = " provides it an opportinity to take control (to open the HOME menu overlay,"]
    #[doc = " for example). Returns the current state of the application."]
    #[doc = ""]
    #[doc = " \\param block"]
    #[doc = " Determines whether the function should block before returning. If \\c false,"]
    #[doc = " the function returns immediately and all messages and callbacks are processed"]
    #[doc = " asynchronously."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The current state of the program. See #ProcUIStatus. If block is \\c false,"]
    #[doc = " this value is undefined and should be ignored."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " ProcUI's non-blocking mode is not widely used and may have undocumented"]
    #[doc = " behaviour. Be careful with callbacks and the return value."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This function should only be called from the main core. See OSIsMainCore()"]
    #[doc = " and ProcUISubProcessMessages()."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " Assuming the note about core behaviour is true, based on homebrew"]
    #[doc = " \\endif"]
    pub fn ProcUIProcessMessages(block: BOOL) -> ProcUIStatus::Type;
}
extern "C" {
    #[doc = " Register a callback for certain ProcUI events."]
    #[doc = ""]
    #[doc = " \\param type"]
    #[doc = " The event to register a callback for. See #ProcUICallbackType."]
    #[doc = ""]
    #[doc = " \\param callback"]
    #[doc = " Function pointer for the callback to call when the given event occurs."]
    #[doc = ""]
    #[doc = " \\param param"]
    #[doc = " Argument for the callback. This will be passed in as the *second* argument."]
    #[doc = ""]
    #[doc = " \\param priority"]
    #[doc = " The priority of the callback."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - ProcUIRegisterCallbackCore()"]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " higher-priority callbacks exec first? dunno"]
    #[doc = " \\endif"]
    pub fn ProcUIRegisterCallback(
        type_: ProcUICallbackType::Type,
        callback: ProcUICallback,
        param: *mut cty::c_void,
        priority: u32,
    );
}
extern "C" {
    #[doc = " Register a callback for certain ProcUI events, executed on the given core."]
    #[doc = ""]
    #[doc = " \\param type"]
    #[doc = " The event to register a callback for. See #ProcUICallbackType."]
    #[doc = ""]
    #[doc = " \\param callback"]
    #[doc = " Function pointer for the callback to call when the given event occurs."]
    #[doc = ""]
    #[doc = " \\param param"]
    #[doc = " Argument for the callback. This will be passed in as the *second* argument."]
    #[doc = ""]
    #[doc = " \\param priority"]
    #[doc = " The priority of the callback."]
    #[doc = ""]
    #[doc = " \\param core"]
    #[doc = " The core ID to run the callback on."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - ProcUIRegisterCallback()"]
    pub fn ProcUIRegisterCallbackCore(
        type_: ProcUICallbackType::Type,
        callback: ProcUICallback,
        param: *mut cty::c_void,
        priority: u32,
        core: u32,
    );
}
extern "C" {
    #[doc = " Sets the save callback. Unlike ProcUIInitEx(), this function can be called"]
    #[doc = " while ProcUI is already running."]
    #[doc = ""]
    #[doc = " \\param saveCallback"]
    #[doc = " A callback to be called when the application needs to save. The callback"]
    #[doc = " cannot be NULL and it must call OSSavesDone_ReadyToRelease()."]
    #[doc = ""]
    #[doc = " \\param arg"]
    #[doc = " An argument to pass into saveCallbackEx."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - OSSavesDone_ReadyToRelease()"]
    #[doc = " - ProcUIInitEx()"]
    pub fn ProcUISetSaveCallback(saveCallback: ProcUISaveCallbackEx, arg: *mut cty::c_void);
}
extern "C" {
    #[doc = " Shut down the ProcUI library for the current application. This should be"]
    #[doc = " called before the app exits."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " Do not attempt to use any ProcUI library functions after calling this"]
    #[doc = " function, except for ProcUIInit() or ProcUIInitEx()."]
    pub fn ProcUIShutdown();
}
extern "C" {
    #[doc = " ProcUIProcessMessages(), but for secondary cores."]
    #[doc = ""]
    #[doc = " \\param block"]
    #[doc = " Determines whether the function should block before returning. If \\c false,"]
    #[doc = " the function returns immediately and all messages and callbacks are processed"]
    #[doc = " asynchronously."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The current state of the program - see #ProcUIStatus. If block is \\c false,"]
    #[doc = " this value is undefined and should be ignored."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " ProcUI's non-blocking mode is not widely used and may have undocumented"]
    #[doc = " behaviour. Be careful with callbacks and the return value."]
    #[doc = ""]
    #[doc = " \\if false"]
    #[doc = " didn't know what this did, only seen it in the else{} from OSIsMainCore..."]
    #[doc = " please research and correct!"]
    #[doc = " \\endif"]
    pub fn ProcUISubProcessMessages(block: BOOL) -> ProcUIStatus::Type;
}
#[doc = "! A value from enum AX_RESULT."]
pub type AXResult = i32;
pub mod AX_RESULT {
    pub type Type = cty::c_int;
    pub const AX_RESULT_SUCCESS: Type = 0;
    pub const AX_RESULT_INVALID_DEVICE_TYPE: Type = -1;
    pub const AX_RESULT_INVALID_DRC_VS_MODE: Type = -13;
    pub const AX_RESULT_VOICE_IS_RUNNING: Type = -18;
    pub const AX_RESULT_DELAY_TOO_BIG: Type = -19;
}
pub type AXFrameCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "! A value from enum AX_INIT_RENDERER."]
pub type AXInitRenderer = u32;
#[doc = "! A value from enum AX_INIT_PIPELINE."]
pub type AXInitPipeline = u32;
pub mod AX_INIT_RENDERER {
    pub type Type = cty::c_uint;
    pub const AX_INIT_RENDERER_32KHZ: Type = 0;
    pub const AX_INIT_RENDERER_48KHZ: Type = 1;
}
pub mod AX_INIT_PIPELINE {
    pub type Type = cty::c_uint;
    pub const AX_INIT_PIPELINE_SINGLE: Type = 0;
    pub const AX_INIT_PIPELINE_FOUR_STAGE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXProfile {}
#[test]
fn bindgen_test_layout_AXProfile() {
    assert_eq!(
        ::core::mem::size_of::<AXProfile>(),
        0usize,
        concat!("Size of: ", stringify!(AXProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<AXProfile>(),
        1usize,
        concat!("Alignment of ", stringify!(AXProfile))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXInitParams {
    pub renderer: AXInitRenderer,
    pub __unk68: [cty::c_char; 4usize],
    pub pipeline: AXInitPipeline,
}
#[test]
fn bindgen_test_layout_AXInitParams() {
    assert_eq!(
        ::core::mem::size_of::<AXInitParams>(),
        12usize,
        concat!("Size of: ", stringify!(AXInitParams))
    );
    assert_eq!(
        ::core::mem::align_of::<AXInitParams>(),
        4usize,
        concat!("Alignment of ", stringify!(AXInitParams))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXInitParams>())).renderer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXInitParams),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXInitParams>())).__unk68 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AXInitParams),
            "::",
            stringify!(__unk68)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXInitParams>())).pipeline as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AXInitParams),
            "::",
            stringify!(pipeline)
        )
    );
}
extern "C" {
    pub fn AXInit();
}
extern "C" {
    pub fn AXQuit();
}
extern "C" {
    pub fn AXInitWithParams(params: *mut AXInitParams);
}
extern "C" {
    pub fn AXIsInit() -> BOOL;
}
extern "C" {
    pub fn AXInitProfile(profile: *mut AXProfile, count: u32);
}
extern "C" {
    pub fn AXGetSwapProfile(profile: *mut AXProfile, count: u32) -> u32;
}
extern "C" {
    pub fn AXSetDefaultMixerSelect(unk0: u32) -> AXResult;
}
extern "C" {
    pub fn AXRegisterAppFrameCallback(callback: AXFrameCallback) -> AXResult;
}
extern "C" {
    pub fn AXRegisterFrameCallback(callback: AXFrameCallback) -> AXFrameCallback;
}
extern "C" {
    pub fn AXGetInputSamplesPerFrame() -> u32;
}
extern "C" {
    pub fn AXGetInputSamplesPerSec() -> u32;
}
pub type AXDeviceFinalMixCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
pub type AXAuxCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut cty::c_void)>;
#[doc = "! A value from enum AX_DEVICE_MODE."]
pub type AXDeviceMode = u32;
#[doc = "! A value from enum AX_DEVICE_TYPE."]
pub type AXDeviceType = u32;
pub mod AX_DEVICE_MODE {
    pub type Type = cty::c_uint;
    pub const AX_DEVICE_MODE_UNKNOWN: Type = 0;
}
pub mod AX_DEVICE_TYPE {
    pub type Type = cty::c_uint;
    pub const AX_DEVICE_TYPE_TV: Type = 0;
    pub const AX_DEVICE_TYPE_DRC: Type = 1;
    pub const AX_DEVICE_TYPE_CONTROLLER: Type = 2;
}
extern "C" {
    pub fn AXGetDeviceMode(type_: AXDeviceType, mode: *mut AXDeviceMode) -> AXResult;
}
extern "C" {
    pub fn AXGetDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: *mut AXDeviceFinalMixCallback,
    ) -> AXResult;
}
extern "C" {
    pub fn AXRegisterDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: AXDeviceFinalMixCallback,
    ) -> AXResult;
}
extern "C" {
    pub fn AXGetAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: *mut AXAuxCallback,
        userData: *mut *mut cty::c_void,
    ) -> AXResult;
}
extern "C" {
    pub fn AXRegisterAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: AXAuxCallback,
        userData: *mut cty::c_void,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceLinearUpsampler(type_: AXDeviceType, unk0: u32, unk1: u32) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceCompressor(type_: AXDeviceType, unk0: u32) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceUpsampleStage(type_: AXDeviceType, postFinalMix: BOOL) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceVolume(type_: AXDeviceType, id: u32, volume: u16) -> AXResult;
}
#[doc = "! A value from enum AX_DRC_VS_MODE."]
pub type AXDRCVSMode = u32;
#[doc = "! A value from enum AX_DRC_VS_OUTPUT."]
pub type AXDRCVSOutput = u32;
#[doc = "! A value from enum AX_DRC_VS_LC."]
pub type AXDRCVSLC = u32;
#[doc = "! A value from enum AX_DRC_VS_SPEAKER_POS."]
pub type AXDRCVSSpeakerPosition = u32;
#[doc = "! A value from enum AX_DRC_VS_SURROUND_GAIN."]
pub type AXDRCVSSurroundLevelGain = u32;
pub mod AX_DRC_VS_MODE {
    pub type Type = cty::c_uint;
    pub const AX_DRC_VS_MODE_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_OUTPUT {
    pub type Type = cty::c_uint;
    pub const AX_DRC_VS_OUTPUT_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_LC {
    pub type Type = cty::c_uint;
    pub const AX_DRC_VS_LC_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_SPEAKER_POS {
    pub type Type = cty::c_uint;
    pub const AX_DRC_VS_SPEAKER_POS_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_SURROUND_GAIN {
    pub type Type = cty::c_uint;
    pub const AX_DRC_VS_SURROUND_GAIN_UNKNOWN: Type = 0;
}
extern "C" {
    pub fn AXGetDRCVSMode(mode: *mut AXDRCVSMode) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSMode(mode: AXDRCVSMode) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSDownmixBalance(output: AXDRCVSOutput, balance: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLC(lc: AXDRCVSLC) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLimiter(limit: BOOL) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLimiterThreshold(threshold: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSOutputGain(output: AXDRCVSOutput, gain: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSpeakerPosition(
        output: AXDRCVSOutput,
        pos: AXDRCVSSpeakerPosition,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSurroundDepth(output: AXDRCVSOutput, depth: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSurroundLevelGain(gain: AXDRCVSSurroundLevelGain) -> AXResult;
}
#[doc = "! A value from enum AX_VOICE_FORMAT."]
pub type AXVoiceFormat = u16;
#[doc = "! A value from enum AX_VOICE_LOOP."]
pub type AXVoiceLoop = u16;
#[doc = "! A value from enum AX_VOICE_SRC_TYPE."]
pub type AXVoiceSrcType = u32;
#[doc = "! A value from enum AX_VOICE_STATE."]
pub type AXVoiceState = u32;
#[doc = "! A value from enum AX_VOICE_RENDERER."]
pub type AXVoiceRenderer = u32;
#[doc = "! A value from enum AX_VOICE_RATIO_RESULT."]
pub type AXVoiceSrcRatioResult = i32;
#[doc = "! A value from enum AX_VOICE_TYPE."]
pub type AXVoiceType = u32;
pub type AXVoiceCallbackFn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
pub type AXVoiceCallbackExFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: u32, arg3: u32)>;
pub mod AX_VOICE_FORMAT {
    pub type Type = cty::c_uint;
    pub const AX_VOICE_FORMAT_ADPCM: Type = 0;
    pub const AX_VOICE_FORMAT_LPCM16: Type = 10;
    pub const AX_VOICE_FORMAT_LPCM8: Type = 25;
}
pub mod AX_VOICE_LOOP {
    pub type Type = cty::c_uint;
    pub const AX_VOICE_LOOP_DISABLED: Type = 0;
    pub const AX_VOICE_LOOP_ENABLED: Type = 1;
}
pub mod AX_VOICE_RENDERER {
    pub type Type = cty::c_uint;
    pub const AX_VOICE_RENDERER_DSP: Type = 0;
    pub const AX_VOICE_RENDERER_CPU: Type = 1;
    pub const AX_VOICE_RENDERER_AUTO: Type = 2;
}
pub mod AX_VOICE_RATIO_RESULT {
    pub type Type = cty::c_int;
    pub const AX_VOICE_RATIO_RESULT_SUCCESS: Type = 0;
    pub const AX_VOICE_RATIO_RESULT_LESS_THAN_ZERO: Type = -1;
    pub const AX_VOICE_RATIO_RESULT_GREATER_THAN_SOMETHING: Type = -2;
}
pub mod AX_VOICE_SRC_TYPE {
    pub type Type = cty::c_uint;
    pub const AX_VOICE_SRC_TYPE_NONE: Type = 0;
    pub const AX_VOICE_SRC_TYPE_LINEAR: Type = 1;
    pub const AX_VOICE_SRC_TYPE_UNK0: Type = 2;
    pub const AX_VOICE_SRC_TYPE_UNK1: Type = 3;
    pub const AX_VOICE_SRC_TYPE_UNK2: Type = 4;
}
pub mod AX_VOICE_STATE {
    pub type Type = cty::c_uint;
    pub const AX_VOICE_STATE_STOPPED: Type = 0;
    pub const AX_VOICE_STATE_PLAYING: Type = 1;
}
pub mod AX_VOICE_TYPE {
    pub type Type = cty::c_uint;
    pub const AX_VOICE_TYPE_UNKNOWN: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceLink {
    pub next: *mut AXVoice,
    pub prev: *mut AXVoice,
}
#[test]
fn bindgen_test_layout_AXVoiceLink() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceLink>(),
        8usize,
        concat!("Size of: ", stringify!(AXVoiceLink))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceLink>(),
        4usize,
        concat!("Alignment of ", stringify!(AXVoiceLink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceLink>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceLink),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceLink>())).prev as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceLink),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceOffsets {
    pub dataType: AXVoiceFormat,
    pub loopingEnabled: AXVoiceLoop,
    pub loopOffset: u32,
    pub endOffset: u32,
    pub currentOffset: u32,
    pub data: *const cty::c_void,
}
#[test]
fn bindgen_test_layout_AXVoiceOffsets() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceOffsets>(),
        20usize,
        concat!("Size of: ", stringify!(AXVoiceOffsets))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceOffsets>(),
        4usize,
        concat!("Alignment of ", stringify!(AXVoiceOffsets))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceOffsets>())).dataType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceOffsets),
            "::",
            stringify!(dataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceOffsets>())).loopingEnabled as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceOffsets),
            "::",
            stringify!(loopingEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceOffsets>())).loopOffset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceOffsets),
            "::",
            stringify!(loopOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceOffsets>())).endOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceOffsets),
            "::",
            stringify!(endOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceOffsets>())).currentOffset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceOffsets),
            "::",
            stringify!(currentOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceOffsets>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceOffsets),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoice {
    #[doc = "! The index of this voice out of the total voices"]
    pub index: u32,
    #[doc = "! Current play state of this voice"]
    pub state: AXVoiceState,
    #[doc = "! Current volume of this voice"]
    pub volume: u32,
    #[doc = "! The renderer to use for this voice"]
    pub renderer: AXVoiceRenderer,
    #[doc = "! this is a link used in the stack, we do this in host-memory currently"]
    pub link: AXVoiceLink,
    #[doc = "! A link to the next callback to invoke"]
    pub cbNext: *mut AXVoice,
    #[doc = "! The priority of this voice used for force-acquiring a voice"]
    pub priority: u32,
    #[doc = "! The callback to call if this is force-free'd by another acquire"]
    pub callback: AXVoiceCallbackFn,
    #[doc = "! The user context to send to the callbacks"]
    pub userContext: *mut cty::c_void,
    #[doc = "! A bitfield representing different things needing to be synced."]
    pub syncBits: u32,
    pub __unk69: [cty::c_char; 8usize],
    #[doc = "! The current offset data!"]
    pub offsets: AXVoiceOffsets,
    #[doc = "! An extended version of the callback above"]
    pub callbackEx: AXVoiceCallbackExFn,
    #[doc = "! The reason for the callback being invoked"]
    pub callbackReason: u32,
    pub unk0: f32,
    pub unk1: f32,
}
#[test]
fn bindgen_test_layout_AXVoice() {
    assert_eq!(
        ::core::mem::size_of::<AXVoice>(),
        88usize,
        concat!("Size of: ", stringify!(AXVoice))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoice>(),
        4usize,
        concat!("Alignment of ", stringify!(AXVoice))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).volume as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).renderer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).cbNext as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(cbNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).priority as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).userContext as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(userContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).syncBits as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(syncBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).__unk69 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(__unk69)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).offsets as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).callbackEx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(callbackEx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).callbackReason as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(callbackReason)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).unk0 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(unk0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoice>())).unk1 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoice),
            "::",
            stringify!(unk1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceDeviceBusMixData {
    pub volume: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_AXVoiceDeviceBusMixData() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceDeviceBusMixData>(),
        4usize,
        concat!("Size of: ", stringify!(AXVoiceDeviceBusMixData))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceDeviceBusMixData>(),
        2usize,
        concat!("Alignment of ", stringify!(AXVoiceDeviceBusMixData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceDeviceBusMixData>())).volume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceDeviceBusMixData),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceDeviceBusMixData>())).delta as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceDeviceBusMixData),
            "::",
            stringify!(delta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceDeviceMixData {
    pub bus: [AXVoiceDeviceBusMixData; 4usize],
}
#[test]
fn bindgen_test_layout_AXVoiceDeviceMixData() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceDeviceMixData>(),
        16usize,
        concat!("Size of: ", stringify!(AXVoiceDeviceMixData))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceDeviceMixData>(),
        2usize,
        concat!("Alignment of ", stringify!(AXVoiceDeviceMixData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceDeviceMixData>())).bus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceDeviceMixData),
            "::",
            stringify!(bus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceVeData {
    pub volume: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_AXVoiceVeData() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceVeData>(),
        4usize,
        concat!("Size of: ", stringify!(AXVoiceVeData))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceVeData>(),
        2usize,
        concat!("Alignment of ", stringify!(AXVoiceVeData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceVeData>())).volume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceVeData),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceVeData>())).delta as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceVeData),
            "::",
            stringify!(delta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceAdpcmLoopData {
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[test]
fn bindgen_test_layout_AXVoiceAdpcmLoopData() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceAdpcmLoopData>(),
        6usize,
        concat!("Size of: ", stringify!(AXVoiceAdpcmLoopData))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceAdpcmLoopData>(),
        2usize,
        concat!("Alignment of ", stringify!(AXVoiceAdpcmLoopData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceAdpcmLoopData>())).predScale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceAdpcmLoopData),
            "::",
            stringify!(predScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AXVoiceAdpcmLoopData>())).prevSample as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceAdpcmLoopData),
            "::",
            stringify!(prevSample)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceAdpcm {
    pub coefficients: [i16; 16usize],
    pub gain: u16,
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[test]
fn bindgen_test_layout_AXVoiceAdpcm() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceAdpcm>(),
        40usize,
        concat!("Size of: ", stringify!(AXVoiceAdpcm))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceAdpcm>(),
        2usize,
        concat!("Alignment of ", stringify!(AXVoiceAdpcm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceAdpcm>())).coefficients as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceAdpcm),
            "::",
            stringify!(coefficients)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceAdpcm>())).gain as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceAdpcm),
            "::",
            stringify!(gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceAdpcm>())).predScale as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceAdpcm),
            "::",
            stringify!(predScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceAdpcm>())).prevSample as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceAdpcm),
            "::",
            stringify!(prevSample)
        )
    );
}
#[doc = " AXVoice Sample Rate Converter"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceSrc {
    #[doc = "! Playback rate, fixed 16.16"]
    pub ratio: u32,
    #[doc = "! Used by the resampler, fixed 0.16"]
    pub currentOffsetFrac: u16,
    pub lastSample: [i16; 4usize],
}
#[test]
fn bindgen_test_layout_AXVoiceSrc() {
    assert_eq!(
        ::core::mem::size_of::<AXVoiceSrc>(),
        14usize,
        concat!("Size of: ", stringify!(AXVoiceSrc))
    );
    assert_eq!(
        ::core::mem::align_of::<AXVoiceSrc>(),
        1usize,
        concat!("Alignment of ", stringify!(AXVoiceSrc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceSrc>())).ratio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceSrc),
            "::",
            stringify!(ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceSrc>())).currentOffsetFrac as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceSrc),
            "::",
            stringify!(currentOffsetFrac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AXVoiceSrc>())).lastSample as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AXVoiceSrc),
            "::",
            stringify!(lastSample)
        )
    );
}
extern "C" {
    pub fn AXVoiceBegin(v: *mut AXVoice) -> i32;
}
extern "C" {
    pub fn AXVoiceEnd(v: *mut AXVoice) -> i32;
}
extern "C" {
    pub fn AXAcquireVoice(
        priority: u32,
        callback: AXVoiceCallbackFn,
        userContext: *mut cty::c_void,
    ) -> *mut AXVoice;
}
extern "C" {
    pub fn AXAcquireVoiceEx(
        priority: u32,
        callback: AXVoiceCallbackExFn,
        userContext: *mut cty::c_void,
    ) -> *mut AXVoice;
}
extern "C" {
    pub fn AXCheckVoiceOffsets(offsets: *mut AXVoiceOffsets) -> BOOL;
}
extern "C" {
    pub fn AXFreeVoice(voice: *mut AXVoice);
}
extern "C" {
    pub fn AXGetMaxVoices() -> u32;
}
extern "C" {
    pub fn AXGetVoiceCurrentOffsetEx(voice: *mut AXVoice, samples: *const cty::c_void) -> u32;
}
extern "C" {
    pub fn AXGetVoiceLoopCount(voice: *mut AXVoice) -> u32;
}
extern "C" {
    pub fn AXGetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
}
extern "C" {
    pub fn AXIsVoiceRunning(voice: *mut AXVoice) -> BOOL;
}
extern "C" {
    pub fn AXSetVoiceAdpcm(voice: *mut AXVoice, adpcm: *mut AXVoiceAdpcm);
}
extern "C" {
    pub fn AXSetVoiceAdpcmLoop(voice: *mut AXVoice, loopData: *mut AXVoiceAdpcmLoopData);
}
extern "C" {
    pub fn AXSetVoiceCurrentOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceDeviceMix(
        voice: *mut AXVoice,
        type_: AXDeviceType,
        id: u32,
        mixData: *mut AXVoiceDeviceMixData,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetVoiceEndOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceEndOffsetEx(voice: *mut AXVoice, offset: u32, samples: *const cty::c_void);
}
extern "C" {
    pub fn AXSetVoiceInitialTimeDelay(voice: *mut AXVoice, delay: u16) -> AXResult;
}
extern "C" {
    pub fn AXSetVoiceLoopOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceLoopOffsetEx(voice: *mut AXVoice, offset: u32, samples: *const cty::c_void);
}
extern "C" {
    pub fn AXSetVoiceLoop(voice: *mut AXVoice, loop_: AXVoiceLoop);
}
extern "C" {
    pub fn AXSetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
}
extern "C" {
    pub fn AXSetVoicePriority(voice: *mut AXVoice, priority: u32);
}
extern "C" {
    pub fn AXSetVoiceRmtIIRCoefs(voice: *mut AXVoice, filter: u16, ...);
}
extern "C" {
    pub fn AXSetVoiceSrc(voice: *mut AXVoice, src: *mut AXVoiceSrc);
}
extern "C" {
    pub fn AXSetVoiceSrcRatio(voice: *mut AXVoice, ratio: f32) -> AXVoiceSrcRatioResult;
}
extern "C" {
    pub fn AXSetVoiceSrcType(voice: *mut AXVoice, type_: AXVoiceSrcType);
}
extern "C" {
    pub fn AXSetVoiceState(voice: *mut AXVoice, state: AXVoiceState);
}
extern "C" {
    pub fn AXSetVoiceType(voice: *mut AXVoice, type_: AXVoiceType);
}
extern "C" {
    pub fn AXSetVoiceVe(voice: *mut AXVoice, veData: *mut AXVoiceVeData);
}
extern "C" {
    pub fn AXSetVoiceVeDelta(voice: *mut AXVoice, delta: i16);
}
extern "C" {
    #[doc = " Restarts the current title with new arguments once the running application"]
    #[doc = " quits, and requests the application exit immediately (through \\link"]
    #[doc = " proc_ui_procui ProcUI\\endlink). Instead of returning to the HOME menu upon"]
    #[doc = " exit, the system will start the same title again."]
    #[doc = ""]
    #[doc = " \\param argc"]
    #[doc = " The number of strings in the pa_Argv array. Passed in to the title's main"]
    #[doc = " function as argc."]
    #[doc = ""]
    #[doc = " \\param pa_Argv"]
    #[doc = " An array of strings to use as arguments. Passed into the title's main"]
    #[doc = " function as argv."]
    #[doc = ""]
    #[doc = " <!--"]
    #[doc = "    meta: why pa_?"]
    #[doc = "    do we need to include the rpx name in argv[0]?"]
    #[doc = "    behaviour where pa_Argv = NULL?"]
    #[doc = " -->"]
    pub fn SYSRelaunchTitle(argc: u32, pa_Argv: *mut *mut cty::c_char);
}
extern "C" {
    #[doc = " Launches the HOME menu when the current application exits, and requests the"]
    #[doc = " application exit immediately (through \\link proc_ui_procui ProcUI\\endlink)."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This is the default behaviour upon application exit."]
    pub fn SYSLaunchMenu();
}
extern "C" {
    #[doc = " Launch the given title ID once the current application exits, and requests"]
    #[doc = " the application exit immediately (through"]
    #[doc = " \\link proc_ui_procui ProcUI\\endlink). Instead of opening the HOME menu once"]
    #[doc = " the current application quits, the system will load the given title with"]
    #[doc = " default arguments."]
    #[doc = ""]
    #[doc = " <!--"]
    #[doc = "    what happens on an incorrect titleid?"]
    #[doc = "    argc/argv?"]
    #[doc = " -->"]
    pub fn SYSLaunchTitle(TitleId: u64);
}
extern "C" {
    #[doc = " Launch Mii Maker once the current application exits."]
    #[doc = " <!-- there's a version without the underscore, use that? -->"]
    pub fn _SYSLaunchMiiStudio();
}
extern "C" {
    #[doc = " Launch System Settings once the current application exits."]
    pub fn _SYSLaunchSettings();
}
extern "C" {
    #[doc = " Launch Parental Controls once the current application exits."]
    pub fn _SYSLaunchParental();
}
extern "C" {
    #[doc = " Launch Notifications once the current application exits."]
    #[doc = ""]
    #[doc = " <!--"]
    #[doc = "    isn't this an overlay app? does this really run on exit?"]
    #[doc = " -->"]
    pub fn _SYSLaunchNotifications();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppBrowserArgs {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initiate a switch into the controller sync menu. This is the same menu"]
    #[doc = " that can be accessed from the HOME menu overlay (HBM)."]
    #[doc = ""]
    #[doc = " The current application is moved into the background (see \\link"]
    #[doc = " proc_ui_procui ProcUI\\endlink) and the sync menu is shown. Once the user"]
    #[doc = " exits the menu, the application is moved back to the foreground."]
    pub fn SYSSwitchToSyncControllerOnHBM();
}
extern "C" {
    #[doc = " Initiate a switch to the current title's assosciated e-manual."]
    #[doc = ""]
    #[doc = " The current application is moved into the background (see \\link"]
    #[doc = " proc_ui_procui ProcUI\\endlink) and the e-manual is shown. Once the user"]
    #[doc = " exits the menu, the application is moved back to the foreground."]
    pub fn SYSSwitchToEManual();
}
extern "C" {
    #[doc = " Initiate a switch to the Nintendo eShop application."]
    #[doc = ""]
    #[doc = " The current application is moved into the background (see \\link"]
    #[doc = " proc_ui_procui ProcUI\\endlink) and the Nintendo eShop is shown. Once the user"]
    #[doc = " exits the menu, the application is moved back to the foreground."]
    pub fn SYSSwitchToEShop();
}
extern "C" {
    #[doc = " <!--"]
    #[doc = "    ..?"]
    #[doc = "    Current app moves into background then immediately back out again."]
    #[doc = "    Presumably meant for overlay apps to exit?"]
    #[doc = " -->"]
    pub fn _SYSSwitchToMainApp();
}
extern "C" {
    #[doc = " Initiates a switch to the Internet Browser application, with the given"]
    #[doc = " arguments in the form of a \\link SysAppBrowserArgs \\endlink struct."]
    #[doc = ""]
    #[doc = " The current application is moved into the background (see \\link"]
    #[doc = " proc_ui_procui ProcUI\\endlink) and the Internet Browser is shown. Once the"]
    #[doc = " user exits the menu, the application is moved back to the foreground."]
    pub fn SYSSwitchToBrowserForViewer(arg1: *mut SysAppBrowserArgs);
}
pub mod SYSTEM_APP_ID {
    pub type Type = cty::c_uint;
    pub const SYSTEM_APP_ID_HOME_MENU: Type = 0;
    pub const SYSTEM_APP_ID_SYSTEM_SETTINGS: Type = 1;
    pub const SYSTEM_APP_ID_PARENTAL_CONTROLS: Type = 2;
    pub const SYSTEM_APP_ID_USER_SETTINGS: Type = 3;
    pub const SYSTEM_APP_ID_MII_MAKER: Type = 4;
    pub const SYSTEM_APP_ID_ACCOUNT_SETTINGS: Type = 5;
    pub const SYSTEM_APP_ID_DAILY_LOG: Type = 6;
    pub const SYSTEM_APP_ID_NOTIFICATIONS: Type = 7;
    pub const SYSTEM_APP_ID_HEALTH_AND_SAFETY: Type = 8;
    pub const SYSTEM_APP_ID_ELECTRONIC_MANUAL: Type = 9;
    pub const SYSTEM_APP_ID_WIIU_CHAT: Type = 10;
    pub const SYSTEM_APP_ID_SOFTWARE_DATA_TRANSFER: Type = 11;
}
extern "C" {
    pub static SYSTEM_APP_ID_UPDATER: SYSTEM_APP_ID::Type;
}
extern "C" {
    #[doc = " Check if a given title exists and is installed on the system."]
    #[doc = ""]
    #[doc = " \\param TitleId"]
    #[doc = " The ID of the title to check."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " \\c TRUE if the title exists, or \\c FALSE otherwise."]
    pub fn SYSCheckTitleExists(TitleId: u64) -> BOOL;
}
extern "C" {
    #[doc = " Gets the PFID/UPID for a given title."]
    #[doc = ""]
    #[doc = " \\param TitleId"]
    #[doc = " The ID of the title to get the PFID/UPID from."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The PFID/UPID for the title, or a negative value on error."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This function is identical to \\link SYSGetUPIDFromTitleID \\endlink."]
    pub fn SYSGetPFIDFromTitleID(TitleId: u64) -> i32;
}
extern "C" {
    #[doc = " Gets the PFID/UPID for a given title."]
    #[doc = ""]
    #[doc = " \\param TitleId"]
    #[doc = " The ID of the title to get the PFID/UPID from."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " The PFID/UPID for the title, or a negative value on error."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This function is identical to \\link SYSGetPFIDFromTitleID \\endlink."]
    pub fn SYSGetUPIDFromTitleID(TitleId: u64) -> i32;
}
extern "C" {
    #[doc = " Gets the PFID/UPID of the calling (current) application."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This function is identical to \\link SYSGetCallerPFID \\endlink."]
    pub fn SYSGetCallerUPID() -> i32;
}
extern "C" {
    #[doc = " Gets the PFID/UPID of the calling (current) application."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This function is identical to \\link SYSGetCallerUPID \\endlink."]
    pub fn SYSGetCallerPFID() -> i32;
}
extern "C" {
    #[doc = " Gets the title id for a given SYSTEM_APP_ID."]
    #[doc = ""]
    pub fn _SYSGetSystemApplicationTitleId(id: SYSTEM_APP_ID::Type) -> u64;
}
extern "C" {
    #[doc = " Gets the title id for a given SYSTEM_APP_ID in the given region."]
    #[doc = ""]
    pub fn _SYSGetSystemApplicationTitleIdByProdArea(
        id: SYSTEM_APP_ID::Type,
        prod_area: MCPRegion::Type,
    ) -> u64;
}
extern "C" {
    #[doc = " Gets the title id of the calling (current) application."]
    #[doc = ""]
    pub fn SYSGetCallerTitleId() -> u64;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gpr: cty::c_uchar,
    pub fpr: cty::c_uchar,
    pub reserved: cty::c_ushort,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        12usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fpr as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
